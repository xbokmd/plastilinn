<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plastilinn</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
    <link rel="stylesheet" href="https://stackedit.io/style.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap" rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
</head>

<body>
    <div id="vue-app">
        <div class="min-h-screen h-screen flex flex-col">
            <!-- HEADER -->
            <header class="border-b border-gray-200">
                <div id="top-container" class="bg-gray-200 w-full fixed">
                    <div id="navbar" class="navbar bg-base-100 shadow-2xl">
                        <div class="navbar-start">
                            <div class="p-5">
                                <img src="assets/logo.png" alt="Logo de mi empresa" class="h-8">
                            </div>
                            <kbd class="kbd kbd-xs">Plastilinn V0.3.0</kbd>
                            <div class="flex flex-row justify-between gap-2">
                                <button @click="changeSidebar('guides')"
                                    class="collapse-filter-button btn btn-primary btn-outline btn-sm">
                                    <span class="material-symbols-outlined" translate="no">
                                        fact_check
                                    </span>Guides</button>
                                <button @click="changeSidebar('index')"
                                    class="collapse-filter-button btn btn-primary btn-outline btn-sm">
                                    <span class="material-symbols-outlined" translate="no">
                                        list_alt
                                    </span>Index</button>
                                <button @click="changeSidebar('filter')"
                                    class="collapse-filter-button btn btn-primary btn-outline btn-sm">
                                    <span class="material-symbols-outlined" translate="no">
                                        filter_alt
                                    </span>Filter</button>
                                <button @click="changeSidebar('search')"
                                    class="collapse-filter-button btn btn-primary btn-outline btn-sm">
                                    <span class="material-symbols-outlined" translate="no">
                                        search
                                    </span>Search</button>
                            </div>
                        </div>
                        <div class="navbar-center">
                            <div class="flex-1 text-center rounded-lg p-2 m-2" v-if="modelName">
                                <h4>{{ modelName }}
                                    <button @click="openEditorInModal" class="btn btn-primary btn-outline">
                                        edit
                                    </button>
                                </h4>
                            </div>
                        </div>
                        <div class="navbar-end">
                            <div class="join">
                                <button id="downloadBtn" @click="downloadMarkdown"
                                    class="btn join-item btn-primary btn-outline no-animation">
                                    <span class="material-symbols-outlined" translate="no">
                                        download_for_offline
                                    </span>
                                    Download
                                </button>
                                <button id="exportBtn" @click="downloadHTML"
                                    class="btn join-item btn-primary btn-outline no-animation">
                                    <span class="material-symbols-outlined" translate="no">
                                        download_for_offline
                                    </span>
                                    Export
                                </button>
                                <button @click="toggleAutoDownload"
                                    :class="{'bg-green-500': autoDownloadEnabled, 'bg-gray-500': !autoDownloadEnabled}"
                                    class="btn join-item btn-primary btn-outline no-animation">
                                    <span class="material-symbols-outlined" translate="no">
                                        toggle_on
                                    </span>
                                    Auto Download {{ autoDownloadEnabled ? 'ON' : 'OFF' }}
                                </button>
                            </div>
                        </div>
                    </div>

                </div>
            </header>
            <!-- MAIN CONTAINER -->
            <div class="flex-1 flex flex-row overflow-y-hidden">
                <!-- SIDEBAR -->
                <nav class="order-first w-1/4 overflow-y-auto custom-scrollbar"
                    style="min-width: 520px; scroll-behavior: smooth;">
                    <!-- Secciones con visibilidad condicional -->
                    <div class="p-2">
                        <div v-if="currentSidebarSection === 'guides'">
                            <div v-if="markdownGuideContent">
                                <div v-html="markdownGuideContent"></div>
                            </div>
                        </div>
                        <div
                            v-bind:class="{ block: currentSidebarSection === 'index', hidden: currentSidebarSection !== 'index' }">
                            <div class="index">
                                <ul class="menu p-4 w-80 bg-base-100">
                                    <li v-for="block in model.filter(b => b.type === 'section')" :key="block.id"
                                        :class="`pl-${block.depthLevel * 4} p-0`">
                                        <a class="link link-primary" :href="'#' + block.title">{{ block.title }}</a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                        <div
                            v-bind:class="{ block: currentSidebarSection === 'filter', hidden: currentSidebarSection !== 'filter' }">
                            <div class=" flex justify-between bg-white" v-if="filterVisible">
                                <div class="flex flex-col gap-4">
                                    <div class="flex flex-col w-full">
                                        <div class="flex flex-col w-full p-4 bg-white rounded-lg shadow-sm">
                                            <!-- Filtro de etiquetas -->
                                            <div class="flex flex-col mt-4">
                                                <div class="flex flex-col mb-4 p-2 bg-gray-200 rounded-lg shadow">
                                                    <!-- Encabezado con Filter y Reset en la misma lÃ­nea -->
                                                    <div class="flex justify-between items-center mb-2">
                                                        <span class="text-lg font-semibold">Filtered tags and
                                                            markers</span>
                                                        <button @click="resetSelectedTagsAndMarkers"
                                                            class="btn btn-ghost">
                                                            <span class="material-symbols-outlined"
                                                                translate="no">restart_alt</span>
                                                            Reset
                                                        </button>
                                                    </div>
                                                    <!-- Contenedor para las etiquetas, ahora debajo del encabezado -->
                                                    <div id="show-selected"
                                                        class="flex flex-wrap p-2 gap-2 rounded bg-red-300">
                                                        <div class="flex flex-wrap gap-2">
                                                            <span v-for="tag in selectedTags" :key="tag"
                                                                class="flex items-center justify-center h-8 px-2 text-sm"
                                                                :data-tag="tag">{{ tag }}</span>
                                                            <span v-for="marker in selectedMarkers" :key="marker"
                                                                class="flex items-center justify-center h-8 px-2 text-sm"
                                                                :data-marker="marker">{{ marker }}</span>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="tag-group mb-4 px-2 py-3 bg-gray-200 rounded-md shadow-lg">
                                                    <div class="tag-name text-center font-semibold text-blue-600 mb-2">
                                                        Tags
                                                    </div>
                                                    <ul class="flex justify-center items-center flex-wrap gap-2">
                                                        <li v-for="tag in tags" :key="`tag-${tag}`"
                                                            class="filter-switch-item">
                                                            <input class="checkbox checkbox-primary sr-only"
                                                                :id="`tag-${tag}`" :value="tag" type="checkbox"
                                                                @change="toggleTagSelection(`${tag}`)">
                                                            <label :for="`tag-${tag}`"
                                                                class="cursor-pointer inline-block text-sm text-gray-600 hover:text-gray-800 bg-white rounded shadow p-1">
                                                                <span :data-tag="tag">{{ tag }}</span>
                                                            </label>
                                                        </li>
                                                    </ul>
                                                </div>
                                            </div>
                                            <div v-for="(values, markerName) in prepareMarkers()" :key="markerName"
                                                class="marker-group mb-4 px-2 py-3 bg-gray-200 rounded-md shadow-lg">
                                                <div class="marker-name text-center font-semibold text-blue-600 mb-2">{{
                                                    markerName }}</div>
                                                <ul class="flex justify-center items-center flex-wrap gap-2">
                                                    <li v-for="value in values" :key="`marker-${markerName}-${value}`"
                                                        class="filter-switch-item">
                                                        <input class="checkbox checkbox-primary sr-only"
                                                            :id="`marker-${markerName}-${value}`"
                                                            :value="`${markerName}:${value}`" type="checkbox"
                                                            @change="toggleMarkerSelection(`${value}`)">
                                                        <label :for="`marker-${markerName}-${value}`"
                                                            class="cursor-pointer inline-block text-sm text-gray-600 hover:text-gray-800 bg-white rounded shadow p-1">{{
                                                            value }}</label>
                                                    </li>
                                                </ul>
                                            </div>
                                        </div>
                                        <div class="">
                                            <!-- Botones para aplicar filtros directamente -->
                                            <div class="rounded-lg shadow-md overflow-hidden border border-red-500 m-2">
                                                <button @click="setFilterTags(['!!!!!', '!!!!'])"
                                                    class="bg-red-500 text-white px-4 py-2 hover:bg-red-600 focus:ring-red-500 focus:ring-opacity-50 w-full">
                                                    High priority
                                                </button>
                                                <div class="flex items-center bg-gray-100 px-4 py-2">
                                                    <p>
                                                        <span data-marker="!!!!!">!!!!!</span> <kbd
                                                            class="kbd kbd-xs">#!!!!!</kbd> or
                                                        <span data-marker="!!!!">!!!!</span> <kbd
                                                            class="kbd kbd-xs">#!!!!</kbd>
                                                    </p>
                                                </div>
                                            </div>
                                            <div class="rounded-lg shadow-md overflow-hidden border border-red-500 m-2">
                                                <button @click="setFilterTags(['*****', '?????'])"
                                                    class="bg-red-500 text-white px-4 py-2 hover:bg-red-600 focus:ring-red-500 focus:ring-opacity-50 w-full">
                                                    High importance or uncertainty
                                                </button>
                                                <div class="flex items-center bg-gray-100 px-4 py-2">
                                                    <p>
                                                        <span data-marker="*****">*****</span> <kbd
                                                            class="kbd kbd-xs">#*****</kbd> or
                                                        <span data-marker="?????">?????</span> <kbd
                                                            class="kbd kbd-xs">#?????</kbd>
                                                    </p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div
                            v-bind:class="{ block: currentSidebarSection === 'search', hidden: currentSidebarSection !== 'search' }">
                            <div class="flex flex-col mb-4 p-2 bg-gray-200 rounded-lg shadow">
                                <h5 class="card-title">Search and replace</h5>
                                <div class="flex items-center mb-4 p-2 bg-gray-50 rounded-lg shadow">
                                    <span class="material-symbols-outlined" translate="no">
                                        search
                                    </span>
                                    <input v-model="searchQuery" id="seach-query" type="text" placeholder="Search..."
                                        class="input ml-2 bg-gray-50 w-full">
                                </div>
                                <div class="flex items-center mb-4 p-2 bg-gray-50 rounded-lg shadow">
                                    <span class="material-symbols-outlined" translate="no">
                                        find_replace
                                    </span>
                                    <input v-model="replaceText" id="replace-text" type="text"
                                        placeholder="Replace with..." class="input ml-2 bg-gray-50 w-full">
                                </div>
                                <button @click="replaceMatches" class="btn">Replace</button>
                            </div>
                        </div>
                    </div>
                </nav>
                <!-- CONTENT -->
                <main class="flex-auto border-l border-r border-gray-200 overflow-y-auto"
                    style="scroll-behavior: smooth;">
                    <div class="toast toast-top toast-end">
                        <div class="alert mt-20">
                            <button @click="changeSidebar('guides')" class="btn btn-link btn-sm"><a
                                    href="#editing-your-plastilinn-doc">âEditing Your
                                    Plastilinn doc</a></button>
                        </div>
                    </div>
                    <div class="leading-10">
                        <div id="content" class="bg-gray-200 p-1 rounded">
                            <div class="plastilinn-hero hero pt-12" v-if="!modelMarkdownLoaded">
                                <div class="hero-content text-center">
                                    <div class="">
                                        <div class="m-auto p-12">
                                            <div class="flex flex-col md:flex-row">
                                                <div class="flex flex-col justify-center">
                                                </div>
                                            </div>
                                        </div>
                                        <div
                                            class="md:text-5xl text-2xl uppercase font-black bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-500">
                                            Shape your business with AI
                                        </div>
                                        <div class="text-xl m-4">Design, analyze and validate your business model.
                                        </div>
                                        <div class="card bg-base-100 shadow-xl">
                                            <div class="card-body flex justify-center items-center">
                                                <h2>â¬ï¸ I'm already using plastilinn</h2>
                                                Load or drag and drop your plastilinn doc
                                                <input type="file" @change="loadAndParseModelFile" accept=".md"
                                                    class="file-input file-input-bordered file-input-primary w-full max-w-xs m-4">
                                            </div>
                                        </div>
                                        <div class="card bg-base-100 shadow-xl mt-4">
                                            <div class="card-body flex justify-center items-center">
                                                <h2>ð I'm new to plastilinn and I want to:</h2>
                                                <div class="card-actions">
                                                    <a href="#improve-an-existing-business">ð Improve an existing
                                                        business</a>
                                                </div>
                                                <div class="card-actions">
                                                    <a href="#create-a-new-business-from-scratch">âï¸ Create a new
                                                        business
                                                        from scratch</a>
                                                </div>
                                                <div class="card-actions">
                                                    <a href="#try-plastilinn">ð Try plastilinn</a>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="modelContainer m-2 p-0">
                                <div class="flex flex-row w-full">
                                    <div class="md-block-wrapper w-full">
                                        <div v-for="block in searchFilteredBlocks" :key="block.id" :id="block.title"
                                            class="md-block flex">
                                            <div
                                                class="md-block-container-middle md-block-content shadow-xl hover:shadow-2xl transition-shadow custom-flex-2">
                                                <div v-html="block.contentParsed"></div>
                                            </div>
                                            <div
                                                class="md-block-container-right metadata-container text-gray-500 w-full rounded-md text-sm text-center">
                                                <div
                                                    class="flex flex-col items-start justify-start w-full bg-gray-200 rounded-md text-sm text-gray-500">
                                                    <div class="xbok-block-tags flex items-center">
                                                        <button @click="openBlockEditModal(block)"
                                                            class="btn btn-primary btn-outline btn-outline bg-base-200 p-2 rounded opacity-100 hover:opacity-100 focus:opacity-100">
                                                            ð
                                                        </button>
                                                        <div :id="block.metamodel.name"
                                                            class="block-metamodel section inline-flex"
                                                            v-if="block.metamodel">
                                                            <button @click="openInfoModal(block.metamodel.name)"
                                                                class="btn btn-primary btn-outline btn-outline bg-base-200 p-2 rounded opacity-100 hover:opacity-100 focus:opacity-100">
                                                                ð
                                                            </button>
                                                        </div>
                                                        <div class="md-block-container-right markers-container"
                                                            v-html="block.markersParsed">
                                                        </div>
                                                        <div class="md-block-container-right metadata-container"
                                                            v-html="block.tagsParsed">
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div id="content" class="mt-48 ml-2 mr-2">
                                <div class="flex flex-row w-full">
                                    <div class="md-block-wrapper w-full">
                                        <div v-for="block in filteredBlocks" :key="block.id" :id="block.title"
                                            class="md-block flex">
                                            <!-- Renderizar los bloques -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
            <!-- FOOTER -->
            <!-- <footer class="border-t border-gray-200 p-2">Footer</footer> -->
        </div>
        <!-- MODAL WINDOWS -->
        <!-- Modal para editar el contenido del bloque seleccionada -->
        <div v-if="isBlockEditModalOpen"
            class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full items-center z-50">
            <div class="modal-background absolute inset-0 bg-black opacity-50"></div>
            <div class="relative top-10 mx-auto p-1 border w-4/5 h-4/5 shadow-lg rounded-md bg-white flex flex-col justify-center items-center"
                style="z-index: 100;">
                <div>
                    <div class="text-center">
                        <button class="btn m-2 btn-success" @click="saveChanges">
                            <span class="material-symbols-outlined" translate="no">
                                save
                            </span>
                            Save changes
                        </button>
                        <button class="btn m-2 btn-error" @click="closeModal">
                            <span class="material-symbols-outlined" translate="no">
                                cancel
                            </span>
                            Close window
                        </button>
                        <div class="mt-2">
                            <div id="editor-container"></div>
                        </div>
                        <!-- Mostrar botones dinÃ¡micos basados en el metamodelID del bloque -->
                        <div v-if="selectedBlockIndex !== null">
                            <div v-for="prompt in getPromptsForMetamodelID(model[selectedBlockIndex].metamodelID)"
                                :key="prompt.id">
                                <div role="alert" class="alert">ð¤ Artificial Intelligence (click to open AI toold and
                                    paste the prompt copied to your clipboard)
                                    <button class="btn m-2 btn-primary"
                                        @click="copyPromptToClipboard(prompt.prompt); openNewWindowWithURL(prompt.url); printMessage('Prompt copied. Paste it in the chatbot!!!')">
                                        <span class="material-symbols-outlined" translate="no">
                                            content_copy
                                        </span>
                                        {{ prompt.caption }}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
        <!-- Modal para el editor de pantalla completa -->
        <div v-if="isFullScreenEditorOpen"
            class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex items-center justify-center">
            <div class="relative bg-white w-11/12 h-5/6 p-5 shadow-lg rounded-md">
                <!-- Contenedor del editor -->
                <div id="doc-editor-container"></div>
                <button @click="saveNewEditorContent(); closeFullScreenEditor()"
                    class="btn btn-primary btn-outline mt-4">Save</button>
                <button @click="closeFullScreenEditor()" class="absolute btn mt-4">Close</button>
            </div>
        </div>
        <div id="confirmation-message"
            class="fixed top-4 left-1/2 transform -translate-x-1/2 hidden bg-green-500 text-white py-2 px-4 rounded shadow-md transition-opacity duration-300 opacity-0 z-50">
        </div>
    </div>

    <script>
        Vue.createApp({
            data() {
                return {
                    // APP STATE
                    currentSidebarSection: 'home',
                    isSidebarVisible: true, // Controla la visibilidad de la sidebar
                    isIndexOpen: true,
                    isInfoModalOpen: false,
                    autoDownloadEnabled: true,
                    newMarkdownContent: '',
                    showGuidesSelect: false, // Controla la visibilidad del select
                    markdownGuideContent: '', // Almacena el contenido del Markdown cargado
                    isArtifactModalOpen: false,
                    artifactModalContent: '', // AlmacenarÃ¡ el contenido HTML generado
                    generatedContent: '',
                    // METAMODEL
                    metamodel: [],
                    // Definir un array con los sÃ­mbolos que usan los markers
                    markerSymbols: ['>', '*', '?', '!', 'Â¡', '=', '+', '-'],
                    // MODEL
                    model: [], // Se utilizarÃ¡ para almacenar el modelo de datos creado a partir del Markdown
                    modelName: '',
                    modelMarkdown: '', // Campo para almacenar el contenido Markdown concatenado
                    modelMarkdownLoaded: false, // Variable para controlar si el markdown ha sido cargado y analizado
                    modelTagsArray: new Set(),
                    depthCounters: [0, 0, 0, 0, 0, 0],
                    // MODEL BLOCKS
                    lastId: 0, // Inicializa un contador para los IDs
                    isBlockEditModalOpen: false,
                    selectedBlockContent: '',
                    selectedBlockIndex: null,
                    selectedBlockId: null,
                    tags: [],
                    // BLOCK INFO MODAL
                    selectedInfoBlock: null, // Para almacenar la informaciÃ³n del bloque seleccionado
                    selectedBlockInfoURL: null,
                    // FILTERS
                    selectedTags: [], // Almacena las etiquetas seleccionadas
                    selectedBlockTitles: [], // Arreglo para almacenar los titles seleccionados
                    selectedMarkers: [],
                    // combinedFilters: [],
                    filterVisible: true,
                    // SEARCH
                    searchQuery: '',
                    searchText: '',
                    replaceText: '',
                    isFullScreenEditorOpen: false, // Estado para controlar el modal del editor en pantalla completa
                    selectedPrompt: null,
                };
            },
            computed: {

                parsedModel() {
                    return this.model.map((block) => ({ ...block, contentParsed: marked.parse(block.content) }));
                },

                filteredBlocks() {
                    try {
                        let blocksWithParents = [];
                        let allLocators = new Set();

                        this.model.forEach(block => {
                            const tagMatch = this.selectedTags.length === 0 || this.selectedTags.some(tag => block.tags.includes(tag));
                            const markerMatch = this.selectedMarkers.length === 0 || this.selectedMarkers.some(marker => {
                                return block.markers && block.markers.some(bMarker => bMarker === marker || bMarker.includes(marker));
                            });

                            if (tagMatch && markerMatch) {
                                blocksWithParents.push(block);
                                allLocators.add(block.locator);

                                let parentLocator = block.locator.split('.').slice(0, -1).join('.');
                                while (parentLocator) {
                                    if (!allLocators.has(parentLocator)) {
                                        const parentBlock = this.model.find(b => b.locator === parentLocator);
                                        if (parentBlock) {
                                            blocksWithParents.unshift(parentBlock);
                                            allLocators.add(parentLocator);
                                        }
                                    }
                                    parentLocator = parentLocator.split('.').slice(0, -1).join('.');
                                }
                            }
                        });

                        // Ordena y resalta como antes
                        blocksWithParents.sort((a, b) => a.locator.localeCompare(b.locator));
                        blocksWithParents.sort((a, b) => a.uid - b.uid);

                        const highlightedBlocks = blocksWithParents.map(block => {
                            const clonedBlock = { ...block };
                            if (this.selectedTags.length > 0) {
                                clonedBlock.contentParsed = this.highlightText(clonedBlock.contentParsed, this.selectedTags);
                            }
                            return clonedBlock;
                        });
                        this.highlightFilteredBlocks();
                        return highlightedBlocks;
                    } catch (error) {
                        console.error('Error al filtrar bloques:', error);
                    }
                },

                combinedFilters() {
                    return [...this.selectedBrands, ...this.selectedTags];
                },

                searchFilteredBlocks() {
                    if (!this.searchQuery) {
                        return this.filteredBlocks;
                    }

                    let filteredBlocks = this.filteredBlocks.filter(block =>
                        block.contentParsed.toLowerCase().includes(this.searchQuery.toLowerCase())
                    );

                    const allLocators = new Set(filteredBlocks.map(block => block.locator));
                    let blocksToAdd = []; // Guardaremos aquÃ­ los bloques padres para luego insertarlos

                    filteredBlocks.forEach(block => {
                        const parentLocators = this.findParentLocators(block.locator);
                        parentLocators.forEach(parentLocator => {
                            if (!allLocators.has(parentLocator)) {
                                const parentBlock = this.model.find(b => b.locator === parentLocator);
                                if (parentBlock) {
                                    blocksToAdd.push(parentBlock);
                                    allLocators.add(parentLocator);
                                }
                            }
                        });
                    });

                    // Insertar cada bloque padre en la posiciÃ³n correcta
                    blocksToAdd.forEach(parentBlock => {
                        const childIndex = filteredBlocks.findIndex(block =>
                            block.locator.startsWith(parentBlock.locator + '.')
                        );
                        if (childIndex !== -1) {
                            // Si encontramos un hijo, insertamos el padre justo antes
                            filteredBlocks.splice(childIndex, 0, parentBlock);
                        } else {
                            // Si no encontramos un hijo (debido a filtros), agregamos el padre al final
                            filteredBlocks.push(parentBlock);
                        }
                    });

                    // Finalmente, aplicar el resaltado
                    return filteredBlocks.map(block => {
                        const highlightedContent = this.highlightText(block.contentParsed, this.searchQuery);
                        return { ...block, contentParsed: highlightedContent };
                    });
                },

                orderedBlocks() {
                    return this.model.sort((a, b) => a.uid - b.uid);
                }

            },
            methods: {

                changeSidebar(section) {
                    this.currentSidebarSection = section;
                    // Si la secciÃ³n no es 'filter', resetea el input de bÃºsqueda y los tags de filtro
                    if (section !== 'filter') {
                        this.searchQuery = ''; // Resetea el input de bÃºsqueda
                        this.selectedTags = []; // Resetea los tags de filtro seleccionados
                    }
                },

                // METAMODEL

                processMetamodel() {
                    axios.get('https://xbokmd.github.io/plastilinn/metamodel.json')
                        .then((response) => {
                            if (response.data && response.data.classes && response.data.sections) {
                                this.metamodel = response.data;
                            } else {
                                console.error('Metamodel received does not have the expected structure');
                            }
                        })
                        .catch((error) => console.error('Error loading metamodel:', error));
                },

                // MODEL LOADING

                loadAndParseModelFile(event) {
                    const file = event.target.files[0];
                    if (!file) {
                        return;
                    }
                    const modelName = this.getModelNameFromFileName(file.name);
                    this.modelName = modelName; // Actualiza modelName con el resultado de la funciÃ³n
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        this.parseModelMarkdown(content);
                    };
                    reader.readAsText(file);
                    this.updateModelMarkdown();
                    this.modelMarkdownLoaded = true;
                },

                getModelNameFromFileName(fileName) {
                    let name = fileName.replace(/\.md$/, ''); // Elimina la extensiÃ³n ".md"
                    name = name.replace(/ - saved.*$/, ''); // Elimina " - saved" y todo lo que sigue
                    return name;
                },

                parseModelMarkdown(content) {
                    const model = this.splitModelMarkdownIntoBlocks(content);
                    this.model = model.map((blockContent) => this.processBlock(blockContent));
                    this.assignUids();
                    this.updateTagsArray();
                    this.modelMarkdownLoaded = true; // Indicar que el markdown ha sido cargado y analizado
                },

                splitModelMarkdownIntoBlocks(content) {
                    let currentBlock = [];
                    const lines = content.split(/\r?\n/);

                    lines.forEach((line) => {
                        if (/^\s*([-*\d.]*)*\s*#/.test(line)) {
                            if (currentBlock.length > 0) {
                                this.model.push(currentBlock.join('\n'));
                                currentBlock = [];
                            }
                        }
                        currentBlock.push(line);
                    });
                    if (currentBlock.length > 0) {
                        this.model.push(currentBlock.join('\n'));
                    }
                    return this.model;
                },

                // BLOCK PROCESSING

                updateModelBlockContent(blockId, newContent) {
                    const blockIndex = this.model.findIndex(block => block.id === blockId);
                    if (blockIndex !== -1) {
                        // Actualiza el contenido
                        const block = this.model[blockIndex];
                        // Asegura que newContent sea una cadena antes de asignarla.
                        // Si newContent no es una cadena, podrÃ­as convertirla a cadena o manejar el error como prefieras.
                        if (typeof newContent !== 'string') {
                            console.error('newContent esperaba una cadena, recibido:', typeof newContent, newContent);
                            // Por ejemplo, si newContent deberÃ­a ser siempre una cadena, podrÃ­as convertirla forzosamente a cadena
                            // o asignar una cadena vacÃ­a o algÃºn valor por defecto segÃºn sea apropiado para tu aplicaciÃ³n.
                            newContent = String(newContent); // Convierte forzosamente a cadena (podrÃ­a resultar en 'undefined' o 'null' como cadena)
                            // O manejar el caso de manera diferente segÃºn sea necesario.
                        }

                        block.content = newContent;

                        // Llama a los mÃ©todos para recalcular los campos dependientes
                        this.updateDependentModelBlockFields(blockIndex);
                    }
                },

                updateDependentModelBlockFields(blockIndex) {
                    const block = this.model[blockIndex];
                    // ConversiÃ³n forzada a cadena si es necesario.
                    let contentAsString = String(block.content)
                    const mdToHTML = this.parseToHTML(block.content);
                    block.contentParsed = marked.parse(mdToHTML);
                    //block.contentParsed = marked.parse(mdToHTML);
                    const firstLine = block.content.split('\n')[0];
                    block.type = this.determineBlockType(firstLine);
                    block.depthLevel = this.determineDepthLevel(firstLine);
                    block.title = this.extractBlockTitle(block.content); // Ajustado para usar el mÃ©todo recalculado
                    block.instanceClass = this.determineInstanceClass(block.content, block.type);
                    const tagResults = this.processTags(block.content);
                    block.tags = tagResults.tags;
                    block.tagsParsed = tagResults.tagsParsed;
                    block.markers = tagResults.markers;
                    block.markersParsed = tagResults.markersParsed;
                    block.instanceValue = this.setInstanceValue(block.title);
                    block.metamodelID = this.generateMetamodelID(block.title, block.instanceClass);
                    block.metamodel = this.importMetamodelData(block.metamodelID);
                    // Llama al nuevo mÃ©todo para calcular el locator
                    block.locator = this.calculateLocator(block.depthLevel);
                    // AquÃ­ puedes agregar mÃ¡s campos para recalcular si es necesario
                },

                processBlock(blockContent, blockId = null) {
                    let block;
                    let isNewBlock = false;

                    if (blockId == null) {
                        // CreaciÃ³n de un nuevo bloque
                        this.lastId += 1;
                        block = { id: this.lastId, content: blockContent };
                        this.model.push(block);
                        isNewBlock = true;
                    } else {
                        // ActualizaciÃ³n de un bloque existente
                        const blockIndex = this.model.findIndex(block => block.id === blockId);
                        if (blockIndex === -1) {
                            console.error("Block not found");
                            return;
                        }
                        block = this.model[blockIndex];
                        block.content = blockContent;
                    }

                    if (!isNewBlock || block.content) {
                        const blockIndex = this.model.findIndex(b => b.id === block.id);
                        this.updateDependentModelBlockFields(blockIndex);
                    }

                    // Siempre devuelve el bloque para operaciones de creaciÃ³n. Para actualizaciones,
                    // el bloque ya estÃ¡ actualizado en el modelo.
                    return block;
                },

                determineBlockType(firstLine) {
                    if (/^\s*(-\s+)?#(\s|#)/.test(firstLine)) {
                        return 'section';
                    }
                    return 'item';
                },

                determineDepthLevel(firstLine) {
                    // Esta expresiÃ³n regular busca signos '#' al inicio de la lÃ­nea seguidos directamente
                    // por otro '#' o un espacio, indicando un encabezado de Markdown.
                    const match = firstLine.match(/^\s*(#+)(?=\s|#)/);
                    if (match) {
                        return match[1].length; // La longitud de la coincidencia es el nivel de profundidad.
                    }
                    // Si no es un encabezado de Markdown, retorna 0 o un valor por defecto.
                    return 0;
                },

                calculateLocator(depthLevel) {
                    if (depthLevel === 0) {
                        // Encuentra el Ãºltimo locator con un depthLevel > 0 y trÃ¡talo como base para este.
                        const lastNonZeroDepthLocator = this.findLastNonZeroDepthLocator();
                        return `${lastNonZeroDepthLocator}.1`; // Asume que quieres aÃ±adirlo como un subnivel del Ãºltimo encabezado.
                    } else if (depthLevel >= 1 && depthLevel <= 6) {
                        this.depthCounters[depthLevel - 1] += 1;

                        for (let i = depthLevel; i < 6; i++) {
                            this.depthCounters[i] = 0;
                        }

                        return this.depthCounters.slice(0, depthLevel).join('.');
                    } else {
                        console.error(`Depth level out of range: ${depthLevel}`);
                        return '';
                    }
                },

                findLastNonZeroDepthLocator() {
                    // Busca hacia atrÃ¡s desde el final del array model hasta encontrar un bloque con depthLevel > 0.
                    for (let i = this.model.length - 1; i >= 0; i--) {
                        if (this.model[i].depthLevel > 0) {
                            return this.model[i].locator; // AsegÃºrate de que este bloque ya tiene un locator calculado.
                        }
                    }
                    return '0'; // Devuelve un valor por defecto si no encuentras ninguno.
                },

                determineInstanceClass(blockContent, type) {
                    if (type === 'section') {
                        const match = blockContent.match(/^\s*#+\s*(#[^\s]+)/);
                        if (match && match[1] && !/^#+$/.test(match[1])) {
                            return match[1].substring(1);
                        }
                    }
                    return null;
                },

                processTags(blockContent) {
                    const markerSymbols = this.markerSymbols;
                    // Inicializando un nuevo array para los marcadores ajustados
                    const adjustedMarkers = [];

                    // Capturando marcadores: cadenas que comienzan con # seguido por uno de los sÃ­mbolos especiales de marcadores
                    const markers = [...blockContent.matchAll(/(?:^|\s)#([>!*?+^-][^\s]*)/g)].map(match => {
                        const markerWithoutPrefix = match[1];
                        adjustedMarkers.push(markerWithoutPrefix); // Agrega el marcador ajustado sin el prefijo
                        return markerWithoutPrefix; // Devuelve el marcador sin el prefijo para el mapeo
                    });

                    const markersParsed = adjustedMarkers.map(marker => this.parseMarker(marker)).join(' ');

                    // ExpresiÃ³n regular ajustada para capturar etiquetas
                    const tagsRegex = /(?:^|\s)(#[^\s#][^\s]*)/g;
                    const tags = [];
                    let match;
                    while ((match = tagsRegex.exec(blockContent)) !== null) {
                        // Evita bucles infinitos con coincidencias de ancho cero
                        if (match.index === tagsRegex.lastIndex) {
                            tagsRegex.lastIndex++;
                        }

                        // Excluye marcadores del array de etiquetas
                        if (!markerSymbols.some(symbol => match[1].startsWith(`#${symbol}`))) {
                            tags.push(match[1].substring(1)); // Elimina el # principal por consistencia con tu lÃ³gica original
                        }
                    }
                    const tagsParsed = tags.map(tag => this.parseTag(tag)).join(' ');

                    // Nota: Este cÃ³digo asume que todos los marcadores vienen con un prefijo y los ajusta en consecuencia.
                    // Si algunos marcadores pueden venir sin prefijo, deberÃ¡s ajustar esta lÃ³gica.
                    return { markers: adjustedMarkers, markersParsed, tags, tagsParsed };
                },

                parseMarker(marker) {
                    // AsegÃºrate de que esta funciÃ³n maneje correctamente el marcador ya sin prefijo
                    return `<span data-marker="${marker}">#${marker}</span>`;
                },

                parseTag(tag) {
                    return `<span data-tag="${tag}">#${tag}</span>`;
                },

                extractBlockTitle(blockContent) {
                    const firstLine = blockContent.split(/\r?\n/)[0]; // Obtiene la primera lÃ­nea

                    // Extrae el encabezado Markdown y la primera etiqueta (si existe) que estÃ© directamente despuÃ©s del encabezado
                    const matches = firstLine.match(/^(#+\s*)(#[^\s]+)?\s*(.*)/);
                    if (matches) {
                        const markdownHeader = matches[1]; // Encabezado Markdown (p.ej., '###')
                        const directTag = matches[2] ? `${matches[2]} ` : ''; // La etiqueta directa despuÃ©s del encabezado, si existe
                        const restOfTheTitle = matches[3]; // El resto del tÃ­tulo despuÃ©s del encabezado y la etiqueta directa

                        // Combina la etiqueta directa (si existe) y el resto del tÃ­tulo, eliminando otras etiquetas
                        let title = (directTag + restOfTheTitle).replace(/#[^\s]+/g, '').trim();

                        // Elimina cualquier nÃºmero de '#' que puedan existir al principio del valor de la variable title y estÃ©n seguidos de un espacio
                        title = title.replace(/^#+\s*/, '');

                        // /// console.log('Returning title with matches:', title); // Traza antes del return
                        return title;
                    }

                    // En caso de que no haya coincidencia, retorna la lÃ­nea completa, pero tambiÃ©n limpiamos posibles '#' al inicio aquÃ­.
                    // Se asegura que se aplique la eliminaciÃ³n de '#' seguidos de un espacio para todos los casos.
                    const finalTitle = firstLine.replace(/^#+\s*/, '').trim();
                    /// console.log('Returning title without matches:', finalTitle); // Traza antes del return
                    return finalTitle;
                    // Asegurarse de devolver una cadena vacÃ­a si el tÃ­tulo no se encuentra
                    return title || '';
                },

                setInstanceValue(title) {
                    /// console.log("ð ~ setInstanceValue ~ title:", title)
                    // Verifica si title es una cadena
                    if (typeof title !== "string") {
                        /// console.log("title debe ser una cadena.setInstanceValue ~ title:", title);
                        return ""; // Retorna una cadena vacÃ­a o maneja el caso como prefieras
                    }

                    // Initial assignment based on title starting with a hashtag
                    if (/^#\w+/.test(title)) {
                        this.instanceValue = title;
                    }

                    // Extract component after the initial tag and dash, refining instanceValue
                    const titleParts = title.match(/^#\w+\s+(.*?)\s*(-|$)/);
                    /// console.log("ð ~ setInstanceValue ~ titleParts:", titleParts)
                    if (titleParts && titleParts[1]) {
                        this.instanceValue = titleParts[1].replace(/#\w+/g, '').trim();
                    } else if (title.includes('-')) {
                        this.instanceValue = title.split('-')[0].trim();
                    } else {
                        this.instanceValue = title.trim();
                    }
                    /// console.log("ð ~ setInstanceValue ~ this.instanceValue:", this.instanceValue)
                    return this.instanceValue;
                },

                generateMetamodelID(title, instanceClass) {
                    // Si instanceClass estÃ¡ vacÃ­o o es null, retorna directamente el title
                    if (!instanceClass) {
                        return title;
                    }

                    // Si instanceClass no estÃ¡ vacÃ­o y el tÃ­tulo no contiene un guiÃ³n con un espacio a cada lado
                    if (instanceClass && !title.includes(" - ")) {
                        return `${instanceClass} Name`;
                    }

                    // Si instanceClass no estÃ¡ vacÃ­o y el tÃ­tulo contiene un guiÃ³n con un espacio a cada lado
                    if (instanceClass && title.includes(" - ")) {
                        // Extrae el texto a la derecha del guiÃ³n, incluyendo el guiÃ³n y los espacios
                        const titleAfterDash = title.substring(title.indexOf(" - ") + 3);
                        // Construye metamodelID usando instanceClass y el texto a la derecha del guiÃ³n, reemplazando el inicio del tÃ­tulo por "Name"
                        return `${instanceClass} Name - ${titleAfterDash}`;
                    }

                    // En cualquier otro caso (por precauciÃ³n), retorna el tÃ­tulo
                    return title;
                },

                importMetamodelData(metamodelID) {
                    /// console.log("ð ~ importMetamodelData ~ metamodelID:", metamodelID)
                    // Encuentra la secciÃ³n que coincide con el metamodelID proporcionado.
                    const section = this.metamodel.sections.find((section) => section.name === metamodelID);

                    if (section) {
                        /// console.log("ð ~ importMetamodelData ~ section:", section)
                        return section;
                    }
                    /// console.log('No se encontrÃ³ ninguna secciÃ³n que coincida con el metamodelID:', metamodelID);
                    return null;
                },

                parseToHTML(content) {
                    if (typeof content !== 'string') {
                        console.error('Expected content to be a string, but got:', typeof content, content);
                        return ''; // Retorna una cadena vacÃ­a o maneja el error como prefieras
                    }

                    // Define un array con los sÃ­mbolos que usan los markers
                    const markerSymbols = this.markerSymbols;

                    // Procesa etiquetas y marcadores primero
                    let processedTagsContent = content.replace(/(^|\s)(#[^\s#]+)/g, (match, p1, p2) => {
                        if (markerSymbols.some(symbol => p2[1] === symbol)) {
                            // Si es un marcador
                            return `${p1}${this.parseMarker(p2.slice(1))}`;
                        } else {
                            // Si es una etiqueta
                            return `${p1}${this.parseTag(p2.slice(1))}`;
                        }
                    });
                    return processedTagsContent;
                },

                openInfoModal(block) {
                    /// console.log("ð ~ openInfoModal ~ block:", block)
                    this.selectedInfoBlock = block;
                    this.selectedBlockId = block.id; // AsegÃºrate de tener selectedBlockId definido en tu data()
                    this.selectedBlockInfoURL = `https://xbokmd.github.io/plastilinn/raw.html#/docs/xBoK/sections/${block.replace(/ /g, '_')}`;
                    // Busca el Ã­ndice de la lÃ­nea basÃ¡ndose en el ID Ãºnico
                    this.selectedBlockIndex = this.model.findIndex((item) => item.id === block.id);
                    this.isInfoModalOpen = true;
                    this.$nextTick(() => {
                        // AsegÃºrate de que el contenedor del editor estÃ© disponible en el DOM
                        this.selectedBlockInfoURL;
                    });

                    const width = 900; // Ancho de la ventana
                    const height = 600; // Alto de la ventana

                    // Calcular posiciÃ³n central
                    const y = window.top.outerHeight / 2 + window.top.screenY - (height / 2);
                    const x = window.top.outerWidth / 2 + window.top.screenX - (width / 2);

                    window.open(this.selectedBlockInfoURL, 'Modal', `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, copyhistory=no, width=${width}, height=${height}, top=${y}, left=${x}`);
                },

                findParentLocators(locator) {
                    const parts = locator.split('.');
                    const parents = [];

                    for (let i = 1; i < parts.length; i++) {
                        parents.push(parts.slice(0, i).join('.'));
                    }

                    return parents;
                },

                // EDIT BLOCK

                initEditor() {
                    if (this.editor) {
                        this.editor.destroy(); // Destruye la instancia anterior del editor
                    }
                    this.editor = new toastui.Editor({
                        el: document.querySelector('#editor-container'),
                        initialEditType: 'markdown',
                        previewStyle: 'tab',
                        height: '340px',
                        width: '500px',
                        hideModeSwitch: true,
                        initialValue: this.selectedBlockContent, // Asume que `editingContent` es tu contenido actual que quieres editar
                    });
                },

                openBlockEditModal(block) {
                    this.updateModelMarkdown();
                    this.selectedBlockId = block.id; // AsegÃºrate de tener selectedBlockId definido en tu data()
                    this.selectedBlockContent = block.content;
                    this.selectedBlockIndex = this.model.findIndex((item) => item.id === block.id);
                    this.isBlockEditModalOpen = true;
                    this.$nextTick(() => {
                        // AsegÃºrate de que el contenedor del editor estÃ© disponible en el DOM
                        this.initEditor();
                    });
                },

                showHelpSection() {
                    const helpSection = document.getElementById('help-section');
                    const editingSection = document.getElementById('editing-your-plastilinn-doc');

                    if (helpSection && editingSection) {
                        // Copiar el contenido de la secciÃ³n 'editing-your-plastilinn-doc' dentro del contenedor 'help-section'
                        helpSection.innerHTML = editingSection.innerHTML;

                        // Puedes desplazar la pÃ¡gina hacia el contenedor, si lo deseas
                        helpSection.scrollIntoView({ behavior: 'smooth' });
                    } else {
                        console.error('No se encontrÃ³ la secciÃ³n de ayuda o la secciÃ³n de ediciÃ³n.');
                    }
                },

                getPromptsForMetamodelID(metamodelID) {
                    return this.metamodel.prompts.filter(prompt => {
                        // AÃ±adir log para ver los valores de prompt.item y metamodelID en la consola
                        console.log('prompt.item:', prompt.item, 'metamodelID:', metamodelID);

                        // Filtrar los prompts que coinciden con el metamodelID
                        return prompt.item === metamodelID;
                    });
                },

                // EDIT MD DOCUMENT

                closeFullScreenEditor() {
                    this.isFullScreenEditorOpen = false; // Cierra el modal
                },

                handleSelection() {
                    if (this.selectedPrompt) {
                        this.copyPromptToClipboard(this.selectedPrompt.prompt);
                        this.openNewWindowWithURL(this.selectedPrompt.url);
                        this.printMessage('Prompt copied. Paste it in the chatbot!!!');
                    }
                },

                initDocumentEditor() {
                    const editorContainer = document.querySelector('#doc-editor-container');
                    if (!editorContainer) {
                        console.error("Editor container not found");
                        return; // Sal del mÃ©todo si el contenedor no existe
                    }

                    if (this.editor) {
                        this.editor.destroy(); // Destruye el editor si ya existe una instancia anterior
                    }

                    this.editor = new toastui.Editor({
                        el: editorContainer,
                        initialEditType: 'markdown',
                        previewStyle: 'tab',
                        height: '500px',
                        initialValue: this.modelMarkdown, // Puedes ajustar para cargar el contenido markdown actual
                    });
                },

                openEditorInModal() {
                    this.isFullScreenEditorOpen = true;  // Abre el modal

                    // Usa un setTimeout para asegurar que el DOM se ha renderizado completamente
                    setTimeout(() => {
                        const editorContainer = document.querySelector('#doc-editor-container');
                        if (!editorContainer) {
                            console.error("Editor container not found");
                            return;
                        }

                        this.newEditorInstance = new toastui.Editor({
                            el: editorContainer,
                            initialEditType: 'markdown',
                            previewStyle: 'tab',
                            height: '500px',
                            initialValue: this.modelMarkdown, // Contenido inicial
                        });
                    }, 500); // Ajusta el tiempo si es necesario
                },


                showGeneratedContent() {
                    this.generatedContent = this.generateSuggestionPrompt();
                },

                printMessage(message) {
                    const confirmationMessage = document.getElementById('confirmation-message');
                    confirmationMessage.textContent = message; // Establece el mensaje proporcionado como contenido del elemento
                    confirmationMessage.classList.remove('hidden', 'opacity-0');
                    confirmationMessage.classList.add('opacity-100');

                    setTimeout(() => {
                        confirmationMessage.classList.remove('opacity-100');
                        confirmationMessage.classList.add('opacity-0');
                        setTimeout(() => {
                            confirmationMessage.classList.add('hidden');
                        }, 300); // DuraciÃ³n de la transiciÃ³n
                    }, 8000); // Tiempo de espera para ocultar el mensaje
                },

                generateCompletePrompt(partialPrompt) {
                    this.updateModelMarkdown();
                    const { modelMarkdown } = this;
                    const completePrompt = partialPrompt + `
        CUSTOM INFO: Here's some information about the business:\n\n`
                        + `--- business model start ---\n\n`
                        + `${modelMarkdown}\n\n`
                        + `--- business model end ---\n\n`;
                    return completePrompt;
                },

                copyPromptToClipboard(prompt) {
                    const textarea = document.createElement('textarea');
                    textarea.value = this.generateCompletePrompt(prompt);  // Referencia al mÃ©todo correctamente con 'this'
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);

                    // Llama al mÃ©todo printMessage con el mensaje de confirmaciÃ³n
                    this.printMessage('Prompt copied to clipboard!!!');
                },

                openNewWindowWithURL(url) {
                    const width = 800;
                    const height = 600;
                    const y = window.top.outerHeight / 2 + window.top.screenY - (height / 2);
                    const x = window.top.outerWidth / 2 + window.top.screenX - (width / 2);
                    window.open(url, '_blank', `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, width=${width}, height=${height}, top=${y}, left=${x}`);
                },

                saveChanges() {
                    const editedContent = this.editor.getMarkdown();
                    const oldTitle = this.extractBlockTitle(this.selectedBlockContent); // Utiliza tu mÃ©todo existente para extraer el tÃ­tulo
                    const newTitle = this.extractBlockTitle(editedContent); // Suponiendo que tengas una funciÃ³n similar para el contenido editado

                    if (oldTitle !== newTitle) {
                        alert("You have changed the title of a block. If you have references to this title in the document, " +
                            "you might want to use the search and replace feature within the sidebar filter. " +
                            `Search "${oldTitle}" and replace it with "${newTitle}"`);
                    }

                    if (this.selectedBlockIndex !== null) {
                        // Encuentra el ID del bloque seleccionado para poder pasarlo al mÃ©todo de actualizaciÃ³n.
                        const blockId = this.model[this.selectedBlockIndex].id;

                        // Actualiza el bloque utilizando el mÃ©todo de actualizaciÃ³n que maneja la lÃ³gica de recalculo.
                        this.updateModelBlockContent(blockId, editedContent);

                        // Nota: No necesitas procesar tags, title, etc., aquÃ­, ya que eso se manejarÃ¡ en el mÃ©todo de recÃ¡lculo.
                    }
                    this.updateModelMarkdown();
                    const markdownContent = this.modelMarkdown; // Obtiene el valor actual de modelMarkdown
                    this.newMarkdownContent = markdownContent; // Almacena el contenido en el estado
                    this.processNewContent();
                    this.closeModal();

                    // DespuÃ©s de guardar, verifica si autoDownload estÃ¡ habilitado
                    if (this.autoDownloadEnabled) {
                        this.downloadMarkdown(); // Asume que este es tu mÃ©todo de descarga existente
                    }
                    // this.highlightTitlesInContent();
                },

                closeModal() {
                    this.isBlockEditModalOpen = false;
                },

                // NAVIGATION

                highlightOnLoad() {
                    this.$nextTick(() => {
                        if (window.location.hash) {
                            const hash = decodeURIComponent(window.location.hash.substring(1)); // Decodifica el hash.
                            this.highlightBlock(hash);
                        }
                    });
                },

                highlightBlock(id) {
                    const element = document.getElementById(id);
                    if (element) {
                        element.classList.add('highlight');
                        setTimeout(() => element.classList.remove('highlight'), 5000);
                    }
                },

                highlightFilteredBlocks() {
                    this.$nextTick(() => {
                        // Asumiendo que tienes un array 'filteredBlocks' que contiene los bloques filtrados
                        this.filteredBlocks.forEach(block => {
                            const element = document.getElementById(block.title); // Asumiendo que el 'id' del elemento HTML corresponde al 'title' del bloque
                            if (element) {
                                element.classList.add('highlight');
                                setTimeout(() => element.classList.remove('highlight'), 5000);
                            }
                        });
                    });
                },

                // MODEL PROCESSING

                assignUids() {
                    let uid = 1; // Inicia el contador de UID en 1 o cualquier otro valor inicial que prefieras.
                    this.model.forEach((block) => {
                        block.uid = uid++; // Asigna el UID y luego incrementa el contador.
                    });
                    /// console.log('UIDs assigned to model blocks:', this.model);
                },

                resetDepthCounters() {
                    this.depthCounters = [0, 0, 0, 0, 0, 0];
                },

                // MÃ©todo para abrir el contenido en un nuevo editor
                openInNewEditor() {
                    this.updateModelMarkdown();

                    // Crea un nuevo div dinÃ¡micamente
                    const editorContainer = document.createElement('div');
                    editorContainer.id = `editor-container-${Date.now()}`; // Un ID Ãºnico para cada instancia
                    editorContainer.style = 'margin-top: 20px;'; // Opcional, para aÃ±adir espaciado

                    // AÃ±ade el contenedor del editor al cuerpo
                    document.body.appendChild(editorContainer);

                    // Inicializa un nuevo editor y guarda la referencia en `this.newEditorInstance`
                    this.newEditorInstance = new toastui.Editor({
                        el: editorContainer,
                        initialEditType: 'markdown',
                        previewStyle: 'tab',
                        height: '500px', // Ajusta la altura segÃºn sea necesario
                        initialValue: this.modelMarkdown, // Utiliza el contenido actual de Markdown
                    });

                    // Crea un botÃ³n para guardar el contenido del nuevo editor
                    const saveButton = document.createElement('button');
                    saveButton.innerText = 'Save as Markdown';
                    saveButton.classList.add('btn', 'btn-primary btn-outline', 'm-2');
                    saveButton.onclick = this.saveNewEditorContent; // Asigna el mÃ©todo de guardado al evento `click`

                    // AÃ±ade el botÃ³n de guardar despuÃ©s del editor
                    editorContainer.appendChild(saveButton);
                },


                generateFileName() {
                    const { modelName } = this; // ObtÃ©n el nombre actual del modelo
                    const timestamp = new Date().toISOString().replace(/[:-]|\.\d{3}/g, ''); // Genera un timestamp en el formato deseado
                    return `${modelName} - saved ${timestamp}.md`; // Devuelve el nombre del archivo
                },

                // MÃ©todo para guardar el contenido del nuevo editor como archivo Markdown
                saveNewEditorContent() {
                    if (this.newEditorInstance) {
                        // ObtÃ©n el contenido actual del editor en formato Markdown
                        const markdownContent = this.newEditorInstance.getMarkdown();

                        // Usa el mÃ©todo `generateFileName()` para obtener el nombre del archivo
                        const fileName = this.generateFileName();

                        // Crea un Blob con el contenido Markdown
                        const blob = new Blob([markdownContent], { type: 'text/markdown' });

                        // Crea un enlace para descargar el archivo
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = fileName;

                        // Simula un clic en el enlace para iniciar la descarga
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        // Simula la carga del archivo y procesa el nuevo contenido en Markdown
                        this.newMarkdownContent = markdownContent;

                        // Llama al mÃ©todo para refrescar todo el modelo
                        this.refreshModelFromMarkdown();

                        // Opcional: Mostrar un mensaje de confirmaciÃ³n o hacer mÃ¡s acciones despuÃ©s de guardar
                        this.printMessage('Markdown saved and model refreshed.');
                    } else {
                        alert('No editor instance found');
                    }
                },

                refreshModelFromMarkdown() {
                    // Resetea el modelo antes de procesar el nuevo contenido
                    this.model = [];
                    this.resetDepthCounters();

                    // Procesa el contenido Markdown nuevo
                    this.parseModelMarkdown(this.newMarkdownContent);

                    // Actualiza el contenido Markdown para reflejar los cambios
                    this.updateModelMarkdown();

                    // Llama a los mÃ©todos para actualizar los tags y otros campos si es necesario
                    this.updateTagsArray();

                    // Si hay algÃºn otro mÃ©todo necesario para refrescar la UI, se puede agregar aquÃ­.
                    this.$nextTick(() => {
                        this.highlightFilteredBlocks(); // Opcional, resalta bloques filtrados
                    });
                },



                // MÃ©todo para simular la subida del archivo despuÃ©s de la descarga
                simulateFileUpload(blob, fileName) {
                    // Crea un archivo simulado (File API no estÃ¡ soportada directamente en blobs, pero esta es una soluciÃ³n aproximada)
                    const simulatedFile = new File([blob], fileName, { type: 'text/markdown' });

                    // Crea un FileReader para leer el archivo como texto
                    const reader = new FileReader();

                    reader.onload = (event) => {
                        const content = event.target.result; // Este es el contenido del archivo subido
                        // Procesa el archivo subido como si hubiera sido subido por el usuario
                        this.parseModelMarkdown(content); // MÃ©todo para parsear el contenido Markdown
                    };

                    // Leer el archivo como texto
                    reader.readAsText(simulatedFile);
                },


                updateModelMarkdown() {
                    let concatenatedContent = '';
                    this.model.forEach((item) => {
                        concatenatedContent += `${item.content}\n`;
                    });
                    this.modelMarkdown = concatenatedContent; // Actualiza el Markdown
                },

                updateTagsArray() {
                    // Cargar la lista de bloques
                    this.model.forEach((block) => block.tags.forEach((tag) => this.modelTagsArray.add(tag)));
                    // Convertir modelTagsArray a un array, ordenarlo alfabÃ©ticamente y luego asignar a this.tags
                    this.tags = Array.from(this.modelTagsArray).sort((a, b) => a.localeCompare(b));
                    // Inicializar el filtrado (si necesario)
                    //this.filterBlocks([]);
                },

                // FILTERS AND SEARCH

                setFilterTags(tags) {
                    // Establece las etiquetas seleccionadas directamente
                    this.selectedTags = tags;
                },

                filteredBlocksByTags(tags) {
                    return this.model.filter((block) => block.tags.some((tag) => tags.includes(tag)));
                },

                resetSelectedTagsAndMarkers() {
                    this.selectedTags = [];
                    this.selectedMarkers = [];
                },

                buildTagsQueryList(tags) {
                    // Filtra los bloques que contienen todas las etiquetas especificadas
                    const filteredBlocks = this.model.filter((block) => tags.every((tag) => block.tags.includes(tag)));
                    // Construye una lista de HTML con los titles de los bloques filtrados
                    let htmlList = '<ul>';
                    filteredBlocks.forEach((block) => {
                        htmlList += `<li>${block.title}</li>`;
                    });
                    htmlList += '</ul>';

                    // Devuelve la lista HTML
                    return htmlList;
                },

                toggleTagSelection(tag) {
                    console.log("ð ~ toggleTagSelection ~ tag:", tag)
                    const index = this.selectedTags.indexOf(tag);
                    if (index > -1) {
                        this.selectedTags.splice(index, 1); // Si la etiqueta ya estÃ¡ seleccionada, quÃ­tala
                    } else {
                        this.selectedTags.push(tag); // Si no, aÃ±Ã¡dela
                    }
                },

                toggleMarkerSelection(marker) {
                    // Asume que los marcadores ya se gestionan con su propio sistema de prefijos o identificaciÃ³n
                    const index = this.selectedMarkers.indexOf(marker);
                    if (index > -1) {
                        this.selectedMarkers.splice(index, 1); // Si el marcador ya estÃ¡ seleccionado, quÃ­talo
                    } else {
                        this.selectedMarkers.push(marker); // Si no, aÃ±Ã¡delo
                    }
                },

                highlightText(text, terms) {
                    if (!terms.length) return text; // Si no hay tÃ©rminos, devuelve el texto tal cual

                    // Asegura que terms sea un array. Si no lo es, conviÃ©rtelo.
                    if (!Array.isArray(terms)) {
                        terms = [terms];
                    }

                    // Preparar una expresiÃ³n regular que identifique si estamos dentro de una etiqueta HTML
                    const htmlTagRegex = /<\/?[^>]+>/gi;

                    // Esta funciÃ³n de reemplazo verifica si el tÃ©rmino estÃ¡ dentro de una etiqueta HTML
                    function replacementFunction(match, offset, fullText) {
                        // Encuentra todos los tags en el texto
                        let tagMatch;
                        let isInTag = false;
                        while ((tagMatch = htmlTagRegex.exec(fullText)) !== null) {
                            const tagStart = tagMatch.index;
                            const tagEnd = tagMatch.index + tagMatch[0].length;
                            if (offset >= tagStart && offset < tagEnd) {
                                // Si el match estÃ¡ dentro de un tag, marcamos isInTag como verdadero y rompemos el ciclo
                                isInTag = true;
                                break;
                            }
                        }

                        // Si el match estÃ¡ dentro de un tag, lo devuelve sin modificarlo
                        if (isInTag) {
                            return match;
                        } else {
                            // Si no estÃ¡ dentro de un tag, aplica el resaltado
                            return `<span class="highlight-text">${match}</span>`;
                        }
                    }

                    // Resalta cada tÃ©rmino
                    terms.forEach(term => {
                        const regex = new RegExp(term, 'gi');
                        text = text.replace(regex, replacementFunction);
                    });

                    return text;
                },

                escapeRegExp(string) {
                    return string.replace(/[.*+?^${ }()|[\]\\]/g, '\\$&'); // Escapa caracteres especiales para regex
                },

                replaceMatches() {
                    if (!this.searchQuery || !this.replaceText) {
                        alert("Por favor, completa ambos campos de bÃºsqueda y reemplazo.");
                        return;
                    }

                    // Utiliza el mÃ©todo escapeRegExp correctamente llamado con 'this.'
                    const regex = new RegExp(this.escapeRegExp(this.searchQuery), 'gi');

                    this.model.forEach((block) => {
                        if (regex.test(block.content)) {
                            // Reemplaza todas las coincidencias en el contenido del bloque
                            const updatedContent = block.content.replace(regex, this.replaceText);

                            // Llama a updateModelBlockContent para cada bloque afectado
                            // Esto asegurarÃ¡ que todos los campos dependientes se actualicen adecuadamente
                            this.updateModelBlockContent(block.id, updatedContent);
                        }
                    });

                    // Limpia los campos de bÃºsqueda y reemplazo despuÃ©s del proceso
                    this.searchQuery = '';
                    this.replaceText = '';

                    // Opcionalmente, puedes llamar a otros mÃ©todos si es necesario actualizar la UI o el estado global
                },

                prepareMarkers() {
                    const markers = {};
                    if (this.metamodel.markers && Array.isArray(this.metamodel.markers)) {
                        this.metamodel.markers.forEach((marker) => {
                            // AsegÃºrate de que marker.name existe y es una cadena vÃ¡lida
                            if (marker.name && typeof marker.name === 'string') {
                                if (!markers[marker.name]) {
                                    markers[marker.name] = new Set(); // Usa un Set para evitar valores duplicados
                                }
                                // Verifica si marker.values es una cadena y conviÃ©rtela en un arreglo si es necesario
                                const values = typeof marker.values === 'string' ? marker.values.split(',') : marker.values;
                                // AsegÃºrate de que values sea un arreglo antes de intentar iterar sobre Ã©l
                                if (Array.isArray(values)) {
                                    values.forEach(value => markers[marker.name].add(value.trim())); // Usa trim para eliminar espacios en blanco al inicio y al final
                                } else {
                                    // Si marker.values no es un arreglo ni una cadena, muestra una advertencia
                                    console.warn(`Expected marker.values to be an array or a string, got:`, typeof marker.values, marker.values);
                                }
                            }
                        });
                    }

                    // Convierte los sets a arrays y elimina espacios en blanco de los valores
                    for (const markerName in markers) {
                        markers[markerName] = Array.from(markers[markerName]);
                    }
                    return markers;
                },

                toggleMarkerSelection(markerValue) {
                    const index = this.selectedMarkers.indexOf(markerValue);
                    if (index > -1) {
                        // El marcador ya estÃ¡ seleccionado, quitarlo del array
                        this.selectedMarkers.splice(index, 1);
                    } else {
                        // El marcador no estÃ¡ seleccionado, aÃ±adirlo al array
                        this.selectedMarkers.push(markerValue);
                    }

                    // Opcional: Puedes llamar aquÃ­ al mÃ©todo que actualiza el filtro de bloques si deseas que los bloques se actualicen inmediatamente despuÃ©s de cambiar la selecciÃ³n.
                    // this.updateBlocksFilter();
                },

                updateFilter(selectedMarker) {
                    // AquÃ­ puedes implementar la lÃ³gica para filtrar los bloques basÃ¡ndose en el marcador seleccionado.
                    // Por ejemplo, podrÃ­as ajustar la propiedad 'filteredBlocks' para que solo incluya bloques que coincidan con el marcador seleccionado.
                    this.filteredBlocks = this.model.filter(block => {
                        // Suponiendo que 'block.markers' es un array de marcadores asociados con el bloque
                        return block.markers.includes(selectedMarker);
                    });
                },

                // FORMATING

                // ARTIFACTS

                // MÃ©todo para cambiar a la secciÃ³n "Guides" y cargar una guÃ­a especÃ­fica por URL
                activateGuidesAndLoadGuide(url) {
                    // Cambia la secciÃ³n activa del sidebar a "Guides"
                    this.changeSidebar('guides');

                    // Espera un momento para asegurar que la interfaz se haya actualizado
                    this.$nextTick(() => {
                        // Carga la guÃ­a especificada por la URL
                        this.loadGuideMarkdownContent(url);
                    });
                },

                async loadGuideMarkdownContent(url) {
                    if (url) {
                        try {
                            const response = await fetch(url);
                            const markdown = await response.text();
                            // AquÃ­ convertirÃ­as el Markdown a HTML
                            // Puedes usar la librerÃ­a marked.js como antes mencionÃ©
                            this.markdownGuideContent = marked.parse(markdown);
                        } catch (error) {
                            /// console.log("ð ~ loadGuideMarkdownContent ~ error:", error)
                            this.markdownContent = '';
                        }
                    } else {
                        this.markdownGuideContent = '';
                    }
                },

                setArtifactBusinessModelCanvas() {
                    this.isArtifactModalOpen = true;
                },

                // DOWNLOAD AND EXPORT

                downloadMarkdown() {
                    this.updateModelMarkdown(); // Actualiza el contenido Markdown
                    const markdownContent = this.modelMarkdown; // ObtÃ©n el contenido actual
                    const fileName = this.generateFileName(); // Usa el mismo mÃ©todo para generar el nombre del archivo

                    // Crea un Blob con el contenido Markdown
                    const blob = new Blob([markdownContent], { type: 'text/markdown' });

                    // Crea un enlace para descargar el archivo
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName;

                    // Simula un clic en el enlace para iniciar la descarga y luego limpia
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },

                processLoadedMarkdown() {
                    if (!this.newMarkdownContent) {
                        console.error("No hay contenido de Markdown para cargar.");
                        return;
                    }

                    // Simula la carga y el procesamiento del contenido Markdown
                    this.parseModelMarkdown(this.newMarkdownContent);
                },

                processNewContent() {
                    // Resetear model a un array vacÃ­o
                    this.model = [];
                    this.resetDepthCounters();
                    const content = this.newMarkdownContent;
                    // AquÃ­ debes invocar la lÃ³gica que normalmente usas para procesar el contenido Markdown cargado.
                    // Por ejemplo, si tienes un mÃ©todo que parsea el Markdown a bloques del modelo, Ãºsalo aquÃ­.
                    this.parseModelMarkdown(content);
                },

                downloadHTML() {
                    // Convierte el Markdown a HTML
                    this.updateModelMarkdown();
                    // eslint-disable-next-line no-undef
                    const htmlContent = marked.parse(this.modelMarkdown);
                    const { modelName } = this; // Obtiene el nombre actual del modelo
                    const timestamp = new Date().toISOString().replace(/[:-]|\.\d{3}/g, ''); // Genera un timestamp en el formato deseado
                    const fileName = `${modelName} - saved ${timestamp}.html`; // Construye el nombre del archivo

                    // Opcional: Si quieres incluir un estilo bÃ¡sico en tu HTML exportado, puedes agregarlo aquÃ­
                    const htmlWithStyle = `
                                <!DOCTYPE html>
                                <html lang="en">
                                    <head>
                                        <meta charset="UTF-8">
                                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                                        <title>Plastilinn</title>
                                        <link rel="stylesheet" href="https://stackedit.io/style.css" />
                                        <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
                                        <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
                                    </head>
                                    <body>
                                    <script>
                                        // Esto se ejecuta automÃ¡ticamente cuando se carga la pÃ¡gina
                                        window.onload = function() {
                                            alert("Copy the page content and paste it on your text editor");
                                        };
                                    <\/script>
                                    <style>
                                        h1,
                                        h2,
                                        h3,
                                        h4,
                                        h5,
                                        h6 {
                                            all: unset;
                                            font-size: 2rem !important;
                                            /* Ajusta el tamaÃ±o segÃºn tus necesidades */
                                            font-weight: 700 !important;
                                            /* 700 es bold */
                                            margin-bottom: 16px !important;
                                            /* AÃ±adir espacio entre los encabezados */
                                            display: block !important;
                                            /* Asegurar que los encabezados sigan siendo bloque */
                                        }
                                    </style>
                                    ${htmlContent}
                                    </body>
                                </html>
                                                    `;

                    // Crea un Blob con el contenido HTML
                    const blob = new Blob([htmlWithStyle], { type: 'text/html' });

                    // Crea un enlace para descargar el archivo
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName; // Puedes personalizar el nombre del archivo

                    // Simula un clic en el enlace para iniciar la descarga y luego limpia
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },

                toggleAutoDownload() {
                    this.autoDownloadEnabled = !this.autoDownloadEnabled;
                },

            },
            mounted() {
                this.processMetamodel(); // Otras inicializaciones pueden ir aquÃ­
                this.highlightOnLoad(); // Resalta el elemento si la pÃ¡gina se cargÃ³ con un hash.
                window.addEventListener('hashchange', this.highlightOnLoad);
                // Configura marked.js para este componente
                marked.setOptions({
                    gfm: true, // Habilita GitHub Flavored Markdown (GFM)
                    breaks: true, // Convierte los saltos de lÃ­nea simples en <br>
                });
                // Cargar la guÃ­a "Plastilinn documentation" al cargar la pÃ¡gina
                this.currentSidebarSection = 'guides'; // Cambia la secciÃ³n activa a 'guides'
                const guideUrl = 'https://xbokmd.github.io/plastilinn/docs/guides/plastilinn_documentation.md';
                this.loadGuideMarkdownContent(guideUrl); // Cargar la guÃ­a directamente
            },
        })
            .mount('#vue-app');
    </script>
</body>

</html>