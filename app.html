<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web App</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
    <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
    <style>
        /* Ajustar el estilo para etiquetas dentro de cualquier encabezado */
        h1 span[data-tag],
        h2 span[data-tag],
        h3 span[data-tag],
        h4 span[data-tag],
        h5 span[data-tag],
        h6 span[data-tag] {
            padding-left: 2.8rem;
            /* Ajusta según sea necesario */
            vertical-align: middle;
            /* Asegura que el ícono y el texto estén alineados verticalmente */
        }
    </style>
</head>

<body class="">
    <div id="vue-app">
        <div class="min-h-screen h-screen flex flex-col">
            <header class="border-b border-gray-200">
                <div id="top-container" class="bg-gray-200 w-full fixed">
                    <div id="navbar" class="navbar bg-base-100 shadow-xl">
                        <div class="navbar-start">
                            <div class="p-5">
                                <!-- Logo como imagen -->
                                <img src="assets\logo.png" alt="Logo de mi empresa" class="h-8">
                                <!-- Logo como texto o SVG, aquí un ejemplo con texto -->
                            </div>
                            <a class="btn btn-ghost text-xl">Plastilinn</a>
                        </div>
                        <div class="navbar-center">
                            <div class="flex-1 text-center bg-gray-200 rounded-lg p-2 m-2">
                                <h4 v-if="modelName">{{ modelName }}</h4>
                            </div>
                        </div>
                        <div class="navbar-end">
                            <div class="join">
                                <button id="downloadBtn" @click="downloadMarkdown"
                                    class="btn join-item btn-primary btn-sm">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
                                        class="w-6 h-6">
                                        <path fill-rule="evenodd"
                                            d="M10.5 3.75a6 6 0 0 0-5.98 6.496A5.25 5.25 0 0 0 6.75 20.25H18a4.5 4.5 0 0 0 2.206-8.423 3.75 3.75 0 0 0-4.133-4.303A6.001 6.001 0 0 0 10.5 3.75Zm2.25 6a.75.75 0 0 0-1.5 0v4.94l-1.72-1.72a.75.75 0 0 0-1.06 1.06l3 3a.75.75 0 0 0 1.06 0l3-3a.75.75 0 1 0-1.06-1.06l-1.72 1.72V9.75Z"
                                            clip-rule="evenodd" />
                                    </svg>
                                    Download
                                </button>
                                <button id="downloadBtn" @click="downloadHTML" class="btn join-item btn-primary btn-sm">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
                                        class="w-6 h-6">
                                        <path fill-rule="evenodd"
                                            d="M10.5 3.75a6 6 0 0 0-5.98 6.496A5.25 5.25 0 0 0 6.75 20.25H18a4.5 4.5 0 0 0 2.206-8.423 3.75 3.75 0 0 0-4.133-4.303A6.001 6.001 0 0 0 10.5 3.75Zm2.25 6a.75.75 0 0 0-1.5 0v4.94l-1.72-1.72a.75.75 0 0 0-1.06 1.06l3 3a.75.75 0 0 0 1.06 0l3-3a.75.75 0 1 0-1.06-1.06l-1.72 1.72V9.75Z"
                                            clip-rule="evenodd" />
                                    </svg>
                                    Export
                                </button>
                                <button @click="toggleAutoDownload"
                                    :class="{'bg-green-500': autoDownloadEnabled, 'bg-gray-500': !autoDownloadEnabled}"
                                    class="btn join-item btn-primary btn-sm">
                                    Auto Download {{ autoDownloadEnabled ? 'ON' : 'OFF' }}
                                </button>
                            </div>
                        </div>
                    </div>

                </div>
            </header>

            <!-- main container -->

            <div class="flex-1 flex flex-row overflow-y-hidden">
                <nav class="order-first w-1/4 m-4 p-2 overflow-y-auto" style="min-width: 440px">
                    <div class="flex flex-row flex-wrap gap-2 bg-white sticky top-0">
                        <div class="flex flex-row justify-between mb-4 gap-2">
                            <button @click="changeSection('home')"
                                class="collapse-filter-button btn btn-primary btn-sm">🏠 Home</button>
                            <button @click="changeSection('guides')"
                                class="collapse-filter-button btn btn-primary btn-sm">📋 Guides</button>
                            <button @click="changeSection('index')"
                                class="collapse-filter-button btn btn-primary btn-sm">🗂️ Index</button>
                            <button @click="changeSection('filter')"
                                class="collapse-filter-button btn btn-primary btn-sm">🔍 Filter</button>
                        </div>
                    </div>

                    <!-- Secciones con visibilidad condicional -->
                    <div
                        v-bind:class="{ block: currentSidebarSection === 'home', hidden: currentSidebarSection !== 'home' }">
                        <div id="sidebar-home">
                            <div>
                                <p>Plastilinn allows you to create a business model and evolve it to make it better and
                                    better. </p>
                                <div>
                                    <h5>📋 Guides</h5>
                                    <p>Includes help guides that will make it easier for you to create your business
                                        model, offering you step by step all the information you need and precise
                                        instructions.</p>
                                    <h5>🗂️ Index</h5>
                                    <p>Allows you to quickly navigate to the section of your plastilin doc that you want
                                        to consult.</p>
                                    <h5>🔍 Filter</h5>
                                    <p>Allows you to carry out smart queries by filtering the content of your plastilin
                                        doc.</p>
                                </div>
                                <div role="alert" class="alert mt-10">
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                                        class="stroke-info shrink-0 w-6 h-6">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                    </svg>
                                    <h3 class="font-bold">New to plastilin?</h3>
                                    <div class="text-xs">Simply click on the guides button in this sidebar and select
                                        the quickstart guide.</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div
                        v-bind:class="{ block: currentSidebarSection === 'guides', hidden: currentSidebarSection !== 'guides' }">
                        <!-- Select que se muestra u oculta según showSelect -->
                        <select @change="loadMarkdownContent($event.target.value)"
                            class="w-full bg-white border border-gray-300 text-gray-700 py-2 px-4 rounded-lg shadow-sm focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-200 transition duration-150 ease-in-out">
                            <option value="">Select a guide</option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/plastilinn_cheatsheet.md">
                                Plastilinn cheatsheet
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/quick_start.md">Quick start
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/using_plastilinn.md">Using
                                plastilinn
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/idea_definition.md">Idea
                                definition
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/business_model_canvas.md">Business
                                Model Canvas
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/lean_canvas.md">Lean Canvas
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/value_proposition_canvas.md">Value
                                Proposition Canvas
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/empathy_map.md">Empathy map
                            </option>
                        </select>
                        <!-- Div que muestra el contenido del Markdown seleccionado -->
                        <div v-if="markdownGuideContent">
                            <div v-html="markdownGuideContent"></div>
                        </div>

                        <button
                            @click="setArtifactBusinessModelCanvas('partners', 'activities', 'valuePropositions', 'relationships', 'profile', 'resources', 'channels', 'costLines', 'revenueLines'); isArtifactModalOpen = true">Business
                            Model Canvas</button>

                        <div id="artifact-modal" v-if="isArtifactModalOpen"
                            style="position: fixed; top: 5%; left: 5%; width: 90%; height: 90%; z-index: 100; background-color: white; overflow: auto; padding: 20px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);">
                            <!-- Usa v-html para insertar el contenido de artifactModalContent como HTML -->
                            <button @click="isArtifactModalOpen = false">Cerrar</button>
                            <div v-html="artifactModalContent"></div>
                            <div id="business-model-canvas" class="bg-gray-100 -black h-screen p-5">
                                <div class="row-span-2 grid h-3/5 grid-cols-5 bg-white  shadow-lg">
                                    <div class="row-span-2 border pl-2">
                                        <h3>Key Partners</h2>
                                    </div>
                                    <div class="row-span-1 border pl-2">
                                        <h3>Key activities</h3>
                                        <div v-html="buildTagsQueryList(['work'])"></div>
                                    </div>
                                    <div class="row-span-2 border pl-2">
                                        <h3>Value propositions</h3>
                                    </div>
                                    <div class="border pl-2">
                                        <h3>
                                            Customer relationships</h3>
                                    </div>
                                    <div class="row-span-2 border< pl-2>">
                                        <h3>Customer segments</h3>
                                    </div>
                                    <div class="border pl-2">
                                        <h3>Key resources</h3>
                                    </div>
                                    <div class="border pl-2">
                                        <h3>Channels</h3>
                                        <div v-html="buildTagsQueryList(['tag1', 'tag2'])"></div>
                                    </div>
                                </div>
                                <div class="grid h-52 grid-cols-2 bg-white shadow-lg">
                                    <div class="border pl-2">
                                        <h3>Cost lines</h3>
                                    </div>
                                    <div class="border pl-2">
                                        <h3>
                                            Revenue lines</h3>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div
                            v-bind:class="{ block: currentSidebarSection === 'index', hidden: currentSidebarSection !== 'index' }">
                            <div class="index">
                                <ul class="menu p-4 w-80 bg-base-100">
                                    <li v-for="block in model.filter(b => b.blockType === 'section')" :key="block.id"
                                        :class="`pl-${block.depthLevel * 4} p-0`">
                                        <a :href="'#' + block.blockTitle">{{ block.blockTitle }}</a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                        <div
                            v-bind:class="{ block: currentSidebarSection === 'filter', hidden: currentSidebarSection !== 'filter' }">
                            <div class=" flex justify-between bg-white" v-if="filterVisible">
                                <div class="flex flex-col gap-4">
                                    <div class="flex flex-col w-full">
                                        <div class="flex flex-col w-full p-4 bg-white rounded-lg shadow-sm">
                                            <!-- Búsqueda -->
                                            <div class="flex items-center mb-4 p-2 bg-gray-50 rounded-lg shadow">
                                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                                                    fill="currentColor" class="w-5 h-5 text-gray-400">
                                                    <path fill-rule="evenodd"
                                                        d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z"
                                                        clip-rule="evenodd" />
                                                </svg>
                                                <input v-model="searchQuery" type="text" placeholder="Search..."
                                                    class="input ml-2 bg-gray-50 w-full">
                                            </div>
                                            <!-- Botón para abrir el modal de búsqueda y reemplazo -->
                                            <button @click="showSearchReplaceModal = true" class="btn btn-primary">Abrir
                                                búsqueda y reemplazo</button>
                                            <!-- Filtro de etiquetas -->
                                            <div class="flex flex-col">
                                                <div class="flex items-center mb-4 p-2 bg-gray-50 rounded-lg shadow">
                                                    <span>Filter tags</span>
                                                    <div class="flex flex-wrap gap-2 mt-2">
                                                        <span v-for="tag in selectedTags" :key="tag"
                                                            class="flex items-center justify-center h-8 px-2 text-sm"
                                                            :data-tag="tag">{{ tag }}</span>
                                                    </div>
                                                    <button @click="resetSelectedTags" class="btn btn-ghost btn-sm">
                                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                                                            fill="currentColor" class="w-6 h-6">
                                                            <path fill-rule="evenodd"
                                                                d="M4.755 10.059a7.5 7.5 0 0 1 12.548-3.364l1.903 1.903h-3.183a.75.75 0 1 0 0 1.5h4.992a.75.75 0 0 0 .75-.75V4.356a.75.75 0 0 0-1.5 0v3.18l-1.9-1.9A9 9 0 0 0 3.306 9.67a.75.75 0 1 0 1.45.388Zm15.408 3.352a.75.75 0 0 0-.919.53 7.5 7.5 0 0 1-12.548 3.364l-1.902-1.903h3.183a.75.75 0 0 0 0-1.5H2.984a.75.75 0 0 0-.75.75v4.992a.75.75 0 0 0 1.5 0v-3.18l1.9 1.9a9 9 0 0 0 15.059-4.035.75.75 0 0 0-.53-.918Z"
                                                                clip-rule="evenodd" />
                                                        </svg>Reset</button>
                                                </div>
                                                <select v-model="selectedTags"
                                                    class="select select-bordered w-full p-2 bg-white rounded-lg shadow"
                                                    multiple>
                                                    <option v-for="tag in tags" :key="tag" :value="tag">{{ tag }}
                                                    </option>
                                                </select>
                                            </div>
                                        </div>
                                        <div class="">

                                            <!-- Botones para aplicar filtros directamente -->
                                            <div class="rounded-lg shadow-md overflow-hidden border border-red-500 m-2">
                                                <button @click="setFilterTags(['*****', '?????'])"
                                                    class="bg-red-500 text-white px-4 py-2 hover:bg-red-600 focus:ring-red-500 focus:ring-opacity-50 w-full">
                                                    High priority
                                                </button>
                                                <div class="flex items-center bg-gray-100 px-4 py-2">
                                                    <p>
                                                        <span data-tag="!!!!!">!!!!!</span> <kbd
                                                            class="kbd kbd-xs">#!!!!!</kbd> or
                                                        <span data-tag="!!!!">!!!!</span> <kbd
                                                            class="kbd kbd-xs">#!!!!</kbd>
                                                    </p>
                                                </div>
                                            </div>
                                            <div class="rounded-lg shadow-md overflow-hidden border border-red-500 m-2">
                                                <button @click="setFilterTags(['*****', '?????'])"
                                                    class="bg-red-500 text-white px-4 py-2 hover:bg-red-600 focus:ring-red-500 focus:ring-opacity-50 w-full">
                                                    High importance or uncertainty
                                                </button>
                                                <div class="flex items-center bg-gray-100 px-4 py-2">
                                                    <p>
                                                        <span data-tag="*****">*****</span> <kbd
                                                            class="kbd kbd-xs">#*****</kbd> or
                                                        <span data-tag="?????">?????</span> <kbd
                                                            class="kbd kbd-xs">#?????</kbd>
                                                    </p>
                                                </div>
                                            </div>

                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                </nav>

                <main class="flex-auto  border-l border-r border-gray-200 p-2 overflow-y-auto"
                    style="scroll-behavior: smooth;">
                    <div class="leading-10">
                        <div id="content" class="bg-gray-200 p-1 rounded">
                            <div class="plastilinn-hero hero pt-48" v-if="!markdownLoaded">
                                <div class="hero-content text-center">
                                    <div class="max-w-md">
                                        <div class="m-auto max-w-6xl p-12">
                                            <div class="flex flex-col md:flex-row">
                                                <div class="md:w-1/2 max-w-md flex flex-col justify-center">

                                                </div>
                                            </div>
                                        </div>
                                        <div class="md:text-5xl text-2xl uppercase font-black">Shape your business with
                                            AI</div>
                                        <div class="text-xl mt-4">Design, analyze and validate your business model.
                                        </div>
                                        <div role="alert" class="alert m-8">
                                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                                                class="stroke-info shrink-0 w-6 h-6">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z">
                                                </path>
                                            </svg>
                                            <span>Upload your plastilinn doc</span>
                                        </div>
                                        <input type="file" @change="loadAndParseMarkdown" accept=".md"
                                            class="file-input file-input-bordered file-input-primary w-full max-w-xs m-4">
                                    </div>
                                </div>
                            </div>
                            <div class="modelContainer m-2 p-0">
                                <div class="flex flex-row w-full">
                                    <div class="md-block-wrapper w-full">
                                        <div v-for="block in searchFilteredBlocks" :key="block.id"
                                            :id="block.blockTitle" class="md-block flex">
                                            <div
                                                class="md-block-container-middle md-block-content shadow-xl hover:shadow-2xl transition-shadow p-2 ml-2 mr-2 custom-flex-2 w-1/2">
                                                <div v-html="block.parsedContent"></div>
                                            </div>
                                            <div
                                                class="md-block-container-right tags-container text-gray-500 w-full rounded-md text-sm text-center p-2 mt-1 mb-1 w-1/4">
                                                <div
                                                    class="flex flex-col items-start justify-start w-full bg-gray-200 rounded-md text-sm text-gray-500 p-2 mt-1 mb-1 w-1/4">
                                                    <div class="xbok-block-tags flex items-center gap-2">
                                                        <span data-tag="edit"
                                                            class="flex items-center justify-center h-8 px-2 text-sm">
                                                            <button @click="openModal(block)"
                                                                class="opacity-50 hover:opacity-100 focus:opacity-100"><svg
                                                                    xmlns="http://www.w3.org/2000/svg"
                                                                    viewBox="0 0 24 24" fill="blue" class="w-4 h-4">
                                                                    <path
                                                                        d="M21.731 2.269a2.625 2.625 0 0 0-3.712 0l-1.157 1.157 3.712 3.712 1.157-1.157a2.625 2.625 0 0 0 0-3.712ZM19.513 8.199l-3.712-3.712-12.15 12.15a5.25 5.25 0 0 0-1.32 2.214l-.8 2.685a.75.75 0 0 0 .933.933l2.685-.8a5.25 5.25 0 0 0 2.214-1.32L19.513 8.2Z" />
                                                                </svg>
                                                            </button>
                                                        </span>
                                                        <div :id="block.metamodel.name"
                                                            class="block-metamodel section inline-flex"
                                                            v-if="block.metamodel">
                                                            <span data-tag="section"
                                                                class="flex items-center justify-center h-8 px-2 text-sm">
                                                                <button @click="openRemoteModal(block.metamodel.name)"
                                                                    class="opacity-50 hover:opacity-100 focus:opacity-100">
                                                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none"
                                                                        viewBox="0 0 24 24" stroke-width="1.5"
                                                                        stroke="blue" class="w-6 h-6">
                                                                        <path stroke-linecap="round"
                                                                            stroke-linejoin="round"
                                                                            d="m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z" />
                                                                    </svg>
                                                                </button>
                                                        </div>
                                                        <div class="md-block-container-right tags-container"
                                                            v-html="block.tagsParsed">
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div id="content" class="mt-48 ml-2 mr-2">
                                <div class="flex flex-row w-full">
                                    <div class="md-block-wrapper w-full">
                                        <div v-for="block in filteredBlocks" :key="block.id" :id="block.blockTitle"
                                            class="md-block flex">
                                            <!-- Renderizar los bloques -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </main>


            </div>
            <!-- end main container -->

            <footer class="border-t border-gray-200 p-2">Footer</footer>
        </div>

        <!-- MODAL WINDOWS -->

        <!-- Modal de búsqueda y reemplazo -->
        <div v-if="showSearchReplaceModal"
            class="fixed inset-0 bg-gray-600 bg-opacity-75 flex justify-center items-center">
            <div class="bg-white p-4 rounded-lg shadow-lg flex flex-col">
                <div class="mb-2">
                    <label for="searchText" class="block text-sm font-medium text-gray-700">Texto a buscar</label>
                    <input v-model="searchText" id="searchText" type="text"
                        class="mt-1 p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div class="mb-4">
                    <label for="replaceText" class="block text-sm font-medium text-gray-700">Texto de reemplazo</label>
                    <input v-model="replaceText" id="replaceText" type="text"
                        class="mt-1 p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div class="flex justify-end gap-2">
                    <button @click="showSearchReplaceModal = false" class="btn btn-secondary">Cancelar</button>
                    <button @click="performSearchReplace(searchText)" class="btn mb-2 btn-primary">Reemplazar</button>
                </div>
            </div>
        </div>

        <!-- Modal para editar el contenido del bloqur seleccionada -->
        <div v-if="isModalOpen"
            class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full items-center z-50">
            <div class="modal-background absolute inset-0 bg-black opacity-50"></div>
            <div class="relative top-20 mx-auto p-5 border w-4/5 shadow-lg rounded-md bg-white flex flex-col justify-center items-center"
                style="z-index: 100;">
                <div class="flex">
                    <div class="mt-3 text-center">
                        <div class="mt-2">
                            <div id="editor-container"></div>
                        </div>
                        <button class="btn m-2 btn-primary btn-sm" @click="sendMessageToBot()"><svg
                                xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
                                class="w-6 h-6">
                                <path d="M16.5 7.5h-9v9h9v-9Z" />
                                <path fill-rule="evenodd"
                                    d="M8.25 2.25A.75.75 0 0 1 9 3v.75h2.25V3a.75.75 0 0 1 1.5 0v.75H15V3a.75.75 0 0 1 1.5 0v.75h.75a3 3 0 0 1 3 3v.75H21A.75.75 0 0 1 21 9h-.75v2.25H21a.75.75 0 0 1 0 1.5h-.75V15H21a.75.75 0 0 1 0 1.5h-.75v.75a3 3 0 0 1-3 3h-.75V21a.75.75 0 0 1-1.5 0v-.75h-2.25V21a.75.75 0 0 1-1.5 0v-.75H9V21a.75.75 0 0 1-1.5 0v-.75h-.75a3 3 0 0 1-3-3v-.75H3A.75.75 0 0 1 3 15h.75v-2.25H3a.75.75 0 0 1 0-1.5h.75V9H3a.75.75 0 0 1 0-1.5h.75v-.75a3 3 0 0 1 3-3h.75V3a.75.75 0 0 1 .75-.75ZM6 6.75A.75.75 0 0 1 6.75 6h10.5a.75.75 0 0 1 .75.75v10.5a.75.75 0 0 1-.75.75H6.75a.75.75 0 0 1-.75-.75V6.75Z"
                                    clip-rule="evenodd" />
                            </svg>
                            AI suggest content</button>
                        <button class="btn m-2 btn-primary btn-sm" @click="saveChanges"><svg
                                xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
                                class="w-6 h-6">
                                <path
                                    d="M3.375 3C2.339 3 1.5 3.84 1.5 4.875v.75c0 1.036.84 1.875 1.875 1.875h17.25c1.035 0 1.875-.84 1.875-1.875v-.75C22.5 3.839 21.66 3 20.625 3H3.375Z" />
                                <path fill-rule="evenodd"
                                    d="m3.087 9 .54 9.176A3 3 0 0 0 6.62 21h10.757a3 3 0 0 0 2.995-2.824L20.913 9H3.087ZM12 10.5a.75.75 0 0 1 .75.75v4.94l1.72-1.72a.75.75 0 1 1 1.06 1.06l-3 3a.75.75 0 0 1-1.06 0l-3-3a.75.75 0 1 1 1.06-1.06l1.72 1.72v-4.94a.75.75 0 0 1 .75-.75Z"
                                    clip-rule="evenodd" />
                            </svg>
                            Save changes</button>
                        <button class="btn m-2 btn-primary btn-sm" @click="closeModal"><svg
                                xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
                                class="w-6 h-6">
                                <path fill-rule="evenodd"
                                    d="M5.47 5.47a.75.75 0 0 1 1.06 0L12 10.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L13.06 12l5.47 5.47a.75.75 0 1 1-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 0 1 0-1.06Z"
                                    clip-rule="evenodd" />
                            </svg>
                            Close window</button>
                    </div>
                </div>
            </div>

        </div>
        <script>
            Vue.createApp({
                data() {
                    return {
                        currentSidebarSection: 'home',
                        metamodel: [],
                        model: [], // Se utilizará para almacenar el modelo de datos creado a partir del Markdown
                        lastId: 0, // Inicializa un contador para los IDs
                        modelName: '',
                        modelMarkdown: '', // Campo para almacenar el contenido Markdown concatenado
                        isModalOpen: false,
                        selectedBlockContent: '',
                        selectedBlockIndex: null,
                        blocks: [], // Puedes inicializarlo como un array vacío o con valores iniciales
                        currentBlockId: null,
                        tags: [], // Inicializa tags aquí
                        allTags: new Set(),
                        selectedTags: [], // Almacena las etiquetas seleccionadas
                        markdownLoaded: false, // Variable para controlar si el markdown ha sido cargado y analizado
                        filterVisible: true,
                        blockTitles: [], // Arreglo para almacenar todos los blockTitles únicos
                        selectedBlockTitles: [], // Arreglo para almacenar los blockTitles seleccionados
                        searchQuery: '',
                        isSidebarVisible: true, // Controla la visibilidad de la sidebar
                        isIndexOpen: true,
                        isInfoModalOpen: false,
                        selectedInfoBlock: null, // Para almacenar la información del bloque seleccionado
                        currentBlockInfoURL: null,
                        components: [],
                        autoDownloadEnabled: true,
                        showGuidesSelect: false, // Controla la visibilidad del select
                        markdownGuideContent: '', // Almacena el contenido del Markdown cargado
                        searchText: '',
                        replaceText: '',
                        showSearchReplaceModal: false,
                        isArtifactModalOpen: false,
                        artifactModalContent: '', // Almacenará el contenido HTML generado
                    };
                },
                computed: {
                    parsedModel() {
                        return this.model.map(block => {
                            return { ...block, parsedContent: marked.parse(block.content) };
                        });
                    },
                    filteredBlocks() {
                        const blocksWithSections = [];
                        const addedSectionIds = new Set(); // Almacena los IDs de secciones ya añadidas

                        this.model.filter(block => {
                            const tagMatch = this.selectedTags.length === 0 || this.selectedTags.some(tag => block.tags.includes(tag));
                            const titleMatch = this.selectedBlockTitles.length === 0 || this.selectedBlockTitles.includes(block.blockTitle);
                            return tagMatch && titleMatch;
                        }).forEach(block => {
                            if (block.blockType === 'item') {
                                const sectionUid = String(block.id).split('.')[0];
                                // Verificar si la sección ya fue añadida, si no, encontrar y añadir la sección
                                if (!addedSectionIds.has(sectionUid)) {
                                    const sectionBlock = this.model.find(b => String(b.id) === sectionUid && b.blockType === 'section');
                                    if (sectionBlock && !blocksWithSections.includes(sectionBlock)) {
                                        blocksWithSections.push(sectionBlock);
                                        addedSectionIds.add(sectionUid);
                                    }
                                }
                            }
                            // Añadir el bloque si es un ítem o si es una sección que no ha sido añadida previamente
                            if (block.blockType === 'section' && !addedSectionIds.has(String(block.id))) {
                                addedSectionIds.add(String(block.id));
                                blocksWithSections.push(block);
                            } else if (block.blockType === 'item') {
                                blocksWithSections.push(block);
                            }
                        });
                        return blocksWithSections;
                    },
                    searchFilteredBlocks() {
                        if (!this.searchQuery) return this.filteredBlocks; // Utiliza filteredBlocks para mantener los filtros anteriores
                        return this.filteredBlocks.filter(block => {
                            // Verifica si el contenido del bloque incluye el texto de búsqueda
                            // Asume que 'parsedContent' es el contenido que deseas buscar
                            return block.parsedContent.toLowerCase().includes(this.searchQuery.toLowerCase());
                        });
                    },
                },
                methods: {
                    filteredBlocksByTags(tags) {
                        return this.model.filter(block =>
                            block.tags.some(tag => tags.includes(tag))
                        );
                    },
                    setArtifactTest(placeholder1, placeholder2) {
                        this.artifactModalContent = `
                        <div>
                            <h3>1</h3>
                            ${placeholder1}
                        </div>
                        <div>
                            <h3>2</h3>
                            ${placeholder2}
                        </div>
                    `;
                        this.isArtifactModalOpen = true;
                    },
                    buildTagsQueryList(tags) {
                        // Filtra los bloques que contienen todas las etiquetas especificadas
                        const filteredBlocks = this.model.filter(block =>
                            // Comprueba si cada etiqueta especificada está presente en las etiquetas del bloque
                            tags.every(tag => block.tags.includes(tag))
                        );

                        // Construye una lista de HTML con los blockTitles de los bloques filtrados
                        let htmlList = '<ul>';
                        filteredBlocks.forEach(block => {
                            htmlList += `<li>${block.blockTitle}</li>`;
                        });
                        htmlList += '</ul>';

                        // Devuelve la lista HTML
                        return htmlList;
                    },
                    buildArtifactBusinessModelCanvas() {
                        let partners
                        let activities
                        let valuePropositions
                        let relationships
                        let profile
                        let resources
                        let channels
                        let costLines
                        let revenueLines
                        setArtifactBusinessModelCanvas(partners, activities, valuePropositions, relationships, profile, resources, channels, costLines, revenueLines);
                    },
                    setArtifactBusinessModelCanvas(partners, activities, valuePropositions, relationships, profile, resources, channels, costLines, revenueLines) {
                        this.artifactModalContent = `
                        <div id="business-model-canvas" class="bg-gray-100 -black h-screen p-5">
                            <div class="row-span-2 grid h-3/5 grid-cols-5 bg-white  shadow-lg">
                                <div class="row-span-2 border pl-2">
                                    <h3>Key Partners</h2>
                                    ${partners}
                                </div>
                                <div class="row-span-1 border pl-2">
                                    <h3>Key activities</h3>
                                    ${activities}
                                </div>
                                <div class="row-span-2 border pl-2">
                                    <h3>Value propositions</h3>
                                    ${valuePropositions}
                                </div>
                                <div class="border pl-2">
                                    <h3>Customer relationships</h3>
                                    ${relationships}
                                </div>
                                <div class="row-span-2 border pl-2">
                                    <h3>Customer segments</h3>
                                    ${profile}
                                </div>
                                <div class="border pl-2">
                                    <h3>Key resources</h3>
                                    ${resources}
                                </div>
                                <div class="border pl-2">
                                    <h3>Channels</h3>
                                    ${channels}
                                </div>
                            </div>
                            <div class="grid h-52 grid-cols-2 bg-white shadow-lg">
                                <div class="border pl-2">
                                    <h3>Cost lines</h3>
                                    ${costLines}
                                </div>
                                <div class="border pl-2">
                                    <h3>Revenue lines</h3>
                                    ${revenueLines}
                                </div>
                            </div>
                        </div>
                `;
                        this.isArtifactModalOpen = true;
                    },
                    changeSection(section) {
                        this.currentSidebarSection = section;
                        console.log("Sección actual del sidebar:", this.currentSidebarSection);
                        // Aquí puedes agregar cualquier otra lógica que necesites ejecutar cuando cambies de sección
                    },
                    performSearchReplace(originalText) {
                        // Asegúrate de que searchText no esté vacío y que realmente quieras usar el argumento originalText
                        if (!originalText) return; // Sale si originalText está vacío

                        this.model.forEach(block => {
                            // Usa la variable originalText en lugar de searchText para el reemplazo
                            block.content = block.content.replaceAll(originalText, this.replaceText);
                            // Actualiza el contenido parseado después del reemplazo para reflejar los cambios
                            block.parsedContent = marked.parse(block.content);
                        });

                        // Restablece searchText y replaceText a cadenas vacías después del reemplazo
                        this.searchText = '';
                        this.replaceText = '';
                        this.showSearchReplaceModal = false; // Cierra el modal después de realizar el reemplazo
                    },
                    async loadMarkdownContent(url) {
                        if (url) {
                            try {
                                const response = await fetch(url);
                                const markdown = await response.text();
                                // Aquí convertirías el Markdown a HTML
                                // Puedes usar la librería marked.js como antes mencioné
                                this.markdownGuideContent = marked.parse(markdown);
                            } catch (error) {
                                console.error("Error cargando el archivo Markdown:", error);
                                this.markdownContent = '';
                            }
                        } else {
                            this.markdownGuideContent = '';
                        }
                    },
                    assignUids() {
                        let sectionUid = 0; // Contador para uid de sección
                        let itemUidCounter = 0; // Contador para uid de ítem dentro de la sección

                        this.model.forEach((block, index) => {
                            if (block.blockType === 'section') {
                                sectionUid++;
                                itemUidCounter = 0; // Reinicia el contador de ítems para la nueva sección
                                block.id = `${sectionUid}`; // Asigna el uid de la sección
                            } else if (block.blockType !== 'section') { // Cambio aquí para incluir cualquier tipo que no sea 'section'
                                itemUidCounter++;
                                block.id = `${sectionUid}.${itemUidCounter}`; // Asigna el uid compuesto a los ítems
                            }
                        });
                    },
                    loadAndParseMarkdown(event) {
                        const file = event.target.files[0];
                        if (!file) {
                            return;
                        }
                        const modelName = this.getModelNameFromFileName(file.name);
                        this.modelName = modelName; // Actualiza modelName con el resultado de la función
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const content = e.target.result;
                            this.parseMarkdown(content);
                        };
                        reader.readAsText(file);
                        this.markdownLoaded = true;
                    },
                    getModelNameFromFileName(fileName) {
                        let name = fileName.replace(/\.md$/, ''); // Elimina la extensión ".md"
                        name = name.replace(/ - saved.*$/, ''); // Elimina " - saved" y todo lo que sigue
                        return name;
                    },
                    setInstanceValue() {
                        this.model.forEach(block => {
                            // Verifica si blockTitle comienza con una etiqueta
                            if (/^#\w+/.test(block.blockTitle)) {
                                // Si blockTitle comienza con una etiqueta, asigna blockTitle a instanceValue
                                block.instanceValue = block.blockTitle;
                            }
                            // Continúa con la lógica original de división y asignación
                            // Extrae el componente del título que sigue inmediatamente después de la etiqueta inicial
                            const titleParts = block.blockTitle.match(/^#\w+\s+(.*?)\s*(\/|$)/);

                            if (titleParts && titleParts[1]) {
                                // Asigna el componente extraído a instanceValue, eliminando etiquetas adicionales si las hay
                                block.instanceValue = titleParts[1].replace(/#\w+/g, '').trim();
                            } else {
                                // Si no se encuentra el patrón esperado, asigna null o maneja según sea necesario
                                block.instanceValue = null;
                            }

                            // Añadir lógica para manejar instanceSection
                            const sectionParts = block.blockTitle.split(" / ");
                            if (sectionParts.length > 1) {
                                // Asume que el texto después del " / " debe ser asignado a instanceSection
                                block.instanceSection = sectionParts[1].trim();
                            } else {
                                // Si no hay un " / " en el blockTitle, se decide dejar instanceSection como null
                                block.instanceSection = null;
                            }

                            // Generar y asignar metamodelID directamente aquí
                            // Se añade "/ ${block.instanceSection}" solo si instanceSection existe y tiene un valor
                            let blockMetamodelID = `#${block.instanceClass} ${block.instanceValue}` + (block.instanceSection ? ` / ${block.instanceSection}` : '');
                            block.metamodelID = blockMetamodelID;
                        });
                    },
                    parseMarkdown(content) {
                        const blocks = []; // Almacenará los bloques identificados
                        let currentBlock = []; // Almacena las líneas del bloque actual
                        const lines = content.split(/\r?\n/); // Divide el contenido en líneas

                        lines.forEach(line => {
                            // Verifica si la línea actual marca el inicio de un nuevo bloque
                            if (/^\s*([-*\d.]*)*\s*#/.test(line)) {
                                if (currentBlock.length > 0) {
                                    blocks.push(currentBlock.join('\n')); // Agrega el bloque actual a los bloques
                                    currentBlock = []; // Reinicia el bloque actual
                                }
                            }
                            currentBlock.push(line); // Añade la línea al bloque actual
                        });
                        if (currentBlock.length > 0) {
                            blocks.push(currentBlock.join('\n')); // Asegúrate de añadir el último bloque
                        }

                        // Actualiza this.model para que contenga bloques en lugar de líneas individuales
                        this.model = blocks.map((blockContent, index) => {
                            this.lastId += 1; // Incrementa el ID para cada bloque
                            const firstLine = blockContent.split('\n')[0];

                            let blockType = 'item';
                            // Use a simpler approach to count '#' at the start of the line for depth level
                            const depthLevel = firstLine.startsWith('#') ? firstLine.match(/^#+/)[0].length : 0;

                            if (/^\s*(-\s+)?#(\s|#)/.test(firstLine)) {
                                blockType = 'section';
                            } else if (firstLine.match(/^\s*[\-\*] /) || firstLine.match(/^\s*\d+\. /)) {
                                blockType = 'item';
                            }

                            let instanceClass = null; // Inicializa instanceClass como null

                            // Verifica si el bloque es de tipo 'section' y busca una etiqueta justo después del encabezado
                            if (blockType === 'section' && /^\s*#*\s*#([^\s]+)/.test(blockContent)) {
                                const match = blockContent.match(/^\s*#*\s*#([^\s]+)/);
                                if (match && match[1]) {
                                    instanceClass = match[1]; // Asigna el nombre de la etiqueta a instanceClass
                                }
                            }

                            const { tags, tagsParsed } = this.processTags(blockContent);
                            let blockTitle = this.extractBlockTitle(blockContent);
                            const blockContentWithTagsParsed = this.parseMDToHTML(blockContent);
                            const parsedContent = marked.parse(blockContentWithTagsParsed); // Parsea el contenido Markdown
                            console.log(blockTitle);
                            let metamodelID = "";
                            let metamodel = this.importMetamodelData(blockTitle, instanceClass);

                            if (instanceClass && blockTitle) {
                                // Actualiza el blockTitle concatenando el valor de instanceClass y el valor original de blockTitle.
                                // Asegúrate de incluir el '#' si es necesario y un espacio para separar los valores.
                                blockTitle = `#${instanceClass} ${blockTitle}`;
                            }


                            // Suponiendo que importMetamodelData devuelve un objeto metamodelo con la estructura esperada
                            if (metamodel && metamodel.name) {
                                // Aquí asumimos que quieres usar el valor de `name` del metamodelo
                                // como el `metamodelID` del bloque actual en el modelo.
                                metamodelID = metamodel.name;
                            }

                            if (blockTitle.includes("/")) {
                                const parts = blockTitle.split("/");
                                instanceValue = parts[0].trim(); // La parte antes del "/" es el instanceValue
                                // Reemplazar instanceValue por "Id" en metamodelID
                                metamodelID = metamodelID.replace(instanceValue, "Id").trim();
                            }

                            return {
                                id: this.lastId,
                                content: blockContent,
                                blockType: blockType,
                                tags: tags,
                                tagsParsed: tagsParsed,
                                blockTitle: blockTitle,
                                parsedContent: parsedContent, // Agrega la propiedad parsedContent al objeto block
                                metamodel: metamodel,
                                depthLevel: depthLevel, // Include the depth level here
                                instanceClass: instanceClass, // Agrega instanceClass al objeto
                                metamodelID: metamodelID,
                            };
                        });
                        this.updateModelMarkdown();
                        console.log(this.model); // Verificar la carga y transformación del contenido
                        window.botpressWebChat.sendEvent({ type: 'hide' });
                        this.assignUids();
                        this.setInstanceValue();
                    },
                    extractBlockTitle(blockContent) {
                        const firstLine = blockContent.split(/\r?\n/)[0]; // Obtiene la primera línea

                        // Extrae el encabezado Markdown y la primera etiqueta (si existe) que esté directamente después del encabezado
                        const matches = firstLine.match(/^(#+\s*)(#[^\s]+)?\s*(.*)/);
                        if (matches) {
                            const markdownHeader = matches[1]; // Encabezado Markdown (p.ej., '###')
                            const directTag = matches[2] ? matches[2] + ' ' : ''; // La etiqueta directa después del encabezado, si existe
                            const restOfTheTitle = matches[3]; // El resto del título después del encabezado y la etiqueta directa

                            // Combina la etiqueta directa (si existe) y el resto del título, eliminando otras etiquetas
                            const blockTitle = (directTag + restOfTheTitle).replace(/#[^\s]+/g, '').trim();

                            return blockTitle;
                        }

                        // En caso de que no haya coincidencia (lo cual sería inusual), retorna la línea completa
                        return firstLine;
                    },
                    updateBlockTitles() {
                        // Recorre todos los bloques y agrega sus blockTitles al arreglo blockTitles
                        this.model.forEach(block => {
                            if (!this.blockTitles.includes(block.blockTitle)) {
                                this.blockTitles.push(block.blockTitle);
                            }
                        });
                    },
                    importMetamodelData(blockTitle, instanceClass) {
                        console.log("importMetamodelData called with blockTitle:", blockTitle, "and instanceClass:", instanceClass);

                        // Intenta encontrar una coincidencia usando el blockTitle
                        let section = this.metamodel.sections.find(s => s.name === blockTitle);
                        console.log("After trying to match with blockTitle, section is:", section);

                        // Si no encuentra una coincidencia con blockTitle, intenta con instanceClass
                        if (!section && instanceClass) {
                            console.log("No match found with blockTitle, trying with instanceClass:", instanceClass);
                            section = this.metamodel.sections.find(s => s.name === instanceClass);
                            console.log("After trying to match with instanceClass, section is:", section);
                        }

                        // Si se encuentra una coincidencia
                        if (section) {
                            console.log("Match found, section:", section);
                            const blockIndex = this.model.findIndex(block => block.blockTitle === blockTitle || block.instanceClass === instanceClass);
                            console.log("Block index found for update:", blockIndex);

                            if (blockIndex !== -1) {
                                // Actualiza el bloque encontrado con la sección del metamodelo encontrada
                                this.$set(this.model[blockIndex], 'metamodel', section);
                                console.log("Model updated at index:", blockIndex, "with section:", section);
                            } else {
                                console.log("No matching block found in model for given blockTitle or instanceClass.");
                            }
                        } else {
                            console.log("No matching section found in metamodel for given blockTitle or instanceClass.");
                        }

                        // Devuelve la sección encontrada (o undefined si no se encontró ninguna coincidencia)
                        return section;
                    },

                    parseMDToHTML(content) {
                        // Procesa etiquetas como antes
                        const processedTagsContent = content.replace(/(^|\s)#([^#\s][^\s]*)/g, (match, p1, p2) => {
                            return `${p1}<span data-tag="${p2}" class="items-center justify-start rounded p-2">#${p2}</span>`;
                        });

                        // Procesa los saltos de línea, excepto en bloques de código
                        const processedContent = processedTagsContent.split('\n').map((line, index, lines) => {
                            // Detecta bloques de código para evitar añadir <br> dentro de ellos
                            if (line.startsWith('```')) {
                                // Busca el siguiente bloque de cierre de código y salta al índice correspondiente
                                const findClosingTagIndex = lines.slice(index + 1).findIndex(line => line.startsWith('```'));
                                if (findClosingTagIndex !== -1) {
                                    index += findClosingTagIndex + 1;
                                }
                                return line; // No modifica los bloques de código
                            } else {
                                // Añade <br> al final de las líneas que no son parte de un bloque de código
                                return line + '<br>';
                            }
                        }).join('\n');

                        return processedContent;
                    },
                    processTags(content) {
                        // Usando matchAll para capturar el texto después del #
                        const regex = /(?:^|\s)#([^\s]+)/g;
                        const matches = Array.from(content.matchAll(regex));

                        // Extraemos solo las etiquetas sin el símbolo # para tags
                        const tags = matches.map(match => match[1]);

                        // Generamos el HTML para tagsParsed
                        const tagsParsed = tags.map(tag => `<span data-tag="${tag}" class="items-center justify-start rounded p-2">#${tag}</span>`).join('');

                        return {
                            tags: tags, // Ya no necesitamos eliminar el símbolo '#' aquí, porque ya lo hicimos arriba
                            tagsParsed: tagsParsed
                        };
                    },
                    updateModelMarkdown() {
                        // Inicializa una variable para almacenar el contenido concatenado
                        let concatenatedContent = '';

                        // Recorre cada elemento del array model y concatena su contenido con saltos de línea
                        this.model.forEach(item => {
                            concatenatedContent += item.content + '\n';
                        });

                        // Guarda el contenido generado en el campo modelMarkdown del objeto model
                        this.modelMarkdown = concatenatedContent;
                        this.updateTagsArray();
                        console.log(concatenatedContent);
                    },
                    updateTagsArray() {
                        // Cargar la lista de bloques
                        this.blocks = this.model; // Asume que this.model contiene tus bloques
                        this.blocks.forEach(block => block.tags.forEach(tag => this.allTags.add(tag)));
                        // Convertir allTags a un array, ordenarlo alfabéticamente y luego asignar a this.tags
                        this.tags = Array.from(this.allTags).sort((a, b) => a.localeCompare(b));
                        console.log(this.tags);
                        // Inicializar el filtrado (si necesario)
                        this.filterBlocks([]);
                    },
                    filterBlocks(tags) {
                        // Implementa la lógica para filtrar los bloques aquí
                        // Utiliza la lista de bloques `this.model` y los tags seleccionados `tags`
                        // para filtrar los bloques según los tags

                        // Ejemplo de implementación:
                        // Filtra los bloques que contienen al menos uno de los tags seleccionados
                        this.filteredBlocks = this.model.filter(block => {
                            return tags.some(tag => block.tags.includes(tag));
                        });
                    },
                    resetSelectedTags() {
                        this.selectedTags = [];
                    },
                    setFilterTags(tags) {
                        // Establece las etiquetas seleccionadas directamente
                        this.selectedTags = tags;
                    },
                    downloadJSON() {
                        axios.get('https://xbokmd.github.io/plastilinn/metamodel.json')
                            .then(response => {
                                if (response.data && response.data.classes && response.data.sections) {
                                    this.metamodel = response.data;
                                    console.log('Metamodel loaded:', this.metamodel);
                                } else {
                                    console.error('Metamodel received does not have the expected structure');
                                }
                            })
                            .catch(error => console.error('Error loading metamodel:', error));
                    },
                    openModal(block) {
                        console.log("Línea clicada:", block);
                        this.currentBlockId = block.id; // Asegúrate de tener currentBlockId definido en tu data()
                        this.selectedBlockContent = block.content;
                        // Busca el índice de la línea basándose en el ID único
                        this.selectedBlockIndex = this.model.findIndex(item => item.id === block.id);
                        this.isModalOpen = true;
                        console.log("Modal abierta con contenido:", this.selectedBlockContent, "ID:", block.id);
                        this.$nextTick(() => {
                            // Asegúrate de que el contenedor del editor esté disponible en el DOM
                            this.initEditor();
                        });
                        console.log("currentBlockId:", this.currentBlockId);
                    },
                    initEditor() {
                        if (this.editor) {
                            this.editor.destroy(); // Destruye la instancia anterior del editor
                        }
                        this.editor = new toastui.Editor({
                            el: document.querySelector('#editor-container'),
                            initialEditType: 'markdown',
                            previewStyle: 'tab',
                            height: '340px',
                            width: '500px',
                            hideModeSwitch: true,
                            initialValue: this.selectedBlockContent // Asume que `editingContent` es tu contenido actual que quieres editar
                        });
                    },
                    saveChanges() {
                        const editedContent = this.editor.getMarkdown();
                        if (this.selectedBlockIndex !== null) {
                            // Primero, procesa el contenido editado para obtener las tags y el contenido procesado
                            const { tags, tagsParsed } = this.processTags(editedContent);
                            // Asume que parseMDToHTML es una función que deseas usar aquí
                            const blockContentWithTagsParsed = this.parseMDToHTML(editedContent);
                            const blockTitle = this.extractBlockTitle(editedContent);

                            // Luego, actualiza el bloque seleccionado con el nuevo contenido y metadatos
                            this.model.splice(this.selectedBlockIndex, 1, {
                                ...this.model[this.selectedBlockIndex],
                                content: editedContent,
                                tags: tags,
                                tagsParsed: tagsParsed,
                                blockTitle: blockTitle,
                                // Usa el contenido procesado para establecer parsedContent
                                parsedContent: marked.parse(blockContentWithTagsParsed)
                            });
                        }
                        this.updateModelMarkdown();
                        this.closeModal();
                        // Después de guardar, verifica si autoDownload está habilitado
                        if (this.autoDownloadEnabled) {
                            this.downloadMarkdown(); // Asume que este es tu método de descarga existente
                        }
                    },
                    closeModal() {
                        this.isModalOpen = false;
                    },
                    updateBlock(index, newContent) {
                        const tags = newContent.match(/#[^\s]+/g) || [];
                        const tagsParsed = tags.map(tag => `<span class="${tag.substring(1)}">${tag.substring(1)}</span>`).join('');
                        const parsedContent = this.parseContent(newContent); // Asume la existencia de esta función
                        Vue.set(this.model, index, {
                            ...this.model[index],
                            content: newContent,
                            parsedContent: parsedContent,
                            tags: tags.map(tag => tag.substring(1)),
                            tagsParsed: tagsParsed
                        });
                    },
                    openRemoteModal(block) {
                        this.selectedInfoBlock = block;
                        console.log(block);
                        console.log(this.isInfoModalOpen);
                        console.log("Línea clicada:", block);
                        this.currentBlockId = block.id; // Asegúrate de tener currentBlockId definido en tu data()
                        this.currentBlockInfoURL = 'https://xbokmd.github.io/plastilinn/raw.html#/docs/xBoK/sections/' + block.replace(/ /g, "_") + '';
                        console.log(this.currentBlockInfoURL);
                        console.log("URL:", this.currentBlockInfoURL);
                        // Busca el índice de la línea basándose en el ID único
                        this.selectedBlockIndex = this.model.findIndex(item => item.id === block.id);
                        this.isInfoModalOpen = true;
                        console.log("Modal abierta con contenido:", this.currentBlockInfoURL, "ID:", block.id);
                        this.$nextTick(() => {
                            // Asegúrate de que el contenedor del editor esté disponible en el DOM
                            this.currentBlockInfoURL;
                        });
                        console.log("currentBlockId:", this.currentBlockId);

                        // Definir dimensiones y posición de la ventana
                        const ancho = 900; // Ancho de la ventana
                        const alto = 600; // Alto de la ventana
                        // Calcular posición central
                        const y = window.top.outerHeight / 2 + window.top.screenY - (alto / 2);
                        const x = window.top.outerWidth / 2 + window.top.screenX - (ancho / 2);

                        // Abrir nueva ventana
                        window.open(this.currentBlockInfoURL, 'Modal', `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, copyhistory=no, width=${ancho}, height=${alto}, top=${y}, left=${x}`);
                    },
                    downloadMarkdown() {
                        // Asume que modelMarkdown y modelName ya están actualizados
                        const markdownContent = this.modelMarkdown; // Obtiene el valor actual de modelMarkdown
                        const modelName = this.modelName; // Obtiene el nombre actual del modelo
                        const timestamp = new Date().toISOString().replace(/[:\-]|\.\d{3}/g, ''); // Genera un timestamp en el formato deseado

                        const fileName = `${modelName} - saved ${timestamp}.md`; // Construye el nombre del archivo

                        // Crea un Blob con el contenido Markdown
                        const blob = new Blob([markdownContent], { type: 'text/markdown' });

                        // Crea un enlace para descargar el archivo
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = fileName;

                        // Simula un clic en el enlace para iniciar la descarga y luego limpia
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    },
                    downloadHTML() {
                        // Convierte el Markdown a HTML
                        const htmlContent = marked.parse(this.modelMarkdown);

                        // Opcional: Si quieres incluir un estilo básico en tu HTML exportado, puedes agregarlo aquí
                        const htmlWithStyle = `${htmlContent}`;

                        // Crea un Blob con el contenido HTML
                        const blob = new Blob([htmlWithStyle], { type: 'text/html' });

                        // Crea un enlace para descargar el archivo
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = "exported-content.html"; // Puedes personalizar el nombre del archivo

                        // Simula un clic en el enlace para iniciar la descarga y luego limpia
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    },
                    toggleAutoDownload() {
                        this.autoDownloadEnabled = !this.autoDownloadEnabled;
                    },
                    generateSuggestionPrompt() {
                        console.log("currentBlockId:", this.currentBlockId);
                        console.log("model:", this.model); // Ahora imprime el arreglo model para verificar
                        let suggestionPrompt = '';
                        let block = this.model.find(b => b.id === this.currentBlockId); // Cambia this.blocks por this.model
                        console.log("block: ", block);
                        let blockTitle = block ? block.blockTitle : 'Título no encontrado';
                        console.log("blockTitle: ", blockTitle);
                        let modelMarkdown = this.modelMarkdown;
                        let blockExample = block ? block.metamodel.example : 'Example no encontrado';
                        console.log("blockExample: ", blockExample);
                        suggestionPrompt = `As a business model design expert for startups, you specialize in refining business models through detailed, specific feedback and brainstorming tailored to each startup's unique aspects. Your role is to assist in drafting a document that accurately describes a business model, focusing on clear, structured, and relevant advice. Your approach involves:
                    Listening closely to understand the specifics of the business.
                    Providing concise, targeted guidance without unnecessary repetition or formalities.
                    Offering step-by-step feedback to ensure the document effectively captures the business model.
                    You focus on the client's needs and how to best articulate their business model.
                    GOAL: Write a business model document describing the user's project business model. Here's some information about my Business:\n` +

                            `${modelMarkdown}\n` +

                            `MY QUESTION: Please suggest content for the "${blockTitle}" section of the business model.
                    WRITE your answer in PLASTILINN FORMAT, which consists of the text of the answer without any comments or similar, that closely adheres to the format and style of the plastilinn (taking the {block example} as a reference example of a properly formatted answer). In your response, each list component should begin with '#tag', followed by the name enclosed in double brackets '[[ ]]', and then a description on a new, indented line. This is an example of an answer:
                    ---
                    ${blockExample}
                    ---
                    Copy answer in the text box below:
                    ---
                    \`\`\`
                    ${blockExample}
                    \`\`\`
                    ---
                    - You can copy/paste this answer to your plastilinn doc`;

                        return suggestionPrompt;
                    },
                    sendMessageToBot() {
                        console.log(this.currentBlockId);
                        let suggestionPrompt = this.generateSuggestionPrompt();
                        console.log(suggestionPrompt);
                        window.botpressWebChat.mergeConfig({ className: 'plastilinnChatBot', showCloseButton: true })
                        window.botpressWebChat.sendEvent({ type: 'show' })
                        window.botpressWebChat.sendPayload({
                            type: 'text',
                            text: suggestionPrompt
                        });
                    },
                    highlightOnLoad() {
                        this.$nextTick(() => {
                            if (window.location.hash) {
                                const hash = decodeURIComponent(window.location.hash.substring(1)); // Decodifica el hash.
                                this.highlightBlock(hash);
                            }
                        });
                    },
                    highlightBlock(id) {
                        const element = document.getElementById(id);
                        if (element) {
                            element.classList.add('highlight');
                            setTimeout(() => element.classList.remove('highlight'), 3000);
                        }
                    },
                },
                mounted() {
                    this.downloadJSON(); // Otras inicializaciones pueden ir aquí
                    this.updateBlockTitles(); // Actualiza el arreglo blockTitles al cargar la página
                    this.highlightOnLoad(); // Resalta el elemento si la página se cargó con un hash.
                    window.addEventListener('hashchange', this.highlightOnLoad);
                    window.botpressWebChat.onEvent(event => {
                        if (event.type === 'message' && event.message_type === 'text') {
                            alert(`Respuesta del bot: ${event.text}`);
                        }
                    });
                    // Configura marked.js para este componente
                    marked.setOptions({
                        gfm: true, // Habilita GitHub Flavored Markdown (GFM)
                        breaks: true, // Convierte los saltos de línea simples en <br>
                    });
                },
            })
                .mount('#vue-app');
        </script>
        <script src="https://cdn.botpress.cloud/webchat/v1/inject.js"></script>
        <script src="https://mediafiles.botpress.cloud/2aa639ac-f805-454c-b5da-6fcc527f8d70/webchat/config.js"
            defer></script>
</body>

</html>