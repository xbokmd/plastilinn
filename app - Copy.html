<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web App</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>

<body class="bg-gray-100">

    <nav class="bg-white shadow-md py-4 px-8 flex justify-between items-center">
        <h1 class="text-xl font-semibold text-gray-800">Your App Name</h1>
        <div class="flex space-x-4">
            <a href="#" class="hover:text-blue-500">Home</a>
            <a href="#" class="hover:text-blue-500">Features</a>
            <a href="#" class="hover:text-blue-500">Contact</a>
        </div>
    </nav>

    <main class="container mx-auto mt-8">
        <div class="flex justify-between items-center mb-6">
            <div class="flex items-center space-x-3">
                <input type="file" id="markdownFileInput" accept=".md">
            </div>
            <div class="flex space-x-3">
                <select
                    class="form-select bg-white border border-gray-300 rounded-md shadow-sm px-3 py-2 focus:outline-none focus:ring focus:ring-blue-200"
                    id="tagsFilter" multiple onchange="filterLinesBySelectedTags()">
                </select>
                <button class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md transition"
                    onclick="extractTags()">Refresh filter</button>
                <button id="downloadBtn"
                    class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md transition btn btn-primary">Download</button>
            </div>
        </div>

        <div id="md-lines" class="md-lines">
            <div id="md-line" class="md-line grid grid-cols-1 md:grid-cols-5 gap-6">
                <div class="md-line-left p-4 md:col-span-1">
                    Line 1 Section 1
                </div>
                <div class="md-line-content bg-white shadow-md p-4 md:col-span-3">
                    Line 1 Section 2
                </div>
                <div class="md-line-right p-4 md:col-span-1">
                    Line 1 Section 3
                </div>
            </div>
        </div>
        <div id="sectionsContainer"></div>

    </main>

    <!-- script model -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const markdownInput = document.getElementById('markdownFileInput');
            const markdownLinesDiv = document.getElementById('md-lines');
            const JSON_URL = 'https://xbokmd.github.io/plastilinn/metamodel.json';
            let sections = [];
            let allTags = new Set();

            async function displaySectionInfo(sectionName) {
                try {
                    const response = await axios.get(JSON_URL);
                    const section = response.data.sections.find(s => s.name === sectionName);
                    if (section) {
                        let message = '';
                        for (const [key, value] of Object.entries(section)) {
                            message += `${key}: ${value}\n`; // Agrega cada par clave-valor al mensaje
                        }
                        return message; // Retorna el mensaje construido
                    } else {
                        return 'Section not found'; // Retorna este mensaje si la secci칩n no se encuentra
                    }
                } catch (error) {
                    console.error('Error fetching the section info:', error);
                    return 'Failed to load section information'; // Retorna este mensaje en caso de error
                }
            }

            axios.get(JSON_URL)
                .then(async function (response) { // Hace que la funci칩n sea async para usar await dentro
                    // Manejo del 칠xito
                    const sections = response.data.sections;
                    // No es necesario llamar a generateSectionLinks aqu칤 si ya est치s procesando las secciones
                    const sectionsContainer = document.getElementById('sectionsContainer');
                    sectionsContainer.innerHTML = ''; // Limpia el contenedor

                    for (const section of sections) {
                        const sectionInfo = await displaySectionInfo(section.name); // Espera por la informaci칩n de la secci칩n
                        const sectionDiv = document.createElement('div');
                        sectionDiv.classList.add('section');
                        sectionDiv.innerHTML = `
                            <h3>${section.name}</h3>
                            <p>${section.description}</p>
                            <pre>${sectionInfo}</pre> <!-- Muestra la informaci칩n adicional aqu칤 -->
                        `;
                        sectionsContainer.appendChild(sectionDiv);
                    }
                })
                .catch(function (error) {
                    console.error('Error al cargar los nombres de las secciones:', error);
                });

            markdownInput.addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    const content = e.target.result;
                    const lines = content.split(/\r?\n/);
                    markdownLinesDiv.innerHTML = '';

                    markdownLinesDiv.style.gap = '10px';

                    lines.forEach((line, index) => {
                        const result = processModelTitle(line, index);
                        // Extrae las etiquetas de la l칤nea actual
                        // Al extraer etiquetas del texto de la l칤nea
                        const tags = (line.match(/#[^\s]+(?=\s|$)/g) || []).map(tag => tag.substring(1));

                        const rowDiv = document.createElement('div');
                        rowDiv.classList.add('md-line');
                        rowDiv.style.display = 'flex';
                        rowDiv.style.background = '#f2f2f2'; // Aqu칤 aplicas el fondo gris claro a cada l칤nea
                        rowDiv.style.padding = '10px'; // Opcional, a침ade un poco de padding para mejor visualizaci칩n
                        rowDiv.style.marginBottom = '5px'; // Opcional, a침ade un margen inferior para separar las l칤neas


                        const titleDiv = createTitleDiv(result.title, result.isSection);
                        const tagsDiv = createTagsDiv(tags); // Usa las etiquetas extra칤das para crear el div de etiquetas
                        const lineTextarea = createLineTextarea(line, index, result, titleDiv, tagsDiv);

                        rowDiv.appendChild(titleDiv);
                        rowDiv.appendChild(lineTextarea);
                        rowDiv.appendChild(tagsDiv); // A침ade el div de etiquetas al contenedor
                        markdownLinesDiv.appendChild(rowDiv);
                        // A침ade las etiquetas al conjunto de todas las etiquetas sin intentar redefinir 'tags'
                        tags.forEach(tag => allTags.add(tag));
                    });
                };

                reader.readAsText(file);
            });

            function processModelTitle(line, index) {
                let title = line.replace(/^[\s-]*/, '')
                    .replace(/#\S+/g, '')
                    .replace(/#+/g, '')
                    .replace(/\[\[/g, '')
                    .replace(/\]\]/g, '')
                    .trim();
                let matchingSection = sections.find(section => section.name === title);
                let isSection = matchingSection ? "Yes" : "No";
                let modalId = `sectionModal-${index}`;

                if (isSection === "Yes") {
                    return {
                        title,
                        isSection: `<a href="#" data-bs-toggle="modal" data-bs-target="#${modalId}">Section</a>`,
                        modalId,
                        sectionData: matchingSection
                    };
                } else {
                    return { title, isSection, modalId: null, sectionData: null };
                }
            }

            function createTitleDiv(title, isSection) {
                const div = document.createElement('div');
                if (isSection.includes("Section")) {
                    const sectionInfo = displaySectionInfo(title);
                    div.innerHTML = `游 ${isSection}</br><b>${title}</b><a href="#" onclick="createModal(${sectionInfo})">info</a> <a href="#" onclick="getSectionPrompt()">Open Popup</a>`;displaySectionInfo
                    div.style.background = 'lightblue';
                    div.style.color = 'white';
                } else {
                    div.innerHTML = `游늯text`;
                }
                div.style.width = '30%';
                return div;
            }

            function getSectionPrompt() {
                // Function to generate content for the popup
                alert("XXX");
            }

            function createLineTextarea(line, index, result, titleDiv, tagsDiv) {
                const outerContainer = document.createElement('div'); // Contenedor exterior para manejar el ancho del 60%
                outerContainer.style.flex = '1'; // Permite que el contenedor crezca para ocupar el espacio
                outerContainer.style.flexBasis = '60%'; // Establece la base del tama침o en el 60%

                // Crea un div para mostrar el contenido Markdown parseado
                const displayDiv = document.createElement('div');
                displayDiv.innerHTML = marked.parse(line); // Parsea el Markdown a HTML
                displayDiv.style.width = '100%'; // Ajusta el ancho al 100% del contenedor exterior
                displayDiv.classList.add('markdown-display');

                // Crea un textarea para la edici칩n del Markdown, inicialmente oculto
                const textarea = document.createElement('textarea');
                textarea.value = line;
                textarea.style.width = '100%'; // Ajusta el ancho al 100% del contenedor exterior
                textarea.style.resize = 'none';
                textarea.style.display = 'none'; // Oculta el textarea inicialmente
                textarea.classList.add('textarea-editable'); // Aplica la clase para los estilos editables
                // Evento para cambiar a edici칩n al hacer clic en el div
                displayDiv.addEventListener('click', function () {
                    displayDiv.style.display = 'none'; // Oculta el div
                    textarea.style.display = ''; // Muestra el textarea
                    textarea.focus(); // Enfoca el textarea para edici칩n inmediata

                });

                // Evento para actualizar el div con el contenido del textarea al desenfocar
                textarea.addEventListener('blur', function () {
                    displayDiv.innerHTML = marked.parse(textarea.value); // Actualiza el div con el nuevo contenido Markdown parseado
                    textarea.style.display = 'none'; // Oculta el textarea
                    displayDiv.style.display = ''; // Muestra el div

                });

                // Evento para actualizar el t칤tulo y las etiquetas al modificar el contenido
                textarea.addEventListener('input', function () {
                    const update = processModelTitle(this.value, index);
                    titleDiv.innerHTML = `游 ${update.isSection}</br><b>${update.title}</b>`;
                    const updatedTags = (this.value.match(/#[^\s]+(?=\s|$)/g) || []).map(tag => tag.substring(1));
                    updateTagsDiv(updatedTags, tagsDiv);
                });

                // A침ade el displayDiv y el textarea al contenedor exterior
                outerContainer.appendChild(displayDiv);
                outerContainer.appendChild(textarea);

                return outerContainer; // Retorna el contenedor exterior
            }

            // Funci칩n para analizar las etiquetas en el contenido de un textarea
            function parseTagsFromTextarea(content) {
                // Usa una expresi칩n regular para encontrar las etiquetas. Asume que las etiquetas son palabras que comienzan con '#'
                const tagPattern = /#[^\s#]+/g;
                const tags = content.match(tagPattern) || [];
                return tags.map(tag => tag.substring(1)); // Elimina el s칤mbolo '#' de cada etiqueta
            }

            function createTagsDiv(tags) {
                const div = document.createElement('div');
                div.className = 'tags-container'; // Asigna la clase .tags-container al div
                div.style.width = '10%';
                // Crea un span para cada etiqueta
                div.innerHTML = tags.map(tag => `<span class="${tag}">${tag}</span>`).join('');
                return div;
            }

            function updateTagsDiv(updatedTags, tagsDiv) {
                tagsDiv.innerHTML = updatedTags.map(tag => `<span class="${tag}">${tag}</span>`).join('');
            }

            function createModal(section) {
                if (!section || typeof section.name === 'undefined') {
                        console.error('Invalid section or section.name is undefined', section);
                        return; // Sale de la funci칩n si no se cumplen las condiciones
                    }
                    const modalId = `modal-${section.name.replace(/\s+/g, '-')}`;
                if (section && section.name) {
                const modalId = `modal-${section.name.replace(/\s+/g, '-')}`; // Crear un ID 칰nico para cada modal
                }
                console.log('Section:', section);
                console.log('Section Name:', section.name);
                // Verifica si el modal ya existe para evitar duplicados
                if (!document.getElementById(modalId)) {
                    const modalHTML = `
                    <div class="modal fade fixed top-0 left-0 hidden h-full w-full outline-none overflow-x-hidden overflow-y-auto"
                        id="${modalId}" tabindex="-1" aria-labelledby="${modalId}Label" aria-hidden="true">
                        <div class="modal-dialog modal-dialog-centered relative w-auto pointer-events-none">
                        <div class="modal-content border-none shadow-lg relative flex flex-col w-full pointer-events-auto bg-white bg-clip-padding rounded-md outline-none text-current">
                            <div class="modal-header flex flex-shrink-0 items-center justify-between p-4 border-b border-gray-200 rounded-t-md">
                            <h5 class="text-xl font-medium leading-normal text-gray-800" id="${modalId}Label">
                                ${section.name}
                            </h5>
                            <button type="button"
                                    class="btn-close text-black bg-transparent hover:bg-gray-200 hover:text-black rounded-lg text-sm p-1.5 ml-auto inline-flex items-center"
                                    data-dismiss="modal" aria-label="Close" onclick="document.getElementById('${modalId}').classList.add('hidden');">
                                <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                            </button>
                            </div>
                            <div class="modal-body relative p-4">
                            ${Object.entries(section).map(([key, value]) => `<p><strong>${key}:</strong> ${value}</p>`).join('')}
                            </div>
                        </div>
                        </div>
                    </div>
                    `;

                    // A침adir el modal al contenedor
                    const container = document.getElementById('modalContainer');
                    container.insertAdjacentHTML('beforeend', modalHTML);
                }

                // Mostrar el modal
                document.getElementById(modalId).classList.remove('hidden');
            }

            function generateSectionLinks(sections) {
                const linksContainer = document.getElementById('sectionsContainer');
                linksContainer.innerHTML = ''; // Limpiar el contenedor

                sections.forEach(section => {
                    const link = document.createElement('a');
                    link.href = '#';
                    link.textContent = section.name;
                    link.className = 'block p-2 text-blue-500 hover:text-blue-700 cursor-pointer'; // Estilos de TailwindCSS
                    link.addEventListener('click', (e) => {
                        e.preventDefault(); // Prevenir el comportamiento predeterminado
                        createModal(section); // Llamar a la funci칩n de modal
                    });

                    linksContainer.appendChild(link);
                });
            }

            document.addEventListener('DOMContentLoaded', function () {
                const markdownInput = document.getElementById('markdownFileInput');
                const markdownContent = document.getElementById('markdownContent');

                document.getElementById('downloadBtn').addEventListener('click', downloadModel);

                function downloadModel() {
                    const textareas = document.querySelectorAll('textarea');
                    let fileContent = '';
                    textareas.forEach(textarea => {
                        fileContent += textarea.value + '\n'; // A침ade un salto de l칤nea despu칠s de cada 치rea de texto
                    });

                    const fileName = `Business model ${formatDate(new Date())}.md`;
                    downloadFile(fileName, fileContent);
                }

                function formatDate(date) {
                    const year = date.getFullYear();
                    const month = (`0${date.getMonth() + 1}`).slice(-2);
                    const day = (`0${date.getDate()}`).slice(-2);
                    const hours = (`0${date.getHours()}`).slice(-2);
                    const minutes = (`0${date.getMinutes()}`).slice(-2);
                    const seconds = (`0${date.getSeconds()}`).slice(-2);
                    return `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
                }

                function downloadFile(fileName, content) {
                    const element = document.createElement('a');
                    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
                    element.setAttribute('download', fileName);

                    element.style.display = 'none';
                    document.body.appendChild(element);

                    element.click();

                    document.body.removeChild(element);
                }


                function downloadAndRefresh(file) {
                    // Crea una URL temporal para la descarga
                    const url = URL.createObjectURL(file);

                    // Crea un elemento `a` para la descarga
                    const downloadLink = document.createElement('a');
                    downloadLink.href = url;
                    downloadLink.download = file.name;
                    downloadLink.click();

                    // Simula la selecci칩n del archivo descargado
                    const hiddenFileInput = document.createElement('input');
                    hiddenFileInput.type = 'file';
                    hiddenFileInput.multiple = false;
                    hiddenFileInput.files = [file];

                    hiddenFileInput.addEventListener('change', () => {
                        // Recarga la p치gina para actualizar el contenido
                        location.reload();
                    });

                    // Oculta el elemento input
                    hiddenFileInput.style.display = 'none';
                    document.body.appendChild(hiddenFileInput);
                }

                // Funci칩n auxiliar para extraer etiquetas de un div
                function extractTagsFromDiv(div) {
                    const tagSpans = div.querySelectorAll('.tags-container span');
                    const tags = [];
                    tagSpans.forEach(span => tags.push(span.textContent));
                    return tags;
                }

                console.log(allTags)
                // Actualiza el dropdown con las etiquetas encontradas
                function updateTagsDropdown() {
                    const tagsFilter = document.getElementById('tagsFilter');
                    tagsFilter.innerHTML = ''; // Limpia el dropdown

                    // 1. Convierte el Set en un Array apto para ordenar
                    const tagsArray = Array.from(allTags);

                    // 2. Ordena el array alfab칠ticamente 
                    tagsArray.sort((a, b) => a.localeCompare(b));
                    console.log(tagsArray)
                    // 3. Crea las opciones ya con el Array ordenado
                    tagsArray.forEach(tag => {
                        const option = document.createElement('option');
                        option.value = tag;
                        option.textContent = tag;
                        tagsFilter.appendChild(option);
                    });
                }
            });

            const etiquetasEncontradas = new Set(); // Variable global a todo el script

            function extractTags() {
                const textareas = document.querySelectorAll('.textarea-editable');

                // Recorremos cada uno de los textareas
                textareas.forEach(textarea => {
                    // Obtenemos su contenido
                    const text = textarea.value;

                    // Expresi칩n regular para encontrar etiquetas
                    const regex = /\#\S+/g;
                    let matches;

                    // Buscamos coincidencias para la expresi칩n regular 
                    while ((matches = regex.exec(text)) !== null) {
                        // Agregamos la etiqueta al Set
                        etiquetasEncontradas.add(matches[0]);
                    }
                });

                // Mostramos la lista de etiquetas en el select
                const select = document.getElementById('tagsFilter');
                select.innerHTML = ''; // Limpiamos el select antes de agregar nuevas opciones

                // Convertir el Set de etiquetas a un array y ordenarlo alfab칠ticamente
                const etiquetasOrdenadas = Array.from(etiquetasEncontradas).sort();

                // Agregar las opciones ordenadas al selector
                etiquetasOrdenadas.forEach(etiqueta => {
                    const option = document.createElement('option');
                    option.value = etiqueta;
                    option.textContent = etiqueta;
                    select.appendChild(option);
                });
            }

            function filterLinesBySelectedTags() {
                const selectedTags = Array.from(tagsFilter.selectedOptions).map(option => option.value);
                document.querySelectorAll('.md-line').forEach(line => {
                    const lineTags = line.querySelector('textarea').value.match(/\B#\S+/g) || [];
                    line.style.display = selectedTags.some(tag => lineTags.includes(tag)) ? 'block' : 'none';
                });
            }

            // Aseg칰rate de ejecutar extractTags() en alg칰n momento para actualizar "etiquetasEncontradas"
            tagsFilter.addEventListener('change', filterLinesBySelectedTags);

            const reader = new FileReader();
            // Este fragmento es parte del evento 'change' del input de archivos Markdown
            reader.onload = function (e) {
                const content = e.target.result;
                const lines = content.split(/\r?\n/); // Divide el contenido en l칤neas
                allTags.clear(); // Limpia el conjunto de etiquetas para la nueva selecci칩n de archivo

                lines.forEach((line, index) => {
                    // Cambia la expresi칩n regular para capturar sin incluir '#'
                    const tags = line.match(/(?<=\s)#([^\s#]+)/g) || []; // Busca etiquetas en la l칤nea actual
                    tags.forEach(tag => {
                        // A침ade solo el texto de la etiqueta, sin el '#', al conjunto de todas las etiquetas
                        allTags.add(tag.substring(1)); // Elimina el s칤mbolo '#' antes de a침adir
                    });
                });
            };
        })
    </script>

</body>

</html>