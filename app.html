<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web App</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <style>
        .hidden {
            display: none;
        }

        #model-title {
            padding-top: 40px;
            /* Ajusta este valor según la altura de tus elementos fijos */
        }

        .flex.space-x-3 {
            display: flex;
            justify-content: center;
        }

        .md-line-content {
    width: 100%; /* Hace que el textarea ocupe el 100% del ancho de su contenedor */
    min-height: 2em; /* Establece la altura mínima para mostrar dos líneas de texto */
    box-sizing: border-box; /* Asegura que el padding y border se incluyan en la altura y anchura total */
    resize: vertical; /* Permite al usuario redimensionar el textarea solo verticalmente */
}

.ai-magic-button {
    display: block; /* Hace que el botón ocupe su propia línea */
    width: auto; /* O cualquier ancho específico que desees */
    min-height: 1em !important;
    height: 1.5em;
    margin: 0px auto; /* Añade margen arriba y abajo y centra horizontalmente */
}

.btn-primary {
    transition: background-color 0.3s ease, transform 0.2s ease;
}

.btn-primary:hover {
    background-color: #2563eb; /* Un azul más brillante */
    transform: translateY(-2px); /* Efecto de levitación ligera */
}

/* Mejoras en Inputs */
.input, .select {
    transition: border-color 0.3s ease;
    border-radius: 0.5rem;
}

.input:focus, .select:focus {
    border-color: #4f46e5; /* Cambia el color del borde al enfocar */
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.5); /* Sombra suave alrededor */
}
    </style>

</head>

<body class="bg-gray-100">
    <div id="top-container">
        <div class="navbar bg-base-100">
            <div class="flex-1">
                <a class="btn btn-ghost text-xl">Plastilinn</a>
            </div>
            <div class="flex items-center space-x-3">
            </div>
            <div style="display: flex; justify-content: center;">
                <div class="flex space-x-3">
                    <div class="grid grid-cols-3 gap-4">
                        <div class="flex items-center space-x-3" style="justify-content: flex-end;">
                            <input type="file" id="markdownFileInput" accept=".md"
                                class="file-input file-input-bordered file-input-primary w-full max-w-xs">
                        </div>
                        <div class="flex space-x-3" style="justify-content: center;">
                            <button class="collapse-filter-button btn btn-primary bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md transition" type="button">
                                🔍 Filter
                            </button>
                        </div>
                        <div class="flex items-center justify-end space-x-3" style="justify-content: flex-start;">
                            <button id="downloadBtn"
                                class="btn btn-primary bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md transition">⬇️ Download</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="flex-none">
                <ul class="menu menu-horizontal px-1">
                    <li><a>App</a></li>
                    <li><a>Docs</a></li>
                    <li><a>About</a></li>
                </ul>
            </div>
        </div>
    </div>
    <div id="model-title" class="text-center mt-6">
        <!-- El nombre del modelo se mostrará aquí -->
    </div>
    <div class="mt-4 w-4/5 mx-auto">
        <div class="collapse-filter-content hidden ">
            <select class="select select-bordered w-full" id="tagsFilter" multiple>
                <!-- Opciones del filtro serán generadas dinámicamente -->
            </select>
        </div>
    </div>
    <div id="markdownContainer" class="mt-4 text-gray-900 min-h-screen">
        <div class="hero min-h-screen bg-base-200">
            <div class="hero-content text-center">
                <div class="max-w-md card bg-white shadow-xl hover:shadow-2xl transition-shadow">
                    <div class="card-body">
                        <h1 class="text-5xl font-bold">Your business plan powered by Artificial Intelligence</h1>
                        <p class="py-6">Plastilinn offers guidance on completing your business model...</p>
                        <div class="card-actions justify-center">
                            <button class="btn btn-primary">Get Started</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="hero min-h-screen bg-base-200">
            <div class="hero-content text-center">
                <div class="max-w-md">
                    <h1 class="text-5xl font-bold">Your business plan powered by Artificial Intelligence</h1>
                    <p class="py-6">Plastilinn offers guidance on completing your business model, including aspects
                        such
                        as market analysis, marketing strategies, financial planning, organizational structure,
                        understanding market trends, analyzing customer demographics, and evaluating competitor
                        behavior. It can help you make informed choices by evaluating different strategic options,
                        and
                        provides continuous support and instant feedback, crucial for iterative business development
                        and
                        improvement.</p>
                    <ul class="steps">
                        <li class="step step-primary">Design your Business Model</li>
                        <li class="step">Analyze your Business Model</li>
                        <li class="step">Validate your Business Model</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>


    <script>
        let metamodel = [];
        let model = []; // También aseguramos que `model` esté definido globalmente
        
        let uniqueId = 0; // Al inicio de tu script o fuera de cualquier función para que sea global
        let modelName = ''; // Esta variable almacenará el nombre del archivo cargado
        function downloadJSON() {
            axios.get('https://xbokmd.github.io/plastilinn/metamodel.json')
                .then(function (response) {
                    metamodel = response.data;
                    console.log(metamodel); // Opcional: Mostrar los datos en la consola
                })
                .catch(function (error) {
                    console.log(error); // Manejar el error
                });
        }

        downloadJSON();

        function setupMarkdownFileInput() {
            const markdownFileInput = document.getElementById('markdownFileInput');
            const markdownContainer = document.getElementById('markdownContainer');

            markdownFileInput.addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    // Extrae el nombre del archivo sin la extensión '.md'
                    let baseName = file.name.replace('.md', '');

                    // Busca la posición de " - saved" en el nombre del archivo
                    let savedIndex = baseName.indexOf(' - saved');

                    // Si " - saved" se encuentra en el nombre, recorta hasta ese punto
                    if (savedIndex !== -1) {
                        baseName = baseName.substring(0, savedIndex);
                    }

                    modelName = baseName; // Asigna el nombre modificado a modelName
                    updateModelNameDisplay(); // Actualiza la visualización del nombre
                    const content = e.target.result;
                    const lines = content.split(/\r?\n/);
                    model = _.map(lines, (line, index) => {
                        // Extracción de etiquetas
                        const rawTags = line.match(/#[^\s#]+/g) || [];
                        const tags = rawTags.map(tag => {
                            const tagName = tag.substring(1); // Simplemente elimina el símbolo '#' al principio
                            return { raw: tag, className: tagName };
                        });

                        // Intentar identificar y procesar títulos con nueva especificación
                        let title = undefined;
                        // La expresión regular ahora permite espacios/guiones al inicio y busca de 2 a 10 hashes
                        const headingMatch = line.match(/^\s*-*\s*#{2,10}\s*(.*)/);
                        if (headingMatch && headingMatch[1]) {
                            // Limpiar el título: elimina hashes y espacios iniciales, mantiene texto después de los hashes
                            title = headingMatch[1].trim();
                            // Eliminar etiquetas del título si es necesario
                            title = title.replace(/#[^\s#]+/g, '').trim();
                            title = title.replace(/\[\[|\]\]/g, '');
                        }

                        return {
                            id: uniqueId++, // Incrementa el ID único para cada objeto del modelo
                            content: line,
                            tags: tags,
                            index: index,
                            title: title // Agregado condicionalmente, undefined si no es un título
                        };
                    });

                    // Luego de definir tu modelo, actualiza las etiquetas de cada línea
                    model.forEach(lineData => {
                        // Encuentra el tagsContainer correspondiente para esta línea
                        // Esto puede requerir que ajustes cómo identificas o accedes a cada tagsContainer
                        // Por ejemplo, si cada línea tiene un ID único y puedes usarlo para encontrar su tagsContainer
                        const tagsContainer = document.querySelector(`#tags-container-${lineData.id}`);
                        if (tagsContainer) {
                            const cleanedTags = lineData.tags.map(tag => tag.className); // Asume que ya has limpiado las etiquetas
                            updateTagsContainer(tagsContainer, cleanedTags);
                        }
                    });

                    updateTagsFilter();
                    renderModel(); // Asegúrate de ajustar esta función para manejar "title"
                };
                reader.readAsText(file);
            });

            document.querySelector('.collapse-filter-button').addEventListener('click', function() {
                const content = document.querySelector('.collapse-filter-content');
                // Alternar la clase 'hidden' para mostrar/ocultar el contenido
                content.classList.toggle('hidden');
            });

            function renderModel(linesToRender = model) {
                console.log("Líneas a renderizar:", linesToRender); // Esto debería mostrarte las líneas que se van a renderizar
                const markdownContainer = document.getElementById('markdownContainer');
                markdownContainer.innerHTML = ''; // Limpiar el contenedor
                const mainContainer = document.createElement('div');
                mainContainer.className = 'flex flex-col';

                _.forEach(model, (lineData) => {

                    const rowWrapperDiv = document.createElement('div');
                    rowWrapperDiv.classList.add('md-line-wrapper');

                    const lineContainer = document.createElement('div');
                    lineContainer.className = 'flex flex-row md-line';

                    if (lineData.title) {
                        // Creación y configuración del enlace del título (titleLink).
                        const titleLink = document.createElement('a');
                        titleLink.setAttribute('href', `https://go.plastilinn.com/#/page/${lineData.title.replace(/\s+/g, '_')}_info`);
                        titleLink.setAttribute('target', '_blank');
                        titleLink.textContent = lineData.title;
                        titleLink.className = 'text-blue-500 hover:text-blue-800';

                        // Crear un contenedor para el título y el botón.
                        const titleContainer = document.createElement('div');
                        titleContainer.className = 'text-center bg-gray-50 rounded p-2 custom-flex-1 chat chat-bubble chat-end';
                        titleContainer.appendChild(titleLink); // Añadir el enlace al contenedor del título.

                        // Creación del botón modalOpenButton y configuración del evento click.
                        const modalOpenButton = document.createElement('button');
                        modalOpenButton.textContent = '🤖 AI magic';
                        modalOpenButton.className = 'btn ai-magic-button py-1';
                        modalOpenButton.addEventListener('click', function () {
                            openModalWithSectionName(lineData.title);
                        });

                        // Añadir el botón al contenedor del título.
                        titleContainer.appendChild(modalOpenButton);

                        // Añadir el contenedor del título (que ahora incluye el botón) al contenedor de la línea.
                        lineContainer.appendChild(titleContainer);
                    } else {
                        // Manejo de líneas sin título.
                        const noTitleElement = document.createElement('div');
                        noTitleElement.className = 'text-center bg-gray-50 rounded p-2 custom-flex-1';
                        lineContainer.appendChild(noTitleElement);
                    }

                    // Contenedor para el contenido original (editable)
                    const contentContainer = document.createElement('div');
                    contentContainer.className = 'text-center bg-gray-50  shadow-xl hover:shadow-2xl transition-shadow p-2 ml-2 mr-2 custom-flex-2';
                    const textareaElement = document.createElement('textarea');
                    textareaElement.className = 'md-line-content text-left bg-white md:col-span-3';
                    textareaElement.rows = 1; // Establece el número de filas o altura inicial
                    textareaElement.setAttribute('data-id', lineData.id); // Asignar el ID único aquí
                    textareaElement.textContent = lineData.content;
                    contentContainer.appendChild(textareaElement);

                    // Asignación del evento click aquí, dentro del forEach, asegurando que textareaElement está definido
                    textareaElement.addEventListener('click', function () {
                        openModalWithTextareaContent(this.value, this);
                    });

                    textareaElement.addEventListener('input', function () {
                        // Actualizar el modelo con el nuevo contenido
                        const id = this.getAttribute('data-id');
                        const updatedContent = this.value; // Usa 'value' para 'textarea'
                        const lineObj = model.find(obj => obj.id.toString() === id);
                        if (lineObj) {
                            lineObj.content = updatedContent; // Actualiza el contenido en el modelo
                        }

                        // Extrae las etiquetas del contenido actualizado
                        const rawTags = updatedContent.match(/#[^\s#]+/g) || [];
                        const cleanedTags = rawTags.map(tag => tag.substring(1)); // Limpia las etiquetas quitando '#'

                        // Encuentra el contenedor de etiquetas correspondiente
                        // Asegúrate de que tu estructura del DOM permita encontrar correctamente el `tagsContainer`
                        // relacionado con este `textarea`
                        const tagsContainer = this.closest('.md-line').querySelector('.tags-container');
                        if (tagsContainer) {
                            updateTagsContainer(tagsContainer, cleanedTags);
                        }

                        updateTagsFilter();
                    });

                    textareaElement.textContent = lineData.content;
                    contentContainer.appendChild(textareaElement);

                    // Columna para las etiquetas
                    const tagsElement = document.createElement('div');
                    tagsElement.className = 'tags-container ext-gray-500 text-sm text-center bg-gray-50 rounded p-2 custom-flex-3';

                    // Prepara un arreglo de etiquetas limpias basado en lineData.tags
                    const cleanedTags = lineData.tags.map(tag => tag.className);

                    // Llama a updateTagsContainer con el contenedor de etiquetas y el arreglo de etiquetas limpias
                    updateTagsContainer(tagsElement, cleanedTags);

                    // Añadir el contenedor de contenido editable en el medio
                    lineContainer.insertBefore(contentContainer, null); // Asegúrate de que esto esté correctamente insertado

                    lineContainer.appendChild(tagsElement);

                    // Añadir el contenedor de la línea al contenedor principal
                    mainContainer.appendChild(lineContainer);

                    // Asegurarse de envolver correctamente el lineContainer con rowWrapperDiv
                    rowWrapperDiv.appendChild(lineContainer); // Envolver lineContainer dentro de rowWrapperDiv

                    // Añadir el contenedor de la línea (ahora correctamente envuelto) al contenedor principal
                    mainContainer.appendChild(rowWrapperDiv);
                });

                // Añadir el contenedor principal al contenedor de Markdown
                markdownContainer.appendChild(mainContainer);
            }

            function setupEditableContent(contentElement) {
                const editIndicator = document.createElement('span');
                editIndicator.className = 'text-gray-400 text-xl cursor-pointer absolute right-0 mr-4 opacity-0';
                editIndicator.textContent = '✏️';
                contentElement.parentNode.appendChild(editIndicator);

                contentElement.addEventListener('focus', function () {
                    this.classList.add('border', 'border-blue-500', 'rounded', 'p-1');
                });
                contentElement.addEventListener('blur', function () {
                    this.classList.remove('border', 'border-blue-500', 'rounded', 'p-1');
                });
                contentElement.addEventListener('mouseenter', function () {
                    editIndicator.style.opacity = '1';
                });
                contentElement.addEventListener('mouseleave', function () {
                    editIndicator.style.opacity = '0';
                });
            }
            document.getElementById('tagsFilter').addEventListener('change', filterLinesBySelectedTags);

            function updateTagsForLine(tagsContainer, content) {
                // Limpia el contenedor de etiquetas existente
                tagsContainer.innerHTML = '';

                // Extrae las etiquetas del contenido. Este paso depende de cómo identifiques las etiquetas en el texto.
                // Por ejemplo, si las etiquetas son palabras precedidas por '#', podrías hacer algo como esto:
                const tagRegex = /#\w+/g; // Encuentra todas las ocurrencias de '#palabra'
                const tags = content.match(tagRegex) || [];

                // Crea elementos visuales para cada etiqueta encontrada y los añade al contenedor
                tags.forEach(tag => {
                    const tagElement = document.createElement('span'); // O cualquier elemento que represente una etiqueta en tu UI
                    tagElement.textContent = tag; // Establece el texto del elemento al tag encontrado
                    tagsContainer.appendChild(tagElement); // Añade el elemento de etiqueta al contenedor
                });
            }

            function filterLinesBySelectedTags() {
                // Obtener todas las etiquetas seleccionadas del select múltiple
                const selectedTags = Array.from(document.getElementById('tagsFilter').selectedOptions).map(option => option.value);

                // Obtener todos los elementos que representan las líneas de contenido
                const wrappers = document.querySelectorAll('.md-line-wrapper');

                // Iterar sobre cada wrapper
                wrappers.forEach(wrapper => {
                    // Busca dentro del wrapper si existe alguna etiqueta que coincida con las seleccionadas
                    const tagsInLine = wrapper.querySelectorAll('.tags-container span');
                    let tagFound = false;

                    // Verificar si alguna de las etiquetas de la línea coincide con las seleccionadas
                    tagsInLine.forEach(tagElement => {
                        if (selectedTags.includes(tagElement.textContent)) {
                            tagFound = true;
                        }
                    });

                    // Si se encuentra alguna etiqueta o si no se ha seleccionado ninguna (valor ''), muestra el wrapper
                    if (tagFound || selectedTags.length === 0) {
                        wrapper.classList.remove('hidden');
                    } else {
                        // En caso contrario, oculta el wrapper
                        wrapper.classList.add('hidden');
                    }
                });
            }

            document.addEventListener('DOMContentLoaded', function () {

                document.getElementById('tagsFilter').addEventListener('change', filterLinesBySelectedTags);
            });

            document.addEventListener('input', function (e) {
                if (e.target.classList.contains('md-line-content')) {
                    const updatedContent = e.target.value;

                    // Extraer etiquetas usando una expresión regular
                    const rawTags = updatedContent.match(/#[^\s#]+/g) || [];
                    const cleanedTags = rawTags.map(tag => tag.substring(1)); // Limpia las etiquetas quitando '#'

                    // Encuentra el contenedor de etiquetas correspondiente
                    const tagsContainer = e.target.closest('.md-line').querySelector('.tags-container');
                    if (tagsContainer) {
                        updateTagsContainer(tagsContainer, cleanedTags);
                    }
                }
            });

            document.getElementById('downloadBtn').addEventListener('click', downloadModel);

            function formatDate(date) {
                const year = date.getFullYear();
                const month = (`0${date.getMonth() + 1}`).slice(-2);
                const day = (`0${date.getDate()}`).slice(-2);
                const hours = (`0${date.getHours()}`).slice(-2);
                const minutes = (`0${date.getMinutes()}`).slice(-2);
                const seconds = (`0${date.getSeconds()}`).slice(-2);
                return `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
            }

            document.getElementById('downloadBtn').addEventListener('click', function () {
                const modelContent = generateModel(); // Esta función debería generar el contenido a descargar
                // Genera el nombre del archivo usando modelName y la fecha actual para mantenerlo único
                const fileName = `${modelName || 'Business model'} - saved ${formatDate(new Date())}.md`;
                downloadFile(fileName, modelContent); // Llama a la función downloadFile con el nuevo nombre
            });

            function downloadFile(fileName, content) {
                const element = document.createElement('a');
                element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
                element.setAttribute('download', fileName);

                element.style.display = 'none';
                document.body.appendChild(element);

                element.click();

                document.body.removeChild(element);
            }
        }

        function updateModelNameDisplay() {
            let modelNameDisplay = document.getElementById('modelNameDisplay');
            if (!modelNameDisplay) {
                modelNameDisplay = document.createElement('h1');
                modelNameDisplay.id = 'modelNameDisplay';
                // Encuentra el contenedor con id="model-title" para mostrar el nombre del modelo
                const container = document.getElementById('model-title');
                container.appendChild(modelNameDisplay); // Añade el h1 dentro del contenedor específico
            }
            modelNameDisplay.textContent = modelName; // Actualiza el contenido del h1 con el nombre del modelo
        }

        function downloadModel() {
                let fileContent = model.map(obj => obj.content).join('\n'); // Concatena el contenido con saltos de línea
                const fileName = `Business model - saved ${formatDate(new Date())}.md`; // Usa la función formatDate para crear un nombre de archivo único
                downloadFile(fileName, fileContent); // Llama a la función downloadFile con el nombre del archivo y el contenido a descargar
            }

        function setupDownloadButton() {
                const downloadBtn = document.getElementById('downloadBtn');
                if (!downloadBtn) return; // Asegúrate de que el elemento existe

                downloadBtn.addEventListener('click', downloadModel);
            }

        document.addEventListener('input', function (e) {
            if (e.target.getAttribute('contenteditable') === "true") {
                const id = parseInt(e.target.getAttribute('data-id'), 10); // Obtiene el ID como número
                const editedContent = e.target.textContent;

                // Busca y actualiza el objeto correspondiente en `model`
                const lineObj = model.find(obj => obj.id === id);
                if (lineObj) {
                    lineObj.content = editedContent;
                }
            }
        });

        function generateModel() {
            const contentElements = document.querySelectorAll('.md-line-content');
            let modelContent = Array.from(contentElements).map(element => element.value).join('\n\n');
            // La siguiente línea es incorrecta y redundante, por lo que se ha eliminado
            // modelContent += textContent + '\n';
            return modelContent.trim();
        }

        function updateTagsFilter() {
            // Obtener todas las etiquetas únicas de `model`
            const allTags = new Set(); // Usamos un Set para evitar etiquetas duplicadas
            model.forEach(item => {
                item.tags.forEach(tag => {
                    allTags.add(tag.className); // Suponiendo que `className` contiene el nombre de la etiqueta sin '#'
                });
            });

            // Convertir el Set a Array y ordenarlo alfabéticamente
            const sortedTags = Array.from(allTags).sort();

            // Obtener el elemento del selector
            const tagsFilter = document.getElementById('tagsFilter');
            // Limpiar opciones existentes
            tagsFilter.innerHTML = '';

            // Opción predeterminada
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'No filter';
            tagsFilter.appendChild(defaultOption);

            // Crear una opción para cada etiqueta única
            sortedTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagsFilter.appendChild(option);
            });
        }

        function openModalWithTextareaContent(content, textareaElement) {
            const modalContent = document.getElementById('textEditModalContent');
            modalContent.value = content;
            // Guarda una referencia al textarea en una propiedad global o en el mismo modal para usarla al cerrar la modal
            window.currentTextarea = textareaElement; // Guarda el textarea actual como una propiedad global

            // Muestra la ventana modal
            document.getElementById('textEditModal').classList.add('modal-open');
        }

        function closeTextEditModal() {
            const modalContent = document.getElementById('textEditModalContent');
            if (window.currentTextarea) {
                // Aplica el contenido modificado al textarea original
                window.currentTextarea.value = modalContent.value;

                // Extrae las etiquetas del contenido actualizado
                const updatedTags = extractTags(modalContent.value);

                // Encuentra el contenedor de etiquetas relacionado con el textarea
                const tagsContainer = window.currentTextarea.closest('.md-line').querySelector('.tags-container');

                // Actualiza el contenedor de etiquetas utilizando la función existente
                if(tagsContainer) {
                    updateTagsContainer(tagsContainer, updatedTags);
                }
            }
            // Cierra la ventana modal
            document.getElementById('textEditModal').classList.remove('modal-open');
        }

        function extractTags(content) {
            // Utiliza una expresión regular para encontrar todas las coincidencias de etiquetas
            const tagRegex = /#\w+/g;
            const tags = content.match(tagRegex) || [];
            return tags.map(tag => tag.substring(1)); // Elimina el hash del inicio de cada etiqueta
        }

            function closeModal() {
                // Obtiene el textarea del modal y el textarea original
                const modalContent = document.getElementById('generatedModelContent');
                const originalTextarea = document.getElementById('modalTitle').textareaElement;

                // Transfiere el contenido editado de vuelta al textarea original
                if (originalTextarea) {
                    originalTextarea.value = modalContent.value;
                }

                // Cierra la modal
                document.getElementById('modalTitle').classList.remove('modal-open');
            }

            function updateTagsContainer(tagsContainer, tags) {
                // Limpia el contenedor de etiquetas actual
                tagsContainer.innerHTML = '';

                // Añadir las nuevas etiquetas al contenedor
                tags.forEach(tag => {
                    const tagSpan = document.createElement('span');
                    // Asigna el valor de la etiqueta al atributo 'data-tag', asumiendo que 'tag' ya no tiene el '#'
                    tagSpan.setAttribute('data-tag', tag);
                    // Establece el texto visible del span como el valor de la etiqueta
                    tagSpan.textContent = tag;
                    tagsContainer.appendChild(tagSpan);

                    // Añadir un espacio después de cada etiqueta para separación visual
                    tagsContainer.appendChild(document.createTextNode(' '));
                });
            }

        function openModalWithSectionName(sectionName) {
            // Encuentra el elemento que contiene el título en la ventana modal
            const modalTitleContent = document.getElementById('modalTitleContent');
            // Actualiza el contenido de este elemento con el nombre de la sección recibido
            modalTitleContent.textContent = sectionName;

            // Llama a generateModel para obtener el contenido actual del modelo
            const modelContent = generateModel();

            // Define el contenido deseado para el textarea usando plantillas literales
            const customContent = `As a business model design expert for startups, you specialize in refining business models through detailed, specific feedback and brainstorming tailored to each startup's unique aspects. Your role is to assist in drafting a document that accurately describes a business model, focusing on clear, structured, and relevant advice. Your approach involves:
            Listening closely to understand the specifics of the business.
            Providing concise, targeted guidance without unnecessary repetition or formalities.
            Offering step-by-step feedback to ensure the document effectively captures the business model.
            You focus on the client's needs and how to best articulate their business model.
            GOAL: Write a business model document describing the user's project business model. Here's some information about my Business:
                ${modelContent}
            MY QUESTION: Please suggest content for the "${sectionName}" section of the business model.
            WRITE your answer in PLASTILINN FORMAT, which consists of the text of the answer without any comments or similar, that closely adheres to the format and style of the plastilinn (taking the {block example} as a reference example of a properly formatted answer). In your responsse, each list component should begin with '#tag', followed by the name enclosed in double brackets '[[ ]]', and then a description on a new, indented line. For example:
            - ## 🆔 [[{block id}]]
            - #{block content class} [[list component n]]
                - # description of the list component n
            This is an example of a answer:
            ---
            - ## 🆔 stakeholders
                - text
                - #stakeholder [[Entrepreneurs and Startups in AI]]
                - Emerging companies and entrepreneurs interested in artificial intelligence.
                - #stakeholder [[Professionals and Experts in AI]]
                - Individuals looking to expand their knowledge and network in AI.
            ---
            - You can copy/paste this answer to a document, write 'copy' to have the answer in a text box or write ⬇️ 'download' to save this answer to your computer"
            `;

            // Encuentra el textarea dentro del modal y actualiza su contenido
            const generatedModelContent = document.getElementById('generatedModelContent');
            generatedModelContent.value = customContent;

            // Abre la ventana modal añadiendo la clase 'modal-open'
            document.getElementById('modalTitle').classList.add('modal-open');
        }

        function closeModal() {
            document.getElementById('modalTitle').classList.remove('modal-open'); // Cierra el modal
        }

        document.addEventListener('input', function(e) {
            if (e.target.classList.contains('md-line-content')) {
                const updatedContent = e.target.value;
                const id = parseInt(e.target.getAttribute('data-id'), 10); // Obtiene el ID como número

                // Encuentra el objeto en `model` con el ID correspondiente y actualiza su `content`
                const lineObj = model.find(obj => obj.id === id);
                if (lineObj) {
                    lineObj.content = updatedContent;
                    // Extrae las etiquetas del contenido actualizado, incluyendo caracteres especiales
                    const updatedTags = extractTagsFromContent(updatedContent);

                    // Encuentra el contenedor de etiquetas correspondiente
                    const tagsContainer = e.target.closest('.md-line').querySelector('.tags-container');
                    if (tagsContainer) {
                        // Actualiza el contenedor de etiquetas con las etiquetas extraídas
                        updateTagsContainer(tagsContainer, updatedTags);
                    }
                }
            }
        });

        // Esta función extrae etiquetas del contenido y elimina el símbolo '#'
        function extractTagsFromContent(content) {
            // Ajuste de la expresión regular para incluir caracteres especiales como * y %
            const tagRegex = /#\w+/g;
            const tags = content.match(tagRegex) || [];
            return tags.map(tag => tag.substring(1)); // Elimina el '#' del inicio de cada etiqueta
        }

        document.addEventListener('DOMContentLoaded', function () {
            downloadJSON();
            setupMarkdownFileInput();
            setupDownloadButton();
        });
    </script>

<div id="textEditModal" class="modal" tabindex="-1">
    <div class="modal-box">
        <h3 class="font-bold text-lg">Editar Texto</h3>
        <textarea id="textEditModalContent" class="textarea textarea-bordered w-full mt-4" placeholder="Edita el contenido aquí..."></textarea>
        <div class="modal-action">
            <a href="#" class="btn" onclick="closeTextEditModal()">Guardar</a>
        </div>
    </div>
</div>

    <div id="modalTitle" class="modal" tabindex="-1">
        <div class="modal-box">
            <h3 class="font-bold text-lg" id="modalTitleContent">Título del Modelo</h3>
            <textarea id="generatedModelContent" class="textarea textarea-bordered w-full mt-4"
                placeholder="Aquí aparecerá el contenido del modelo generado..."></textarea>
            <p class="py-4">Paste in <a href="https://chat.openai.com/" target="_blank">ChatGPT</a> or <a
                    href="https://gemini.google.com/app" target="_blank">Gemini Pro</a></p>
            <div class="modal-action">
                <a href="#" class="btn" onclick="closeModal()">Cerrar</a>
            </div>
        </div>
    </div>


</body>

</html>