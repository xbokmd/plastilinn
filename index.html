<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plastilinn</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
    <link rel="stylesheet" href="https://stackedit.io/style.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap" rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">

    <style>
        @keyframes blinkRed {
            0% {
                background-color: transparent;
            }

            50% {
                background-color: red;
            }

            100% {
                background-color: transparent;
            }
        }

        #show-selected {
            animation: blinkRed 1s infinite;
            background-color: transparent;
        }

        #show-selected:empty {
            display: none;
        }

        .selected {
            background-color: lightgrey;
            border: blue;
        }
    </style>


</head>

<body>
    <div id="vue-app">
        <div class="min-h-screen h-screen flex flex-col">
            <!-- HEADER -->
            <header class="border-b border-gray-200">
                <div id="top-container" class="bg-gray-200 w-full fixed">
                    <div id="navbar" class="navbar bg-base-100 shadow-2xl">
                        <div class="navbar-start">
                            <div>
                                <img src="https://xbokmd.github.io/plastilinn/assets/logo.png" alt="Logo" class="h-8">
                            </div>
                            <kbd class="kbd kbd-xs">Plastilinn V0.3.0
                                {{ license }} <span v-if="detectedLanguage"> ({{ detectedLanguage }})</span>
                            </kbd>
                            <div class="flex flex-row justify-between gap-2" id="plastilinn-menu">
                                <button @click="changeSidebar('guides')"
                                    :class="{'selected': selectedButton === 'guides'}"
                                    class="collapse-filter-button btn btn-primary btn-outline btn-sm">
                                    <span class="material-symbols-outlined" translate="no">
                                        fact_check
                                    </span>Guides
                                </button>
                                <button @click="changeSidebar('index')"
                                    :class="{'selected': selectedButton === 'index'}"
                                    class="collapse-filter-button btn btn-primary btn-outline btn-sm">
                                    <span class="material-symbols-outlined" translate="no">
                                        list_alt
                                    </span>Index
                                </button>
                                <button @click="changeSidebar('filter')"
                                    :class="{'selected': selectedButton === 'filter'}"
                                    class="collapse-filter-button btn btn-primary btn-outline btn-sm">
                                    <span class="material-symbols-outlined" translate="no">
                                        filter_alt
                                    </span>Filter
                                </button>
                                <button @click="changeSidebar('search')"
                                    :class="{'selected': selectedButton === 'search'}"
                                    class="collapse-filter-button btn btn-primary btn-outline btn-sm">
                                    <span class="material-symbols-outlined" translate="no">
                                        search
                                    </span>Search
                                </button>

                            </div>
                        </div>

                        <div class="navbar-end">
                            <button id="downloadBtn" @click="downloadMarkdown"
                                class="btn btn-primary btn-outline no-animation">
                                <span class="material-symbols-outlined" translate="no">
                                    download_for_offline
                                </span>
                                Download
                            </button>
                            <button id="exportBtn" @click="downloadHTML"
                                class="btn btn-primary btn-outline no-animation">
                                <span class="material-symbols-outlined" translate="no">
                                    download_for_offline
                                </span>
                                Export
                            </button>
                            <button @click="toggleAutoDownload"
                                :class="{'bg-green-500': autoDownloadEnabled, 'bg-gray-500': !autoDownloadEnabled}"
                                class="btn btn-primary btn-outline no-animation">
                                <span class="material-symbols-outlined" translate="no">
                                    toggle_on
                                </span>
                                Auto Download {{ autoDownloadEnabled ? 'ON' : 'OFF' }}
                            </button>
                        </div>
                    </div>
                </div>
                <div>
                    <div class="bg-gray-200 rounded-lg shadow flex items-center justify-between"
                        id="plastilinn-tag-filter" v-if="modelName">
                        <!-- Parte izquierda: Título y botón de edición -->
                        <div class="flex items-center space-x-2">
                            <span class="text-lg font-semibold flex items-center space-x-2">📄 {{ modelName }}</span>
                            <button @click="openEditorInModal"
                                class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded transition duration-300">
                                Edit
                            </button>
                        </div>
                        <!-- Parte derecha: Filtro de etiquetas y botón Reset -->
                        <div class="flex items-center space-x-4">
                            <div class="flex items-center text-lg font-semibold text-gray-700 space-x-2">
                                <span class="material-symbols-outlined">filter_alt</span> Active filters
                            </div>
                            <!-- Contenedor para las etiquetas seleccionadas -->
                            <div class="flex gap-2 p-2 bg-red-100 rounded">
                                <span id="show-selected" class="gap-2 rounded">
                                    <span v-for="tag in selectedTags" :key="tag" class="h-8 px-2 text-sm rounded"
                                        :data-tag="tag">{{ tag }}</span>
                                    <span v-for="marker in selectedMarkers" :key="marker"
                                        class="h-8 px-2 text-sm rounded" :data-marker="marker">{{ marker
                                        }}</span>
                                </span>
                            </div>

                            <!-- Botón de Reset -->
                            <button @click="resetSelectedTagsAndMarkers" class="btn">
                                <span class="material-symbols-outlined" translate="no">restart_alt</span>
                                Reset
                            </button>
                        </div>
                    </div>
                </div>

            </header>
            <!-- MAIN CONTAINER -->
            <div class="mx-auto flex overflow-y-hidden">
                <!-- SIDEBAR -->
                <nav class="order-first w-2/5 overflow-y-auto custom-scrollbar"
                    style="min-width: 520px; scroll-behavior: smooth;">
                    <!-- Secciones con visibilidad condicional -->
                    <div class="p-2">
                        <div v-if="currentSidebarSection === 'guides'">
                            <div v-if="markdownGuideContent">
                                <div v-html="markdownGuideContent"></div>
                            </div>
                        </div>
                        <div
                            v-bind:class="{ block: currentSidebarSection === 'index', hidden: currentSidebarSection !== 'index' }">
                            <div class="index">
                                <div class="" v-for="block in model.filter(b => b.type === 'section')" :key="block.id"
                                    :class="`index-level-${block.depthLevel} pl-${block.depthLevel * 4} p-0`">
                                    <a class="link link-primary" :href="'#' + block.title">
                                        {{ block.title }}
                                        <span v-if="block.markers && block.markers.length" class="">
                                            <span v-for="marker in block.markers" :key="marker" :data-marker="marker"
                                                class="">{{ marker }}</span>
                                        </span>
                                    </a>
                                </div>
                                </span>
                            </div>
                        </div>
                        <div
                            v-bind:class="{ block: currentSidebarSection === 'filter', hidden: currentSidebarSection !== 'filter' }">
                            <div class=" flex justify-between bg-white" v-if="filterVisible">
                                <div class="flex flex-col gap-4">
                                    <div class="flex flex-col w-full">
                                        <div class="flex flex-col w-full p-4 bg-white rounded-lg shadow-sm">
                                            <!-- Filtro de etiquetas -->
                                            <div class="flex flex-col mt-4">
                                                <div class="tag-group mb-4 px-2 py-3 bg-gray-200 rounded-md shadow-lg">
                                                    <div class="tag-name text-center font-semibold text-blue-600 mb-2">
                                                        Tags <a href="https://plastilinn.com/#/pages/guide?id=tags"
                                                            target="_blank">ℹ️</a>
                                                    </div>
                                                    <ul class="flex justify-center items-center flex-wrap gap-2">
                                                        <li v-for="tag in tags" :key="`tag-${tag}`"
                                                            class="filter-switch-item">
                                                            <input class="checkbox checkbox-primary sr-only"
                                                                :id="`tag-${tag}`" :value="tag" type="checkbox"
                                                                @change="toggleTagSelection(`${tag}`)">
                                                            <label :for="`tag-${tag}`"
                                                                class="cursor-pointer inline-block text-sm text-gray-600 hover:text-gray-800 bg-white rounded shadow p-1">
                                                                <span :data-tag="tag">{{ tag }}</span>
                                                            </label>
                                                        </li>
                                                    </ul>
                                                </div>
                                            </div>
                                            <div class="marker-group mb-4 px-2 py-3 bg-gray-200 rounded-md shadow-lg">
                                                <div class="tag-name text-center font-semibold text-blue-600 mb-2">
                                                    Markers <a href="https://plastilinn.com/#/pages/guide?id=markers"
                                                        target="_blank">ℹ️</a>
                                                </div>
                                                <div v-for="(values, markerName) in prepareMarkers()" :key="markerName">
                                                    <ul class="flex flex-wrap gap-2">
                                                        <li>
                                                            <div class="badge badge-neutral">{{ markerName }}</div>
                                                        </li>
                                                        <li v-for="value in values"
                                                            :key="`marker-${markerName}-${value}`"
                                                            class="filter-switch-item">
                                                            <input class="checkbox checkbox-primary sr-only"
                                                                :id="`marker-${markerName}-${value}`"
                                                                :value="`${markerName}:${value}`" type="checkbox"
                                                                @change="toggleMarkerSelection(`${value}`)">
                                                            <label :for="`marker-${markerName}-${value}`"
                                                                class="cursor-pointer inline-block text-sm text-gray-600 hover:text-gray-800 bg-white rounded shadow p-1">{{
                                                                value }}</label>
                                                        </li>
                                                    </ul>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div
                            v-bind:class="{ block: currentSidebarSection === 'search', hidden: currentSidebarSection !== 'search' }">
                            <div class="flex flex-col mb-4 p-2 bg-gray-200 rounded-lg shadow">
                                <h5 class="card-title">Search and replace</h5>
                                <div class="flex items-center mb-4 p-2 bg-gray-50 rounded-lg shadow">
                                    <span class="material-symbols-outlined" translate="no">
                                        search
                                    </span>
                                    <input v-model="searchQuery" id="seach-query" type="text" placeholder="Search..."
                                        class="input ml-2 bg-gray-50 w-full">
                                </div>
                                <div class="flex items-center mb-4 p-2 bg-gray-50 rounded-lg shadow">
                                    <span class="material-symbols-outlined" translate="no">
                                        find_replace
                                    </span>
                                    <input v-model="replaceText" id="replace-text" type="text"
                                        placeholder="Replace with..." class="input ml-2 bg-gray-50 w-full">
                                </div>
                                <button @click="replaceMatches" class="btn">Replace</button>
                            </div>
                        </div>
                    </div>
                </nav>
                <!-- CONTENT -->
                <main class="w-3/5 flex-auto border-l border-r border-gray-200 overflow-y-auto"
                    style="scroll-behavior: smooth;">
                    <div class="leading-10">
                        <div id="content" class="bg-gray-200 p-1 rounded">
                            <div class="plastilinn-hero hero pt-12" v-if="!modelMarkdownLoaded">
                                <div class="hero-content text-center">
                                    <div class="">
                                        <div role="alert" class="alert alert-error mb-4">
                                            <svg xmlns="http://www.w3.org/2000/svg"
                                                class="h-6 w-6 shrink-0 stroke-current" fill="none" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                            </svg>
                                            <div>
                                                <div class="font-bold">Disclaimer: Early Days Ahead! 🚧</div>
                                                <div>Hey there, brave explorer! You’re
                                                    about to dive into the preview version
                                                    of our app. Expect some bumps, bugs, and quirky moments
                                                    along
                                                    the way. We're hard at work ironing out the kinks, and your feedback
                                                    will help us grow strong and steady. Thanks for being part of the
                                                    adventure!</div>
                                            </div>
                                        </div>
                                        <div
                                            class="md:text-5xl text-2xl uppercase font-black bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-500">
                                            Shape your business with AI
                                        </div>
                                        <div class="text-xl m-4">Design, analyze and validate your business model.
                                        </div>
                                        <div class="card bg-base-100 shadow-xl">
                                            <div class="card-body flex justify-center items-center">
                                                <h2>⬆️ I'm already using plastilinn</h2>
                                                Load or drag and drop your plastilinn doc
                                                <input type="file" @change="loadAndParseModelFile" accept=".md,.txt"
                                                    class="file-input file-input-bordered file-input-primary w-full max-w-xs m-4">
                                            </div>
                                        </div>
                                        <div class="card bg-base-100 shadow-xl mt-4">
                                            <div class="card-body flex justify-center items-center">
                                                <h2>🆕 I'm new to plastilinn and I want to:</h2>
                                                <div class="card-actions">
                                                    <a href="#improve-an-existing-business">🔍 Improve an existing
                                                        business</a>
                                                </div>
                                                <div class="card-actions">
                                                    <a href="#create-a-new-business-from-scratch">✏️ Create a new
                                                        business
                                                        from scratch</a>
                                                </div>
                                                <div class="card-actions">
                                                    <a href="#try-plastilinn">👉 Try plastilinn</a>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="modelContainer m-2 p-0">
                                <div class="flex flex-row w-full">
                                    <div class="md-block-wrapper w-full">
                                        <div v-for="block in searchFilteredBlocks" :key="block.id" :id="block.title"
                                            class="md-block flex">
                                            <div
                                                class="md-block-container-middle md-block-content shadow-xl hover:shadow-2xl transition-shadow bg-white w-4/5">
                                                <div v-html="block.contentParsed"></div>

                                                <!-- Mostrar 'pro' solo si NO tiene metamodel.name y el título es un encabezado Markdown (empieza con # seguido de un espacio) -->
                                                <div v-if="isPremiumContent(block)">
                                                    <span>pro</span>
                                                </div>
                                            </div>
                                            <div
                                                class="md-block-container-right metadata-container text-gray-500 rounded-md text-sm text-center w-1/5">
                                                <div
                                                    class="flex flex-col items-start justify-start w-full bg-gray-200 rounded-md text-sm text-gray-500">
                                                    <div class="xbok-block-tags flex items-center"
                                                        v-if="block.metamodel">
                                                        <button @click="openBlockEditModal(block)"
                                                            class="btn btn-primary btn-outline bg-base-200 p-2 rounded">
                                                            📝
                                                        </button>
                                                        <div :id="block.metamodel.name"
                                                            class="block-metamodel section inline-flex">
                                                            <button @click="openInfoModal(block.metamodel.name)"
                                                                class="btn btn-primary btn-outline">
                                                                🆔
                                                            </button>
                                                        </div>
                                                        <div :id="block.metamodel.name"
                                                            class="block-metamodel section inline-flex">
                                                            <button
                                                                @click="openInfoModal(block.metamodel.name + '?id=🔑-keys')"
                                                                class="btn btn-primary btn-outline">
                                                                <a v-if="block.metamodel?.name"
                                                                    :href="`#${block.metamodel.name} keys`">🔑</a>
                                                            </button>
                                                        </div>
                                                        <div v-else>
                                                            <span><a href="#premium">🔒 pro</a></span>
                                                        </div>
                                                    </div>

                                                </div>
                                            </div>
                                        </div>

                                    </div>
                                </div>
                            </div>
                            <div id="content" class="mt-48 ml-2 mr-2">
                                <div class="flex flex-row w-full">
                                    <div class="md-block-wrapper w-full">
                                        <div v-for="block in filteredBlocks" :key="block.id" :id="block.title"
                                            class="md-block flex">
                                            <!-- Renderizar los bloques -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
            <!-- FOOTER -->
            <!-- <footer class="border-t border-gray-200 p-2">Footer</footer> -->
        </div>
        <!-- MODAL WINDOWS -->
        <!-- Modal para editar el contenido del bloque seleccionada -->
        <div v-if="isBlockEditModalOpen"
            class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full items-center z-50">
            <div class="modal-background absolute inset-0 bg-black opacity-50"></div>
            <div class="relative top-10 mx-auto p-1 border w-4/5 h-4/5 shadow-lg rounded-md bg-white flex flex-col justify-center items-center"
                style="z-index: 100;">
                <div>
                    <div class="text-center">
                        <button class="btn m-2 btn-success" @click="saveChanges">
                            <span class="material-symbols-outlined" translate="no">
                                save
                            </span>
                            Save changes
                        </button>
                        <button class="btn m-2 btn-error" @click="closeModal">
                            <span class="material-symbols-outlined" translate="no">
                                cancel
                            </span>
                            Close window
                        </button>
                        <div class="mt-2">
                            <div id="editor-container"></div>
                        </div>
                        <!-- Mostrar botones dinámicos basados en el metamodelID del bloque -->
                        <div v-if="selectedBlockIndex !== null">
                            <div v-for="prompt in getPromptsForMetamodelID(model[selectedBlockIndex].metamodelID)"
                                :key="prompt.id">
                                <div role="alert" class="alert">🤖 Artificial Intelligence (click to open AI toold and
                                    paste the prompt copied to your clipboard)
                                    <button class="btn m-2 btn-primary"
                                        @click="copyPromptToClipboard(prompt.prompt); openNewWindowWithURL(prompt.url); printMessage('Prompt copied. Paste it in the chatbot!!!')">
                                        <span class="material-symbols-outlined" translate="no">
                                            content_copy
                                        </span>
                                        {{ prompt.caption }}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
        <!-- Modal para el editor de pantalla completa -->
        <div v-if="isFullScreenEditorOpen"
            class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 flex items-center justify-center">
            <div class="relative bg-white w-11/12 h-5/6 p-5 shadow-lg rounded-md">
                <!-- Contenedor del editor -->
                <button @click="saveNewEditorContent(); closeFullScreenEditor()"
                    class="btn m2 btn-success">Save</button>
                <button @click="closeFullScreenEditor()" class="btn m-2 btn-error">Close</button>
                <div id="doc-editor-container"></div>
            </div>
        </div>
        <div id="confirmation-message"
            class="fixed top-4 left-1/2 transform -translate-x-1/2 hidden bg-green-500 text-white py-2 px-4 rounded shadow-md transition-opacity duration-300 opacity-0 z-50">
        </div>
    </div>

    <script>
        Vue.createApp({
            data() {
                return {
                    // APP STATE
                    currentSidebarSection: 'home',
                    isSidebarVisible: true, // Controla la visibilidad de la sidebar
                    isIndexOpen: true,
                    isInfoModalOpen: false,
                    autoDownloadEnabled: true,
                    newMarkdownContent: '',
                    showGuidesSelect: false, // Controla la visibilidad del select
                    markdownGuideContent: '', // Almacena el contenido del Markdown cargado
                    isArtifactModalOpen: false,
                    artifactModalContent: '', // Almacenará el contenido HTML generado
                    generatedContent: '',
                    // METAMODEL
                    metamodel: [],
                    // Definir un array con los símbolos que usan los markers
                    markerSymbols: ['>', '*', '?', '!', '¡', '=', '+', '-'],
                    // MODEL
                    model: [], // Se utilizará para almacenar el modelo de datos creado a partir del Markdown
                    modelName: '',
                    modelMarkdown: '', // Campo para almacenar el contenido Markdown concatenado
                    modelMarkdownLoaded: false, // Variable para controlar si el markdown ha sido cargado y analizado
                    modelTagsArray: new Set(),
                    depthCounters: [0, 0, 0, 0, 0, 0],
                    // MODEL BLOCKS
                    lastId: 0, // Inicializa un contador para los IDs
                    isBlockEditModalOpen: false,
                    selectedBlockContent: '',
                    selectedBlockIndex: null,
                    selectedBlockId: null,
                    tags: [],
                    // BLOCK INFO MODAL
                    selectedInfoBlock: null, // Para almacenar la información del bloque seleccionado
                    selectedBlockInfoURL: null,
                    // FILTERS
                    selectedTags: [], // Almacena las etiquetas seleccionadas
                    selectedBlockTitles: [], // Arreglo para almacenar los titles seleccionados
                    selectedMarkers: [],
                    // combinedFilters: [],
                    filterVisible: true,
                    // SEARCH
                    searchQuery: '',
                    searchText: '',
                    replaceText: '',
                    isFullScreenEditorOpen: false, // Estado para controlar el modal del editor en pantalla completa
                    selectedPrompt: null,
                    selectedButton: null, // Para almacenar el botón seleccionado
                };
            },
            computed: {

                parsedModel() {
                    return this.model.map((block) => ({ ...block, contentParsed: marked.parse(block.content) }));
                },

                filteredBlocks() {
                    try {
                        let blocksWithParents = [];
                        let allLocators = new Set();

                        this.model.forEach(block => {
                            const tagMatch = this.selectedTags.length === 0 || this.selectedTags.some(tag => block.tags.includes(tag));
                            const markerMatch = this.selectedMarkers.length === 0 || this.selectedMarkers.some(marker => {
                                return block.markers && block.markers.some(bMarker => bMarker === marker || bMarker.includes(marker));
                            });

                            if (tagMatch && markerMatch) {
                                blocksWithParents.push(block);
                                allLocators.add(block.locator);

                                let parentLocator = block.locator.split('.').slice(0, -1).join('.');
                                while (parentLocator) {
                                    if (!allLocators.has(parentLocator)) {
                                        const parentBlock = this.model.find(b => b.locator === parentLocator);
                                        if (parentBlock) {
                                            blocksWithParents.unshift(parentBlock);
                                            allLocators.add(parentLocator);
                                        }
                                    }
                                    parentLocator = parentLocator.split('.').slice(0, -1).join('.');
                                }
                            }
                        });

                        // Ordena y resalta como antes
                        blocksWithParents.sort((a, b) => a.locator.localeCompare(b.locator));
                        blocksWithParents.sort((a, b) => a.uid - b.uid);

                        const highlightedBlocks = blocksWithParents.map(block => {
                            const clonedBlock = { ...block };
                            if (this.selectedTags.length > 0) {
                                clonedBlock.contentParsed = this.highlightText(clonedBlock.contentParsed, this.selectedTags);
                            }
                            return clonedBlock;
                        });
                        this.highlightFilteredBlocks();
                        return highlightedBlocks;
                    } catch (error) {
                        console.error('Error al filtrar bloques:', error);
                    }
                },

                combinedFilters() {
                    return [...this.selectedBrands, ...this.selectedTags];
                },

                searchFilteredBlocks() {
                    if (!this.searchQuery) {
                        return this.filteredBlocks;
                    }

                    let filteredBlocks = this.filteredBlocks.filter(block =>
                        block.contentParsed.toLowerCase().includes(this.searchQuery.toLowerCase())
                    );

                    const allLocators = new Set(filteredBlocks.map(block => block.locator));
                    let blocksToAdd = []; // Guardaremos aquí los bloques padres para luego insertarlos

                    filteredBlocks.forEach(block => {
                        const parentLocators = this.findParentLocators(block.locator);
                        parentLocators.forEach(parentLocator => {
                            if (!allLocators.has(parentLocator)) {
                                const parentBlock = this.model.find(b => b.locator === parentLocator);
                                if (parentBlock) {
                                    blocksToAdd.push(parentBlock);
                                    allLocators.add(parentLocator);
                                }
                            }
                        });
                    });

                    // Insertar cada bloque padre en la posición correcta
                    blocksToAdd.forEach(parentBlock => {
                        const childIndex = filteredBlocks.findIndex(block =>
                            block.locator.startsWith(parentBlock.locator + '.')
                        );
                        if (childIndex !== -1) {
                            // Si encontramos un hijo, insertamos el padre justo antes
                            filteredBlocks.splice(childIndex, 0, parentBlock);
                        } else {
                            // Si no encontramos un hijo (debido a filtros), agregamos el padre al final
                            filteredBlocks.push(parentBlock);
                        }
                    });

                    // Finalmente, aplicar el resaltado
                    return filteredBlocks.map(block => {
                        const highlightedContent = this.highlightText(block.contentParsed, this.searchQuery);
                        return { ...block, contentParsed: highlightedContent };
                    });
                },

                orderedBlocks() {
                    return this.model.sort((a, b) => a.uid - b.uid);
                }

            },
            methods: {

                processLicense() {
                    const params = new URLSearchParams(window.location.search);
                    const license = params.get('license');

                    if (license) {
                        // Verificar si el primer carácter de la licencia es '0'
                        if (license.charAt(0) === '0') {
                            this.license = 'free'; // Variable global en el contexto de Vue
                        } else {
                            this.license = 'premium'; // Variable global en el contexto de Vue
                        }

                        // Asignar el valor de la licencia al div con ID "license"
                        const licenseDiv = document.getElementById('license');
                        if (licenseDiv) {
                            licenseDiv.innerText = this.license;
                        }
                    }
                },

                isPremiumContent(block) {
                    // Mostrar 'pro' si NO tiene metamodel.name y el título es un encabezado Markdown
                    return !block.metamodel?.name && /^#+\s/.test(block.title);
                },

                changeSidebar(section) {
                    this.currentSidebarSection = section;
                    this.selectedButton = section; // Actualiza el botón seleccionado
                    this.resetSelectedTagsAndMarkers(); // Llama al método de reset
                    // Si la sección no es 'filter', resetea el input de búsqueda y los tags de filtro
                    if (section !== 'filter') {
                        this.searchQuery = ''; // Resetea el input de búsqueda
                        this.selectedTags = []; // Resetea los tags de filtro seleccionados
                    }
                },

                // METAMODEL

                processMetamodel() {
                    axios.get('https://xbokmd.github.io/plastilinn/metamodel/00000000.json')
                        .then((response) => {
                            if (response.data && response.data.classes && response.data.sections) {
                                this.metamodel = response.data;
                            } else {
                                console.error('Metamodel received does not have the expected structure');
                            }
                        })
                        .catch((error) => console.error('Error loading metamodel:', error));
                },

                // MODEL LOADING

                loadAndParseModelFile(event) {
                    const file = event.target.files[0];
                    if (!file) {
                        return;
                    }
                    const modelName = this.getModelNameFromFileName(file.name);
                    this.modelName = modelName; // Actualiza modelName con el resultado de la función

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;

                        // Detectar la variable de idioma en el contenido Markdown
                        const languageMatch = content.match(/<!--\s*language:\s*(\w+)\s*-->/);
                            let language = 'en'; // Valor por defecto (inglés)
                        if (languageMatch && languageMatch[1]) {
                            language = languageMatch[1]; // Obtener el valor del idioma si está presente
                        }

                        // Almacenar el idioma detectado
                        this.detectedLanguage = language;

                        // Procesar el contenido del archivo Markdown
                        this.parseModelMarkdown(content);
                    };
                    reader.readAsText(file);
                    this.updateModelMarkdown();
                    this.modelMarkdownLoaded = true;
                },

                // Método para mostrar el idioma al lado del logo
                displayLanguageNextToLogo(language) {
                    const logoElement = document.querySelector('.navbar-start'); // Ubica el contenedor del logo
                    if (logoElement) {
                        // Remover cualquier elemento previo de idioma
                        const previousLanguageElement = logoElement.querySelector('.language-label');
                        if (previousLanguageElement) {
                            previousLanguageElement.remove();
                        }

                        // Crear un nuevo span para mostrar el idioma
                        const languageElement = document.createElement('span');
                        languageElement.textContent = `(${language})`; // Mostrar el idioma detectado
                        languageElement.classList.add('ml-2', 'text-gray-500', 'language-label'); // Añadir clase para estilo
                        logoElement.appendChild(languageElement); // Insertar el elemento al lado del logo
                    }
                },

                getModelNameFromFileName(fileName) {
                    let name = fileName.replace(/\.(md|txt)$/, ''); // Elimina la extensión ".md" y ".txt"
                    name = name.replace(/ - saved.*$/, ''); // Elimina " - saved" y todo lo que sigue
                    return name;
                },

                parseModelMarkdown(content) {
                    const model = this.splitModelMarkdownIntoBlocks(content);
                    this.model = model.map((blockContent) => this.processBlock(blockContent));
                    this.assignUids();
                    this.updateTagsArray();
                    this.modelMarkdownLoaded = true; // Indicar que el markdown ha sido cargado y analizado
                },

                splitModelMarkdownIntoBlocks(content) {
                    let currentBlock = [];
                    const lines = content.split(/\r?\n/);

                    lines.forEach((line) => {
                        if (/^\s*[*]?\s*#/.test(line)) {
                            if (currentBlock.length > 0) {
                                this.model.push(currentBlock.join('\n'));
                                currentBlock = [];
                            }
                        }
                        currentBlock.push(line);
                    });
                    if (currentBlock.length > 0) {
                        this.model.push(currentBlock.join('\n'));
                    }
                    return this.model;
                },

                // Método para manejar la descarga cuando el usuario intenta cerrar la pestaña
                handleBeforeUnload(event) {
                    // Mostrar mensaje de advertencia personalizado
                    const message = "You might have unsaved changes. Do you want to download your document before closing? Close this alert and click on the download button";

                    // Establecer el mensaje de advertencia en el evento
                    event.returnValue = message;

                    // También devolver el mensaje para ciertos navegadores
                    return message;
                },
                // Método para asegurarte de que se elimine el listener cuando no es necesario
                addBeforeUnloadListener() {
                    window.addEventListener('beforeunload', this.handleBeforeUnload);
                },
                removeBeforeUnloadListener() {
                    window.removeEventListener('beforeunload', this.handleBeforeUnload);
                },

                // BLOCK PROCESSING

                updateModelBlockContent(blockId, newContent) {
                    const blockIndex = this.model.findIndex(block => block.id === blockId);
                    if (blockIndex !== -1) {
                        // Actualiza el contenido
                        const block = this.model[blockIndex];
                        // Asegura que newContent sea una cadena antes de asignarla.
                        // Si newContent no es una cadena, podrías convertirla a cadena o manejar el error como prefieras.
                        if (typeof newContent !== 'string') {
                            console.error('newContent esperaba una cadena, recibido:', typeof newContent, newContent);
                            // Por ejemplo, si newContent debería ser siempre una cadena, podrías convertirla forzosamente a cadena
                            // o asignar una cadena vacía o algún valor por defecto según sea apropiado para tu aplicación.
                            newContent = String(newContent); // Convierte forzosamente a cadena (podría resultar en 'undefined' o 'null' como cadena)
                            // O manejar el caso de manera diferente según sea necesario.
                        }

                        block.content = newContent;

                        // Llama a los métodos para recalcular los campos dependientes
                        this.updateDependentModelBlockFields(blockIndex);
                    }
                },

                updateDependentModelBlockFields(blockIndex) {
                    const block = this.model[blockIndex];
                    // Conversión forzada a cadena si es necesario.
                    let contentAsString = String(block.content)
                    const mdToHTML = this.parseToHTML(block.content);
                    block.contentParsed = marked.parse(mdToHTML);
                    //block.contentParsed = marked.parse(mdToHTML);
                    const firstLine = block.content.split('\n')[0];
                    block.type = this.determineBlockType(firstLine);
                    block.depthLevel = this.determineDepthLevel(firstLine);
                    block.title = this.extractBlockTitle(block.content); // Ajustado para usar el método recalculado
                    block.instanceClass = this.determineInstanceClass(block.content, block.type);
                    const tagResults = this.processTags(block.content);
                    block.tags = tagResults.tags;
                    block.tagsParsed = tagResults.tagsParsed;
                    block.markers = tagResults.markers;
                    block.markersParsed = tagResults.markersParsed;
                    block.instanceValue = this.setInstanceValue(block.title);
                    block.metamodelID = this.generateMetamodelID(block.title, block.instanceClass);
                    block.metamodel = this.importMetamodelData(block.metamodelID);
                    // Llama al nuevo método para calcular el locator
                    block.locator = this.calculateLocator(block.depthLevel);
                    // Aquí puedes agregar más campos para recalcular si es necesario
                },

                processBlock(blockContent, blockId = null) {
                    let block;
                    let isNewBlock = false;

                    if (blockId == null) {
                        // Creación de un nuevo bloque
                        this.lastId += 1;
                        block = { id: this.lastId, content: blockContent };
                        this.model.push(block);
                        isNewBlock = true;
                    } else {
                        // Actualización de un bloque existente
                        const blockIndex = this.model.findIndex(block => block.id === blockId);
                        if (blockIndex === -1) {
                            console.error("Block not found");
                            return;
                        }
                        block = this.model[blockIndex];
                        block.content = blockContent;
                    }

                    if (!isNewBlock || block.content) {
                        const blockIndex = this.model.findIndex(b => b.id === block.id);
                        this.updateDependentModelBlockFields(blockIndex);
                    }

                    // Siempre devuelve el bloque para operaciones de creación. Para actualizaciones,
                    // el bloque ya está actualizado en el modelo.
                    return block;
                },

                determineBlockType(firstLine) {
                    if (/^\s*(-\s+)?#(\s|#)/.test(firstLine)) {
                        return 'section';
                    }
                    return 'item';
                },

                determineDepthLevel(firstLine) {
                    // Esta expresión regular busca signos '#' al inicio de la línea seguidos directamente
                    // por otro '#' o un espacio, indicando un encabezado de Markdown.
                    const match = firstLine.match(/^\s*(#+)(?=\s|#)/);
                    if (match) {
                        return match[1].length; // La longitud de la coincidencia es el nivel de profundidad.
                    }
                    // Si no es un encabezado de Markdown, retorna 0 o un valor por defecto.
                    return 0;
                },

                calculateLocator(depthLevel) {
                    if (depthLevel === 0) {
                        // Encuentra el último locator con un depthLevel > 0 y trátalo como base para este.
                        const lastNonZeroDepthLocator = this.findLastNonZeroDepthLocator();
                        return `${lastNonZeroDepthLocator}.1`; // Asume que quieres añadirlo como un subnivel del último encabezado.
                    } else if (depthLevel >= 1 && depthLevel <= 6) {
                        this.depthCounters[depthLevel - 1] += 1;

                        for (let i = depthLevel; i < 6; i++) {
                            this.depthCounters[i] = 0;
                        }

                        return this.depthCounters.slice(0, depthLevel).join('.');
                    } else {
                        console.error(`Depth level out of range: ${depthLevel}`);
                        return '';
                    }
                },

                findLastNonZeroDepthLocator() {
                    // Busca hacia atrás desde el final del array model hasta encontrar un bloque con depthLevel > 0.
                    for (let i = this.model.length - 1; i >= 0; i--) {
                        if (this.model[i].depthLevel > 0) {
                            return this.model[i].locator; // Asegúrate de que este bloque ya tiene un locator calculado.
                        }
                    }
                    return '0'; // Devuelve un valor por defecto si no encuentras ninguno.
                },

                determineInstanceClass(blockContent, type) {
                    if (type === 'section') {
                        const match = blockContent.match(/^\s*#+\s*(#[^\s]+)/);
                        if (match && match[1] && !/^#+$/.test(match[1])) {
                            return match[1].substring(1);
                        }
                    }
                    return null;
                },

                processTags(blockContent) {
                    const markerSymbols = this.markerSymbols;
                    // Inicializando un nuevo array para los marcadores ajustados
                    const adjustedMarkers = [];

                    // Capturando marcadores: cadenas que comienzan con # seguido por uno de los símbolos especiales de marcadores
                    const markers = [...blockContent.matchAll(/(?:^|\s)#([>!*?+^-][^\s]*)/g)].map(match => {
                        const markerWithoutPrefix = match[1];
                        adjustedMarkers.push(markerWithoutPrefix); // Agrega el marcador ajustado sin el prefijo
                        return markerWithoutPrefix; // Devuelve el marcador sin el prefijo para el mapeo
                    });

                    const markersParsed = adjustedMarkers.map(marker => this.parseMarker(marker)).join(' ');

                    // Expresión regular ajustada para capturar etiquetas
                    const tagsRegex = /(?:^|\s)(#[^\s#][^\s]*)/g;
                    const tags = [];
                    let match;
                    while ((match = tagsRegex.exec(blockContent)) !== null) {
                        // Evita bucles infinitos con coincidencias de ancho cero
                        if (match.index === tagsRegex.lastIndex) {
                            tagsRegex.lastIndex++;
                        }

                        // Excluye marcadores del array de etiquetas
                        if (!markerSymbols.some(symbol => match[1].startsWith(`#${symbol}`))) {
                            tags.push(match[1].substring(1)); // Elimina el # principal por consistencia con tu lógica original
                        }
                    }
                    const tagsParsed = tags.map(tag => this.parseTag(tag)).join(' ');

                    // Nota: Este código asume que todos los marcadores vienen con un prefijo y los ajusta en consecuencia.
                    // Si algunos marcadores pueden venir sin prefijo, deberás ajustar esta lógica.
                    return { markers: adjustedMarkers, markersParsed, tags, tagsParsed };
                },

                parseMarker(marker) {
                    // Asegúrate de que esta función maneje correctamente el marcador ya sin prefijo
                    return `<span data-marker="${marker}">#${marker}</span>`;
                },

                parseTag(tag) {
                    return `<span data-tag="${tag}">#${tag}</span>`;
                },

                extractBlockTitle(blockContent) {
                    const firstLine = blockContent.split(/\r?\n/)[0]; // Obtiene la primera línea

                    // Extrae el encabezado Markdown y la primera etiqueta (si existe) que esté directamente después del encabezado
                    const matches = firstLine.match(/^(#+\s*)(#[^\s]+)?\s*(.*)/);
                    if (matches) {
                        const markdownHeader = matches[1]; // Encabezado Markdown (p.ej., '###')
                        const directTag = matches[2] ? `${matches[2]} ` : ''; // La etiqueta directa después del encabezado, si existe
                        const restOfTheTitle = matches[3]; // El resto del título después del encabezado y la etiqueta directa

                        // Combina la etiqueta directa (si existe) y el resto del título, eliminando otras etiquetas
                        let title = (directTag + restOfTheTitle).replace(/#[^\s]+/g, '').trim();

                        // Elimina cualquier número de '#' que puedan existir al principio del valor de la variable title y estén seguidos de un espacio
                        title = title.replace(/^#+\s*/, '');

                        // /// console.log('Returning title with matches:', title); // Traza antes del return
                        return title;
                    }

                    // En caso de que no haya coincidencia, retorna la línea completa, pero también limpiamos posibles '#' al inicio aquí.
                    // Se asegura que se aplique la eliminación de '#' seguidos de un espacio para todos los casos.
                    const finalTitle = firstLine.replace(/^#+\s*/, '').trim();
                    /// console.log('Returning title without matches:', finalTitle); // Traza antes del return
                    return finalTitle;
                    // Asegurarse de devolver una cadena vacía si el título no se encuentra
                    return title || '';
                },

                setInstanceValue(title) {
                    /// console.log("🚀 ~ setInstanceValue ~ title:", title)
                    // Verifica si title es una cadena
                    if (typeof title !== "string") {
                        /// console.log("title debe ser una cadena.setInstanceValue ~ title:", title);
                        return ""; // Retorna una cadena vacía o maneja el caso como prefieras
                    }

                    // Initial assignment based on title starting with a hashtag
                    if (/^#\w+/.test(title)) {
                        this.instanceValue = title;
                    }

                    // Extract component after the initial tag and dash, refining instanceValue
                    const titleParts = title.match(/^#\w+\s+(.*?)\s*(-|$)/);
                    /// console.log("🚀 ~ setInstanceValue ~ titleParts:", titleParts)
                    if (titleParts && titleParts[1]) {
                        this.instanceValue = titleParts[1].replace(/#\w+/g, '').trim();
                    } else if (title.includes('-')) {
                        this.instanceValue = title.split('-')[0].trim();
                    } else {
                        this.instanceValue = title.trim();
                    }
                    /// console.log("🚀 ~ setInstanceValue ~ this.instanceValue:", this.instanceValue)
                    return this.instanceValue;
                },

                generateMetamodelID(title, instanceClass) {
                    // Si instanceClass está vacío o es null, retorna directamente el title
                    if (!instanceClass) {
                        return title;
                    }

                    // Si instanceClass no está vacío y el título no contiene un guión con un espacio a cada lado
                    if (instanceClass && !title.includes(" - ")) {
                        return `${instanceClass} Name`;
                    }

                    // Si instanceClass no está vacío y el título contiene un guión con un espacio a cada lado
                    if (instanceClass && title.includes(" - ")) {
                        // Extrae el texto a la derecha del guión, incluyendo el guión y los espacios
                        const titleAfterDash = title.substring(title.indexOf(" - ") + 3);
                        // Construye metamodelID usando instanceClass y el texto a la derecha del guión, reemplazando el inicio del título por "Name"
                        return `${instanceClass} Name - ${titleAfterDash}`;
                    }

                    // En cualquier otro caso (por precaución), retorna el título
                    return title;
                },

                importMetamodelData(metamodelID) {
                    /// console.log("🚀 ~ importMetamodelData ~ metamodelID:", metamodelID)
                    // Encuentra la sección que coincide con el metamodelID proporcionado.
                    const section = this.metamodel.sections.find((section) => section.name === metamodelID);

                    if (section) {
                        /// console.log("🚀 ~ importMetamodelData ~ section:", section)
                        return section;
                    }
                    /// console.log('No se encontró ninguna sección que coincida con el metamodelID:', metamodelID);
                    return null;
                },

                parseToHTML(content) {
                    if (typeof content !== 'string') {
                        console.error('Expected content to be a string, but got:', typeof content, content);
                        return ''; // Retorna una cadena vacía o maneja el error como prefieras
                    }

                    // Define un array con los símbolos que usan los markers
                    const markerSymbols = this.markerSymbols;

                    // Procesa etiquetas y marcadores primero
                    let processedTagsContent = content.replace(/(^|\s)(#[^\s#]+)/g, (match, p1, p2) => {
                        if (markerSymbols.some(symbol => p2[1] === symbol)) {
                            // Si es un marcador
                            return `${p1}${this.parseMarker(p2.slice(1))}`;
                        } else {
                            // Si es una etiqueta
                            return `${p1}${this.parseTag(p2.slice(1))}`;
                        }
                    });
                    return processedTagsContent;
                },

                openInfoModal(block) {
                    /// console.log("🚀 ~ openInfoModal ~ block:", block)
                    this.selectedInfoBlock = block;
                    this.selectedBlockId = block.id; // Asegúrate de tener selectedBlockId definido en tu data()
                    this.selectedBlockInfoURL = `https://xbokmd.github.io/plastilinn/raw.html#/docs/xBoK/sections/${block.replace(/ /g, '_')}`;
                    // Busca el índice de la línea basándose en el ID único
                    this.selectedBlockIndex = this.model.findIndex((item) => item.id === block.id);
                    this.isInfoModalOpen = true;
                    this.$nextTick(() => {
                        // Asegúrate de que el contenedor del editor esté disponible en el DOM
                        this.selectedBlockInfoURL;
                    });

                    const width = 900; // Ancho de la ventana
                    const height = 600; // Alto de la ventana

                    // Calcular posición central
                    const y = window.top.outerHeight / 2 + window.top.screenY - (height / 2);
                    const x = window.top.outerWidth / 2 + window.top.screenX - (width / 2);

                    window.open(this.selectedBlockInfoURL, 'Modal', `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, copyhistory=no, width=${width}, height=${height}, top=${y}, left=${x}`);
                },

                findParentLocators(locator) {
                    const parts = locator.split('.');
                    const parents = [];

                    for (let i = 1; i < parts.length; i++) {
                        parents.push(parts.slice(0, i).join('.'));
                    }

                    return parents;
                },

                // EDIT BLOCK

                initEditor() {
                    if (this.editor) {
                        this.editor.destroy(); // Destruye la instancia anterior del editor
                    }
                    this.editor = new toastui.Editor({
                        el: document.querySelector('#editor-container'),
                        initialEditType: 'markdown',
                        previewStyle: 'tab',
                        height: '340px',
                        width: '500px',
                        hideModeSwitch: true,
                        initialValue: this.selectedBlockContent, // Asume que `editingContent` es tu contenido actual que quieres editar
                    });
                },

                openBlockEditModal(block) {
                    this.updateModelMarkdown();
                    this.selectedBlockId = block.id; // Asegúrate de tener selectedBlockId definido en tu data()
                    this.selectedBlockContent = block.content;
                    this.selectedBlockIndex = this.model.findIndex((item) => item.id === block.id);
                    this.isBlockEditModalOpen = true;
                    this.$nextTick(() => {
                        // Asegúrate de que el contenedor del editor esté disponible en el DOM
                        this.initEditor();
                    });
                },

                showHelpSection() {
                    const helpSection = document.getElementById('help-section');
                    const editingSection = document.getElementById('editing-your-plastilinn-doc');

                    if (helpSection && editingSection) {
                        // Copiar el contenido de la sección 'editing-your-plastilinn-doc' dentro del contenedor 'help-section'
                        helpSection.innerHTML = editingSection.innerHTML;

                        // Puedes desplazar la página hacia el contenedor, si lo deseas
                        helpSection.scrollIntoView({ behavior: 'smooth' });
                    } else {
                        console.error('No se encontró la sección de ayuda o la sección de edición.');
                    }
                },

                getPromptsForMetamodelID(metamodelID) {
                    return this.metamodel.prompts.filter(prompt => {
                        // Añadir log para ver los valores de prompt.item y metamodelID en la consola
                        console.log('prompt.item:', prompt.item, 'metamodelID:', metamodelID);

                        // Filtrar los prompts que coinciden con el metamodelID
                        return prompt.item === metamodelID;
                    });
                },

                // EDIT MD DOCUMENT

                closeFullScreenEditor() {
                    this.isFullScreenEditorOpen = false; // Cierra el modal
                },

                handleSelection() {
                    if (this.selectedPrompt) {
                        this.copyPromptToClipboard(this.selectedPrompt.prompt);
                        this.openNewWindowWithURL(this.selectedPrompt.url);
                        this.printMessage('Prompt copied. Paste it in the chatbot!!!');
                    }
                },

                initDocumentEditor() {
                    const editorContainer = document.querySelector('#doc-editor-container');
                    if (!editorContainer) {
                        console.error("Editor container not found");
                        return; // Sal del método si el contenedor no existe
                    }

                    if (this.editor) {
                        this.editor.destroy(); // Destruye el editor si ya existe una instancia anterior
                    }

                    this.editor = new toastui.Editor({
                        el: editorContainer,
                        initialEditType: 'markdown',
                        previewStyle: 'tab',
                        height: '500px',
                        initialValue: this.modelMarkdown, // Puedes ajustar para cargar el contenido markdown actual
                    });
                },

                openEditorInModal() {
                    this.updateModelMarkdown();  // Actualiza el contenido del Markdown antes de abrir el editor
                    this.isFullScreenEditorOpen = true;  // Abre el modal

                    setTimeout(() => {
                        const editorContainer = document.querySelector('#doc-editor-container');
                        if (!editorContainer) {
                            console.error("Editor container not found");
                            return;
                        }

                        // Verifica si el contenido está cargado antes de inicializar el editor
                        if (!this.modelMarkdown || this.modelMarkdown.trim() === '') {
                            console.error('No markdown content available');
                            this.modelMarkdown = '# Your initial markdown content here';
                        }

                        this.newEditorInstance = new toastui.Editor({
                            el: editorContainer,
                            initialEditType: 'markdown',
                            previewStyle: 'tab',
                            height: '500px',
                            initialValue: this.modelMarkdown,  // Asegúrate de que el contenido Markdown esté disponible aquí
                        });
                    }, 500);
                },


                showGeneratedContent() {
                    this.generatedContent = this.generateSuggestionPrompt();
                },

                printMessage(message) {
                    const confirmationMessage = document.getElementById('confirmation-message');
                    confirmationMessage.textContent = message; // Establece el mensaje proporcionado como contenido del elemento
                    confirmationMessage.classList.remove('hidden', 'opacity-0');
                    confirmationMessage.classList.add('opacity-100');

                    setTimeout(() => {
                        confirmationMessage.classList.remove('opacity-100');
                        confirmationMessage.classList.add('opacity-0');
                        setTimeout(() => {
                            confirmationMessage.classList.add('hidden');
                        }, 300); // Duración de la transición
                    }, 8000); // Tiempo de espera para ocultar el mensaje
                },

                generateCompletePrompt(partialPrompt) {
                    this.updateModelMarkdown();
                    const { modelMarkdown } = this;
                    const completePrompt = partialPrompt + `
        CUSTOM INFO: Here's some information about the business:\n\n`
                        + `--- business model start ---\n\n`
                        + `${modelMarkdown}\n\n`
                        + `--- business model end ---\n\n`;
                    return completePrompt;
                },

                copyPromptToClipboard(prompt) {
                    const textarea = document.createElement('textarea');
                    textarea.value = this.generateCompletePrompt(prompt);  // Referencia al método correctamente con 'this'
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);

                    // Llama al método printMessage con el mensaje de confirmación
                    this.printMessage('Prompt copied to clipboard!!!');
                },

                openNewWindowWithURL(url) {
                    const width = 800;
                    const height = 600;
                    const y = window.top.outerHeight / 2 + window.top.screenY - (height / 2);
                    const x = window.top.outerWidth / 2 + window.top.screenX - (width / 2);
                    window.open(url, '_blank', `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, width=${width}, height=${height}, top=${y}, left=${x}`);
                },

                saveChanges() {
                    const editedContent = this.editor.getMarkdown();
                    const oldTitle = this.extractBlockTitle(this.selectedBlockContent); // Utiliza tu método existente para extraer el título
                    const newTitle = this.extractBlockTitle(editedContent); // Suponiendo que tengas una función similar para el contenido editado

                    if (oldTitle !== newTitle) {
                        alert("You have changed the title of the block." +
                            "If you didn't intend to do so (IE, you were pasting a response generated by AI), simply close the block editor (click the Close window button), open it again and paste the response below the heading" +
                            "If you wand to change the title, you might want to use the search and replace feature within the Search menu. " +
                            `Search "${oldTitle}" and replace it with "${newTitle}"`);
                    }

                    if (this.selectedBlockIndex !== null) {
                        // Encuentra el ID del bloque seleccionado para poder pasarlo al método de actualización.
                        const blockId = this.model[this.selectedBlockIndex].id;

                        // Actualiza el bloque utilizando el método de actualización que maneja la lógica de recalculo.
                        this.updateModelBlockContent(blockId, editedContent);

                        // Nota: No necesitas procesar tags, title, etc., aquí, ya que eso se manejará en el método de recálculo.
                    }
                    this.updateModelMarkdown();
                    const markdownContent = this.modelMarkdown; // Obtiene el valor actual de modelMarkdown
                    this.newMarkdownContent = markdownContent; // Almacena el contenido en el estado
                    this.processNewContent();
                    this.closeModal();

                    // Después de guardar, verifica si autoDownload está habilitado
                    if (this.autoDownloadEnabled) {
                        this.downloadMarkdown(); // Asume que este es tu método de descarga existente
                    }
                    // this.highlightTitlesInContent();
                },

                closeModal() {
                    this.isBlockEditModalOpen = false;
                },

                // NAVIGATION

                highlightOnLoad() {
                    this.$nextTick(() => {
                        if (window.location.hash) {
                            const hash = decodeURIComponent(window.location.hash.substring(1)); // Decodifica el hash.
                            this.highlightBlock(hash);
                        }
                    });
                },

                highlightBlock(id) {
                    const element = document.getElementById(id);
                    if (element) {
                        element.classList.add('highlight');
                        setTimeout(() => element.classList.remove('highlight'), 5000);
                    }
                },

                highlightFilteredBlocks() {
                    this.$nextTick(() => {
                        // Asumiendo que tienes un array 'filteredBlocks' que contiene los bloques filtrados
                        this.filteredBlocks.forEach(block => {
                            const element = document.getElementById(block.title); // Asumiendo que el 'id' del elemento HTML corresponde al 'title' del bloque
                            if (element) {
                                element.classList.add('highlight');
                                setTimeout(() => element.classList.remove('highlight'), 5000);
                            }
                        });
                    });
                },

                // MODEL PROCESSING

                assignUids() {
                    let uid = 1; // Inicia el contador de UID en 1 o cualquier otro valor inicial que prefieras.
                    this.model.forEach((block) => {
                        block.uid = uid++; // Asigna el UID y luego incrementa el contador.
                    });
                    /// console.log('UIDs assigned to model blocks:', this.model);
                },

                resetDepthCounters() {
                    this.depthCounters = [0, 0, 0, 0, 0, 0];
                },

                // Método para abrir el contenido en un nuevo editor
                openInNewEditor() {
                    this.updateModelMarkdown();

                    // Crea un nuevo div dinámicamente
                    const editorContainer = document.createElement('div');
                    editorContainer.id = `editor-container-${Date.now()}`; // Un ID único para cada instancia
                    editorContainer.style = 'margin-top: 20px;'; // Opcional, para añadir espaciado

                    // Añade el contenedor del editor al cuerpo
                    document.body.appendChild(editorContainer);

                    // Inicializa un nuevo editor y guarda la referencia en `this.newEditorInstance`
                    this.newEditorInstance = new toastui.Editor({
                        el: editorContainer,
                        initialEditType: 'markdown',
                        previewStyle: 'tab',
                        height: '500px', // Ajusta la altura según sea necesario
                        initialValue: this.modelMarkdown, // Utiliza el contenido actual de Markdown
                    });

                    // Crea un botón para guardar el contenido del nuevo editor
                    const saveButton = document.createElement('button');
                    saveButton.innerText = 'Save as Markdown';
                    saveButton.classList.add('btn', 'btn-primary btn-outline', 'm-2');
                    saveButton.onclick = this.saveNewEditorContent; // Asigna el método de guardado al evento `click`

                    // Añade el botón de guardar después del editor
                    editorContainer.appendChild(saveButton);
                },


                generateFileName() {
                    const { modelName } = this; // Obtén el nombre actual del modelo
                    const timestamp = new Date().toISOString().replace(/[:-]|\.\d{3}/g, ''); // Genera un timestamp en el formato deseado
                    return `${modelName} - saved ${timestamp}.txt`; // Devuelve el nombre del archivo
                },

                // Método para guardar el contenido del nuevo editor como archivo Markdown
                saveNewEditorContent() {
                    if (this.newEditorInstance) {
                        // Obtén el contenido actual del editor en formato Markdown
                        const markdownContent = this.newEditorInstance.getMarkdown();

                        // Usa el método `generateFileName()` para obtener el nombre del archivo
                        const fileName = this.generateFileName();

                        // Crea un Blob con el contenido Markdown
                        const blob = new Blob([markdownContent], { type: 'text/markdown' });

                        // Crea un enlace para descargar el archivo
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = fileName;

                        // Simula un clic en el enlace para iniciar la descarga
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        // Simula la carga del archivo y procesa el nuevo contenido en Markdown
                        this.newMarkdownContent = markdownContent;

                        // Llama al método para refrescar todo el modelo
                        this.refreshModelFromMarkdown();

                        // Opcional: Mostrar un mensaje de confirmación o hacer más acciones después de guardar
                        this.printMessage('Markdown saved and model refreshed.');
                    } else {
                        alert('No editor instance found');
                    }
                },

                refreshModelFromMarkdown() {
                    // Resetea el modelo antes de procesar el nuevo contenido
                    this.model = [];
                    this.resetDepthCounters();

                    // Procesa el contenido Markdown nuevo
                    this.parseModelMarkdown(this.newMarkdownContent);

                    // Actualiza el contenido Markdown para reflejar los cambios
                    this.updateModelMarkdown();

                    // Llama a los métodos para actualizar los tags y otros campos si es necesario
                    this.updateTagsArray();

                    // Si hay algún otro método necesario para refrescar la UI, se puede agregar aquí.
                    this.$nextTick(() => {
                        this.highlightFilteredBlocks(); // Opcional, resalta bloques filtrados
                    });
                },



                // Método para simular la subida del archivo después de la descarga
                simulateFileUpload(blob, fileName) {
                    // Crea un archivo simulado (File API no está soportada directamente en blobs, pero esta es una solución aproximada)
                    const simulatedFile = new File([blob], fileName, { type: 'text/markdown' });

                    // Crea un FileReader para leer el archivo como texto
                    const reader = new FileReader();

                    reader.onload = (event) => {
                        const content = event.target.result; // Este es el contenido del archivo subido
                        // Procesa el archivo subido como si hubiera sido subido por el usuario
                        this.parseModelMarkdown(content); // Método para parsear el contenido Markdown
                    };

                    // Leer el archivo como texto
                    reader.readAsText(simulatedFile);
                },


                updateModelMarkdown() {
                    let concatenatedContent = '';
                    this.model.forEach((item) => {
                        concatenatedContent += `${item.content}\n`;
                    });
                    this.modelMarkdown = concatenatedContent; // Actualiza el Markdown
                },

                updateTagsArray() {
                    // Cargar la lista de bloques
                    this.model.forEach((block) => block.tags.forEach((tag) => this.modelTagsArray.add(tag)));
                    // Convertir modelTagsArray a un array, ordenarlo alfabéticamente y luego asignar a this.tags
                    this.tags = Array.from(this.modelTagsArray).sort((a, b) => a.localeCompare(b));
                    // Inicializar el filtrado (si necesario)
                    //this.filterBlocks([]);
                },

                // FILTERS AND SEARCH

                setFilterTags(tags) {
                    // Establece las etiquetas seleccionadas directamente
                    this.selectedTags = tags;
                },

                filteredBlocksByTags(tags) {
                    return this.model.filter((block) => block.tags.some((tag) => tags.includes(tag)));
                },

                resetSelectedTagsAndMarkers() {
                    this.selectedTags = [];
                    this.selectedMarkers = [];
                },

                buildTagsQueryList(tags) {
                    // Filtra los bloques que contienen todas las etiquetas especificadas
                    const filteredBlocks = this.model.filter((block) => tags.every((tag) => block.tags.includes(tag)));
                    // Construye una lista de HTML con los titles de los bloques filtrados
                    let htmlList = '<ul>';
                    filteredBlocks.forEach((block) => {
                        htmlList += `<li>${block.title}</li>`;
                    });
                    htmlList += '</ul>';

                    // Devuelve la lista HTML
                    return htmlList;
                },

                toggleTagSelection(tag) {
                    console.log("🚀 ~ toggleTagSelection ~ tag:", tag)
                    const index = this.selectedTags.indexOf(tag);
                    if (index > -1) {
                        this.selectedTags.splice(index, 1); // Si la etiqueta ya está seleccionada, quítala
                    } else {
                        this.selectedTags.push(tag); // Si no, añádela
                    }
                },

                toggleMarkerSelection(marker) {
                    // Asume que los marcadores ya se gestionan con su propio sistema de prefijos o identificación
                    const index = this.selectedMarkers.indexOf(marker);
                    if (index > -1) {
                        this.selectedMarkers.splice(index, 1); // Si el marcador ya está seleccionado, quítalo
                    } else {
                        this.selectedMarkers.push(marker); // Si no, añádelo
                    }
                },

                highlightText(text, terms) {
                    if (!terms.length) return text; // Si no hay términos, devuelve el texto tal cual

                    // Asegura que terms sea un array. Si no lo es, conviértelo.
                    if (!Array.isArray(terms)) {
                        terms = [terms];
                    }

                    // Preparar una expresión regular que identifique si estamos dentro de una etiqueta HTML
                    const htmlTagRegex = /<\/?[^>]+>/gi;

                    // Esta función de reemplazo verifica si el término está dentro de una etiqueta HTML
                    function replacementFunction(match, offset, fullText) {
                        // Encuentra todos los tags en el texto
                        let tagMatch;
                        let isInTag = false;
                        while ((tagMatch = htmlTagRegex.exec(fullText)) !== null) {
                            const tagStart = tagMatch.index;
                            const tagEnd = tagMatch.index + tagMatch[0].length;
                            if (offset >= tagStart && offset < tagEnd) {
                                // Si el match está dentro de un tag, marcamos isInTag como verdadero y rompemos el ciclo
                                isInTag = true;
                                break;
                            }
                        }

                        // Si el match está dentro de un tag, lo devuelve sin modificarlo
                        if (isInTag) {
                            return match;
                        } else {
                            // Si no está dentro de un tag, aplica el resaltado
                            return `<span class="highlight-text">${match}</span>`;
                        }
                    }

                    // Resalta cada término
                    terms.forEach(term => {
                        const regex = new RegExp(term, 'gi');
                        text = text.replace(regex, replacementFunction);
                    });

                    return text;
                },

                escapeRegExp(string) {
                    return string.replace(/[.*+?^${ }()|[\]\\]/g, '\\$&'); // Escapa caracteres especiales para regex
                },

                replaceMatches() {
                    if (!this.searchQuery || !this.replaceText) {
                        alert("Por favor, completa ambos campos de búsqueda y reemplazo.");
                        return;
                    }

                    // Utiliza el método escapeRegExp correctamente llamado con 'this.'
                    const regex = new RegExp(this.escapeRegExp(this.searchQuery), 'gi');

                    this.model.forEach((block) => {
                        if (regex.test(block.content)) {
                            // Reemplaza todas las coincidencias en el contenido del bloque
                            const updatedContent = block.content.replace(regex, this.replaceText);

                            // Llama a updateModelBlockContent para cada bloque afectado
                            // Esto asegurará que todos los campos dependientes se actualicen adecuadamente
                            this.updateModelBlockContent(block.id, updatedContent);
                        }
                    });

                    // Limpia los campos de búsqueda y reemplazo después del proceso
                    this.searchQuery = '';
                    this.replaceText = '';

                    // Opcionalmente, puedes llamar a otros métodos si es necesario actualizar la UI o el estado global
                },

                prepareMarkers() {
                    const markers = {};
                    if (this.metamodel.markers && Array.isArray(this.metamodel.markers)) {
                        this.metamodel.markers.forEach((marker) => {
                            // Asegúrate de que marker.name existe y es una cadena válida
                            if (marker.name && typeof marker.name === 'string') {
                                if (!markers[marker.name]) {
                                    markers[marker.name] = new Set(); // Usa un Set para evitar valores duplicados
                                }
                                // Verifica si marker.values es una cadena y conviértela en un arreglo si es necesario
                                const values = typeof marker.values === 'string' ? marker.values.split(',') : marker.values;
                                // Asegúrate de que values sea un arreglo antes de intentar iterar sobre él
                                if (Array.isArray(values)) {
                                    values.forEach(value => markers[marker.name].add(value.trim())); // Usa trim para eliminar espacios en blanco al inicio y al final
                                } else {
                                    // Si marker.values no es un arreglo ni una cadena, muestra una advertencia
                                    console.warn(`Expected marker.values to be an array or a string, got:`, typeof marker.values, marker.values);
                                }
                            }
                        });
                    }

                    // Convierte los sets a arrays y elimina espacios en blanco de los valores
                    for (const markerName in markers) {
                        markers[markerName] = Array.from(markers[markerName]);
                    }
                    return markers;
                },

                toggleMarkerSelection(markerValue) {
                    const index = this.selectedMarkers.indexOf(markerValue);
                    if (index > -1) {
                        // El marcador ya está seleccionado, quitarlo del array
                        this.selectedMarkers.splice(index, 1);
                    } else {
                        // El marcador no está seleccionado, añadirlo al array
                        this.selectedMarkers.push(markerValue);
                    }

                    // Opcional: Puedes llamar aquí al método que actualiza el filtro de bloques si deseas que los bloques se actualicen inmediatamente después de cambiar la selección.
                    // this.updateBlocksFilter();
                },

                updateFilter(selectedMarker) {
                    // Aquí puedes implementar la lógica para filtrar los bloques basándose en el marcador seleccionado.
                    // Por ejemplo, podrías ajustar la propiedad 'filteredBlocks' para que solo incluya bloques que coincidan con el marcador seleccionado.
                    this.filteredBlocks = this.model.filter(block => {
                        // Suponiendo que 'block.markers' es un array de marcadores asociados con el bloque
                        return block.markers.includes(selectedMarker);
                    });
                },

                // FORMATING

                // ARTIFACTS

                // Método para cambiar a la sección "Guides" y cargar una guía específica por URL
                activateGuidesAndLoadGuide(url) {
                    // Cambia la sección activa del sidebar a "Guides"
                    this.changeSidebar('guides');

                    // Espera un momento para asegurar que la interfaz se haya actualizado
                    this.$nextTick(() => {
                        // Carga la guía especificada por la URL
                        this.loadGuideMarkdownContent(url);
                    });
                },

                async loadGuideMarkdownContent(url) {
                    if (url) {
                        try {
                            const response = await fetch(url);
                            const markdown = await response.text();
                            // Aquí convertirías el Markdown a HTML
                            // Puedes usar la librería marked.js como antes mencioné
                            this.markdownGuideContent = marked.parse(markdown);
                        } catch (error) {
                            /// console.log("🚀 ~ loadGuideMarkdownContent ~ error:", error)
                            this.markdownContent = '';
                        }
                    } else {
                        this.markdownGuideContent = '';
                    }
                },

                setArtifactBusinessModelCanvas() {
                    this.isArtifactModalOpen = true;
                },

                // DOWNLOAD AND EXPORT

                downloadMarkdown() {
                    this.updateModelMarkdown(); // Actualiza el contenido Markdown
                    const markdownContent = this.modelMarkdown; // Obtén el contenido actual
                    const fileName = this.generateFileName(); // Usa el mismo método para generar el nombre del archivo

                    // Crea un Blob con el contenido Markdown
                    const blob = new Blob([markdownContent], { type: 'text/markdown' });

                    // Crea un enlace para descargar el archivo
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName;

                    // Simula un clic en el enlace para iniciar la descarga y luego limpia
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },

                processLoadedMarkdown() {
                    if (!this.newMarkdownContent) {
                        console.error("No hay contenido de Markdown para cargar.");
                        return;
                    }

                    // Simula la carga y el procesamiento del contenido Markdown
                    this.parseModelMarkdown(this.newMarkdownContent);
                },

                processNewContent() {
                    // Resetear model a un array vacío
                    this.model = [];
                    this.resetDepthCounters();
                    const content = this.newMarkdownContent;
                    // Aquí debes invocar la lógica que normalmente usas para procesar el contenido Markdown cargado.
                    // Por ejemplo, si tienes un método que parsea el Markdown a bloques del modelo, úsalo aquí.
                    this.parseModelMarkdown(content);
                },

                downloadHTML() {
                    // Configurar un renderer personalizado para agregar IDs a los encabezados
                    const renderer = new marked.Renderer();

                    // Sobrescribir la función heading para agregar los IDs automáticamente
                    renderer.heading = function (text, level) {
                        const slug = marked.slugger().slug(text); // Crear un slug basado en el texto del encabezado
                        return `<h${level} id="${slug}">${text}</h${level}>\n`;
                    };

                    // Establecer el renderer personalizado en Marked
                    marked.setOptions({ renderer });

                    // Convierte el Markdown a HTML usando el renderer con IDs en los headings
                    this.updateModelMarkdown();
                    const htmlContent = marked.parse(this.modelMarkdown);

                    const { modelName } = this; // Obtiene el nombre actual del modelo
                    const timestamp = new Date().toISOString().replace(/[:-]|\.\d{3}/g, ''); // Genera un timestamp en el formato deseado
                    const fileName = `${modelName} - saved ${timestamp}.html`; // Construye el nombre del archivo

                    // Opcional: Si quieres incluir un estilo básico en tu HTML exportado, puedes agregarlo aquí
                    const htmlWithStyle = `
        <!DOCTYPE html>
        <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Plastilinn</title>
                <link rel="stylesheet" href="https://stackedit.io/style.css" />
                <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
                <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
            </head>
            <body>
            <script>
                // Esto se ejecuta automáticamente cuando se carga la página
                window.onload = function() {
                    alert("Copy the page content and paste it on your text editor");
                };
            <\/script>
            <style>
                h1,
                h2,
                h3,
                h4,
                h5,
                h6 {
                    all: unset;
                    font-size: 2rem !important;
                    font-weight: 700 !important;
                    margin-bottom: 16px !important;
                    display: block !important;
                }
            </style>
            ${htmlContent}
            </body>
        </html>
    `;

                    // Crea un Blob con el contenido HTML
                    const blob = new Blob([htmlWithStyle], { type: 'text/html' });

                    // Crea un enlace para descargar el archivo
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName; // Puedes personalizar el nombre del archivo

                    // Simula un clic en el enlace para iniciar la descarga y luego limpia
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },

                toggleAutoDownload() {
                    this.autoDownloadEnabled = !this.autoDownloadEnabled;
                },

            },
            mounted() {
                this.processLicense();
                this.processMetamodel(); // Otras inicializaciones pueden ir aquí
                this.highlightOnLoad(); // Resalta el elemento si la página se cargó con un hash.
                window.addEventListener('hashchange', this.highlightOnLoad);
                // Configura marked.js para este componente
                marked.setOptions({
                    gfm: true, // Habilita GitHub Flavored Markdown (GFM)
                    breaks: true, // Convierte los saltos de línea simples en <br>
                });
                // Cargar la guía "Plastilinn documentation" al cargar la página
                this.currentSidebarSection = 'guides'; // Cambia la sección activa a 'guides'
                const guideUrl = 'https://xbokmd.github.io/plastilinn/docs/guides/plastilinn_documentation.md';
                this.loadGuideMarkdownContent(guideUrl); // Cargar la guía directamente

                // Agregar el listener cuando el componente esté montado
                this.addBeforeUnloadListener();
            },

            beforeUnmount() {
                // Eliminar el listener antes de que el componente sea destruido
                this.removeBeforeUnloadListener();
            }
        })
            .mount('#vue-app');
    </script>
</body>

</html>