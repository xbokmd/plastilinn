<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web App</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <style>
        .md-line {
            display: flex;
            /* o display: grid; dependiendo de tu estructura */
            gap: 10px;
            /* Ajusta este valor seg√∫n lo necesites */
        }
    </style>

</head>

<body class="bg-gray-100">
    <div id="top-container">
        <div class="navbar bg-base-100">
            <div class="flex-1">
                <a class="btn btn-ghost text-xl">Plastilinn</a>
            </div>
            <div class="flex items-center space-x-3">
            </div>
            <div style="display: flex; justify-content: center;">
                <div class="flex space-x-3">
                    <div class="grid grid-cols-3 gap-4">
                        <div class="flex items-center space-x-3" style="justify-content: flex-end;">
                        </div>
                        <div class="flex space-x-3" style="justify-content: center;">
                            <button
                                class="collapse-filter-button btn border-blue-500 text-blue-500 bg-white hover:bg-blue-500 hover:text-white px-4 py-2 rounded-md transition"" type="
                                button">
                                üîç Filter
                            </button>
                        </div>
                        <div class="flex items-center justify-end space-x-3" style="justify-content: flex-start;">
                            <button id="downloadBtn"
                                class="btn border-blue-500 text-blue-500 bg-white hover:bg-blue-500 hover:text-white px-4 py-2 rounded-md transition">‚¨áÔ∏è
                                Download</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="flex-none">
                <ul class="menu menu-horizontal px-1">
                    <li><a>App</a></li>
                    <li><a>Docs</a></li>
                    <li><a>About</a></li>
                </ul>
            </div>
        </div>
    </div>
    <div id="model-title" class="text-center mt-6">
        <!-- El nombre del modelo se mostrar√° aqu√≠ -->
    </div>
    <div class="mt-4 w-4/5 mx-auto">
        <div class="collapse-filter-content hidden ">
            <select class="select select-bordered w-full" id="tagsFilter" multiple>
                <!-- Opciones del filtro ser√°n generadas din√°micamente -->
            </select>
        </div>
    </div>
    <div id="markdownContainer" class="mt-4 ml-2 mr-2 text-gray-900 min-h-screen">
        <div class="hero min-h-screen bg-base-200">
            <div class="hero-content text-center">
                <div class="max-w-md">
                    <input type="file" id="markdownFileInput" accept=".md"
                        class="file-input file-input-bordered file-input-primary w-full max-w-xs m-4">
                    <p>If you don't have a plastilinn document yet, download an empty <a
                            href="plastilinn document template.md" download="Plastilinn document template.md"
                            target="_blank">plastilinn document template</a></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let metamodel = [];
        let model = []; // Tambi√©n aseguramos que `model` est√© definido globalmente

        // Crea un handler para el proxy, similar al que ya tienes para `model`
        let metamodelHandler = {
            get: function (target, property, receiver) {
                if (['push', 'pop', 'shift', 'unshift', 'splice'].includes(property)) {
                    return function (...args) {
                        console.log(`Metamodel: M√©todo ${property} llamado con argumentos`, args);
                        // L√≥gica personalizada antes de la llamada original
                        const result = Array.prototype[property].apply(target, args);
                        // L√≥gica personalizada despu√©s de la llamada original
                        console.log(`Metamodel despu√©s de ${property}:`, target);
                        return result; // Retorna el resultado del m√©todo original
                    };
                }
                return Reflect.get(...arguments);
            },

            set: function (target, property, value, receiver) {
                console.log(`Metamodel: Cambio detectado en propiedad ${property} actualizada con`, value);
                target[property] = value; // Actualiza el array original
                // L√≥gica adicional despu√©s de actualizar el array
                return true; // Indica que la propiedad fue exitosamente establecida
            }
        };

        // Envuelve el array metamodel con el Proxy, pasando el array original y el handler
        metamodel = new Proxy(metamodel, metamodelHandler);

        // Crea un manejador para el proxy
        let handler = {
            get: function (target, property, receiver) {
                // Verificar si la propiedad es un m√©todo que queremos interceptar
                if (['push', 'pop', 'shift', 'unshift', 'splice'].includes(property)) {
                    return function (...args) {
                        console.log(`M√©todo ${property} llamado con argumentos`, args);
                        // L√≥gica personalizada antes de la llamada original
                        // Por ejemplo, podr√≠as hacer algo antes de modificar el array

                        // Llama al m√©todo original del array
                        const result = Array.prototype[property].apply(target, args);

                        // L√≥gica personalizada despu√©s de la llamada original
                        // Por ejemplo, podr√≠as actualizar la UI, enviar notificaciones, etc.
                        console.log(`Array despu√©s de ${property}:`, target);

                        return result; // Retorna el resultado del m√©todo original
                    };
                }

                // Para propiedades que no son m√©todos que queremos interceptar, simplemente retorna el valor original
                return Reflect.get(...arguments);
            },

            set: function (target, property, value, receiver) {
                console.log(`Cambio detectado en model: propiedad ${property} actualizada con`, value);
                target[property] = value; // Actualiza el array original
                // L√≥gica adicional despu√©s de actualizar el array
                return true; // Indica que la propiedad fue exitosamente establecida
            }
        };

        // Envuelve el array model con el Proxy, pasando el array original y el manejador
        model = new Proxy(model, handler);

        let uniqueId = 0; // Al inicio de tu script o fuera de cualquier funci√≥n para que sea global
        let modelName = ''; // Esta variable almacenar√° el nombre del archivo cargado

        function downloadJSON() {
            axios.get('https://xbokmd.github.io/plastilinn/metamodel.json')
                .then(function (response) {
                    // Asumiendo que response.data contiene tanto 'classes' como 'sections'
                    if (response.data && Array.isArray(response.data.classes) && Array.isArray(response.data.sections)) {
                        // Guarda las clases y las secciones en diferentes propiedades de metamodel
                        metamodel.classes = response.data.classes;
                        metamodel.sections = response.data.markers;
                        metamodel.sections = response.data.sections;
                        console.log(metamodel); // Muestra el metamodelo en la consola
                        initializeApp(); // Ejemplo de funci√≥n de inicializaci√≥n
                    } else {
                        console.error('Metamodel received does not have the expected structure');
                    }
                })
                .catch(function (error) {
                    console.log(error); // Maneja el error
                });
        }

        // Definir la funci√≥n initializeApp o cualquier otra l√≥gica que dependa de metamodel
        function initializeApp() {
            // Configuraciones o llamadas a funciones que dependen de que metamodel est√© listo
            setupMarkdownFileInput();
            // Cualquier otra inicializaci√≥n que necesite metamodel
        }

        // Llamar a downloadJSON al inicio para cargar metamodel
        downloadJSON();

        function setupMarkdownFileInput() {
            const markdownFileInput = document.getElementById('markdownFileInput');
            const markdownContainer = document.getElementById('markdownContainer');

            markdownFileInput.addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    // Extrae el nombre del archivo sin la extensi√≥n '.md'
                    let baseName = file.name.replace('.md', '');

                    // Busca la posici√≥n de " - saved" en el nombre del archivo
                    let savedIndex = baseName.indexOf(' - saved');

                    // Si " - saved" se encuentra en el nombre, recorta hasta ese punto
                    if (savedIndex !== -1) {
                        baseName = baseName.substring(0, savedIndex);
                    }

                    modelName = baseName; // Asigna el nombre modificado a modelName
                    updateModelNameDisplay(); // Actualiza la visualizaci√≥n del nombre
                    const content = e.target.result;
                    const lines = content.split(/\r?\n/);
                    model = _.map(lines, (line, index) => {
                        // Extracci√≥n de etiquetas
                        const rawTags = line.match(/#[^\s#]+/g) || [];
                        const tags = rawTags.map(tag => {
                            const tagName = tag.substring(1); // Simplemente elimina el s√≠mbolo '#' al principio
                            return { raw: tag, className: tagName };
                        });

                        // Intentar identificar y procesar t√≠tulos con nueva especificaci√≥n
                        let title = undefined;
                        // La expresi√≥n regular ahora permite espacios/guiones al inicio y busca de 2 a 10 hashes
                        const headingMatch = line.match(/^\s*-*\s*#{2,10}\s*(.*)/);
                        if (headingMatch && headingMatch[1]) {
                            // Limpiar el t√≠tulo: elimina hashes y espacios iniciales, mantiene texto despu√©s de los hashes
                            title = headingMatch[1].trim();
                            // Eliminar etiquetas del t√≠tulo si es necesario
                            title = title.replace(/#[^\s#]+/g, '').trim();
                            title = title.replace(/\[\[|\]\]/g, '');
                        }

                        return {
                            id: uniqueId++, // Incrementa el ID √∫nico para cada objeto del modelo
                            content: line,
                            tags: tags,
                            index: index,
                            title: title // Agregado condicionalmente, undefined si no es un t√≠tulo
                        };
                    });

                    // Luego de definir tu modelo, actualiza las etiquetas de cada l√≠nea
                    model.forEach(lineData => {
                        // Encuentra el tagsContainer correspondiente para esta l√≠nea
                        // Esto puede requerir que ajustes c√≥mo identificas o accedes a cada tagsContainer
                        // Por ejemplo, si cada l√≠nea tiene un ID √∫nico y puedes usarlo para encontrar su tagsContainer
                        const tagsContainer = document.querySelector(`#tags-container-${lineData.id}`);
                        if (tagsContainer) {
                            const cleanedTags = lineData.tags.map(tag => tag.className); // Asume que ya has limpiado las etiquetas
                            updateTagsContainer(tagsContainer, cleanedTags);
                        }
                    });

                    updateTagsFilter();
                    renderModel(); // Aseg√∫rate de ajustar esta funci√≥n para manejar "title"
                };
                reader.readAsText(file);
            });

            document.querySelector('.collapse-filter-button').addEventListener('click', function () {
                const content = document.querySelector('.collapse-filter-content');
                // Alternar la clase 'hidden' para mostrar/ocultar el contenido
                content.classList.toggle('hidden');
            });




function createAndAppend(elementType, attributes = {}, parent = null) {
    const element = document.createElement(elementType);
    Object.keys(attributes).forEach(attr => {
        if (attr === 'className') {
            element.className = attributes[attr];
        } else if (attr === 'textContent') {
            element.textContent = attributes[attr];
        } else {
            element.setAttribute(attr, attributes[attr]);
        }
    });
    if (parent) {
        parent.appendChild(element);
    }
    return element;
}

function handleInputEvent(lineData) {
    return function () {
        const updatedContent = this.value;
        lineData.content = updatedContent; // Update content in model directly

        const rawTags = updatedContent.match(/#[^\s#]+/g) || [];
        const cleanedTags = rawTags.map(tag => tag.substring(1));

        const tagsContainer = this.closest('.md-line').querySelector('.tags-container');
        if (tagsContainer) {
            updateTagsContainer(tagsContainer, cleanedTags);
        }

        updateTagsFilter();
    };
}

function renderModel(linesToRender = model) {
    console.log("L√≠neas a renderizar:", linesToRender);

    const markdownContainer = document.getElementById('markdownContainer');
    markdownContainer.innerHTML = '';

    const mainContainer = createAndAppend('div', {className: 'flex flex-col'}, markdownContainer);

    linesToRender.forEach(lineData => {
        const rowWrapperDiv = createAndAppend('div', {className: 'md-line-wrapper'}, mainContainer);

        const lineContainer = createAndAppend('div', {className: 'flex flex-row md-line'}, rowWrapperDiv);

        if (lineData.title) {
            const titleContainer = createAndAppend('div', {
                className: 'text-center p-2 custom-flex-1 chat chat-bubble chat-end'
            }, lineContainer);

            const titleLink = createAndAppend('a', {
                href: getSectionInfo(lineData.title),
                target: '_blank',
                textContent: lineData.title,
                className: 'text-blue-500 hover:text-blue-800'
            }, titleContainer);

            const modalOpenButton = createAndAppend('button', {
                textContent: 'ü§ñ AI magic',
                className: 'btn ai-magic-button py-1'
            }, titleContainer);
            modalOpenButton.addEventListener('click', () => openModalWithSectionName(lineData.title));
        } else {
            createAndAppend('div', {className: 'text-center p-2 custom-flex-1'}, lineContainer);
        }

        const contentContainer = createAndAppend('div', {
            className: 'text-center shadow-xl hover:shadow-2xl transition-shadow p-2 ml-2 mr-2 custom-flex-2'
        }, lineContainer);

        const textareaElement = createAndAppend('textarea', {
            className: 'md-line-content text-left bg-white shadow-2x1 md:col-span-3',
            'data-id': lineData.id,
            textContent: lineData.content
        }, contentContainer);
        textareaElement.addEventListener('input', handleInputEvent(lineData));

        const tagsElement = createAndAppend('div', {
            className: 'tags-container ext-gray-500 text-sm text-center p-2 custom-flex-3'
        }, lineContainer);

        const cleanedTags = lineData.tags.map(tag => tag.className.replace(/^#/, ''));
        updateTagsContainer(tagsElement, cleanedTags);
    });
}




            function setupEditableContent(contentElement) {
                const editIndicator = document.createElement('span');
                editIndicator.className = 'text-gray-400 text-xl cursor-pointer absolute right-0 mr-4 opacity-0';
                editIndicator.textContent = '‚úèÔ∏è';
                contentElement.parentNode.appendChild(editIndicator);

                contentElement.addEventListener('focus', function () {
                    this.classList.add('border', 'border-blue-500', 'rounded', 'p-1');
                });
                contentElement.addEventListener('blur', function () {
                    this.classList.remove('border', 'border-blue-500', 'rounded', 'p-1');
                });
                contentElement.addEventListener('mouseenter', function () {
                    editIndicator.style.opacity = '1';
                });
                contentElement.addEventListener('mouseleave', function () {
                    editIndicator.style.opacity = '0';
                });
            }
            document.getElementById('tagsFilter').addEventListener('change', filterLinesBySelectedTags);

            function updateTagsForLine(tagsContainer, content) {
                // Limpia el contenedor de etiquetas existente
                tagsContainer.innerHTML = '';

                // Extrae las etiquetas del contenido. Este paso depende de c√≥mo identifiques las etiquetas en el texto.
                // Por ejemplo, si las etiquetas son palabras precedidas por '#', podr√≠as hacer algo como esto:
                const tagRegex = /#\w+/g; // Encuentra todas las ocurrencias de '#palabra'
                const tags = content.match(tagRegex) || [];

                // Crea elementos visuales para cada etiqueta encontrada y los a√±ade al contenedor
                tags.forEach(tag => {
                    const tagElement = document.createElement('span'); // O cualquier elemento que represente una etiqueta en tu UI
                    tagElement.textContent = tag; // Establece el texto del elemento al tag encontrado
                    tagsContainer.appendChild(tagElement); // A√±ade el elemento de etiqueta al contenedor
                });
            }

            function filterLinesBySelectedTags() {
                // Obtener todas las etiquetas seleccionadas del select m√∫ltiple
                const selectedTags = Array.from(document.getElementById('tagsFilter').selectedOptions).map(option => option.value);

                // Obtener todos los elementos que representan las l√≠neas de contenido
                const wrappers = document.querySelectorAll('.md-line-wrapper');

                // Iterar sobre cada wrapper
                wrappers.forEach(wrapper => {
                    // Busca dentro del wrapper si existe alguna etiqueta que coincida con las seleccionadas
                    const tagsInLine = wrapper.querySelectorAll('.tags-container span');
                    let tagFound = false;

                    // Verificar si alguna de las etiquetas de la l√≠nea coincide con las seleccionadas
                    tagsInLine.forEach(tagElement => {
                        if (selectedTags.includes(tagElement.textContent)) {
                            tagFound = true;
                        }
                    });

                    // Si se encuentra alguna etiqueta o si no se ha seleccionado ninguna (valor ''), muestra el wrapper
                    if (tagFound || selectedTags.length === 0) {
                        wrapper.classList.remove('hidden');
                    } else {
                        // En caso contrario, oculta el wrapper
                        wrapper.classList.add('hidden');
                    }
                });
            }

            document.addEventListener('DOMContentLoaded', function () {

                document.getElementById('tagsFilter').addEventListener('change', filterLinesBySelectedTags);
            });

            document.addEventListener('input', function (e) {
                if (e.target.classList.contains('md-line-content')) {
                    const updatedContent = e.target.value;

                    // Extraer etiquetas usando una expresi√≥n regular
                    const rawTags = updatedContent.match(/#[^\s#]+/g) || [];
                    const cleanedTags = rawTags.map(tag => tag.substring(1)); // Limpia las etiquetas quitando '#'

                    // Encuentra el contenedor de etiquetas correspondiente
                    const tagsContainer = e.target.closest('.md-line').querySelector('.tags-container');
                    if (tagsContainer) {
                        updateTagsContainer(tagsContainer, cleanedTags);
                    }
                }
            });

            document.getElementById('downloadBtn').addEventListener('click', downloadModel);

            function formatDate(date) {
                const year = date.getFullYear();
                const month = (`0${date.getMonth() + 1}`).slice(-2);
                const day = (`0${date.getDate()}`).slice(-2);
                const hours = (`0${date.getHours()}`).slice(-2);
                const minutes = (`0${date.getMinutes()}`).slice(-2);
                const seconds = (`0${date.getSeconds()}`).slice(-2);
                return `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
            }

            document.getElementById('downloadBtn').addEventListener('click', function () {
                const modelContent = generateModel(); // Esta funci√≥n deber√≠a generar el contenido a descargar
                // Genera el nombre del archivo usando modelName y la fecha actual para mantenerlo √∫nico
                const fileName = `${modelName || 'Business model'} - saved ${formatDate(new Date())}.md`;
                downloadFile(fileName, modelContent); // Llama a la funci√≥n downloadFile con el nuevo nombre
            });

            function downloadFile(fileName, content) {
                const element = document.createElement('a');
                element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
                element.setAttribute('download', fileName);

                element.style.display = 'none';
                document.body.appendChild(element);

                element.click();

                document.body.removeChild(element);
            }
        }

        function updateModelNameDisplay() {
            let modelNameDisplay = document.getElementById('modelNameDisplay');
            if (!modelNameDisplay) {
                modelNameDisplay = document.createElement('h1');
                modelNameDisplay.id = 'modelNameDisplay';
                // Encuentra el contenedor con id="model-title" para mostrar el nombre del modelo
                const container = document.getElementById('model-title');
                container.appendChild(modelNameDisplay); // A√±ade el h1 dentro del contenedor espec√≠fico
            }
            modelNameDisplay.textContent = modelName; // Actualiza el contenido del h1 con el nombre del modelo
        }

        function downloadModel() {
            let fileContent = model.map(obj => obj.content).join('\n'); // Concatena el contenido con saltos de l√≠nea
            const fileName = `Business model - saved ${formatDate(new Date())}.md`; // Usa la funci√≥n formatDate para crear un nombre de archivo √∫nico
            downloadFile(fileName, fileContent); // Llama a la funci√≥n downloadFile con el nombre del archivo y el contenido a descargar
        }

        function setupDownloadButton() {
            const downloadBtn = document.getElementById('downloadBtn');
            if (!downloadBtn) return; // Aseg√∫rate de que el elemento existe

            downloadBtn.addEventListener('click', downloadModel);
        }

        document.addEventListener('input', function (e) {
            if (e.target.getAttribute('contenteditable') === "true") {
                const id = parseInt(e.target.getAttribute('data-id'), 10); // Obtiene el ID como n√∫mero
                const editedContent = e.target.textContent;

                // Busca y actualiza el objeto correspondiente en `model`
                const lineObj = model.find(obj => obj.id === id);
                if (lineObj) {
                    lineObj.content = editedContent;
                }
            }
        });

        function generateModel() {
            const contentElements = document.querySelectorAll('.md-line-content');
            let modelContent = Array.from(contentElements).map(element => element.value).join('\n');
            // La siguiente l√≠nea es incorrecta y redundante, por lo que se ha eliminado
            // modelContent += textContent + '\n';
            return modelContent.trim();
        }

        function updateTagsFilter() {
            // Obtener todas las etiquetas √∫nicas de `model`
            const allTags = new Set(); // Usamos un Set para evitar etiquetas duplicadas
            model.forEach(item => {
                item.tags.forEach(tag => {
                    allTags.add(tag.className); // Suponiendo que `className` contiene el nombre de la etiqueta sin '#'
                });
            });

            // Convertir el Set a Array y ordenarlo alfab√©ticamente
            const sortedTags = Array.from(allTags).sort();

            // Obtener el elemento del selector
            const tagsFilter = document.getElementById('tagsFilter');
            // Limpiar opciones existentes
            tagsFilter.innerHTML = '';

            // Opci√≥n predeterminada
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'No filter';
            tagsFilter.appendChild(defaultOption);

            // Crear una opci√≥n para cada etiqueta √∫nica
            sortedTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagsFilter.appendChild(option);
            });
        }

        function openModalWithTextarea(textareaElement) {
            const modalBody = document.getElementById('textEditModalBody'); // Aseg√∫rate de tener este contenedor en tu modal
            window.originalTextareaParent = textareaElement.parentNode; // Guarda el contenedor original
            modalBody.appendChild(textareaElement); // Mueve el textarea a la modal

            document.getElementById('textEditModal').classList.add('modal-open'); // Abre la modal
        }

        function closeTextEditModal() {
            const modalContent = document.getElementById('textEditModalContent');
            if (window.currentTextarea) {
                // Aplica el contenido modificado al textarea original
                window.currentTextarea.value = modalContent.value;

                // Extrae las etiquetas del contenido actualizado
                const updatedTags = extractTags(modalContent.value);

                // Encuentra el contenedor de etiquetas relacionado con el textarea
                const tagsContainer = window.currentTextarea.closest('.md-line').querySelector('.tags-container');

                // Actualiza el contenedor de etiquetas utilizando la funci√≥n existente
                if (tagsContainer) {
                    updateTagsContainer(tagsContainer, updatedTags);
                }
            }
            // Cierra la ventana modal
            document.getElementById('textEditModal').classList.remove('modal-open');
        }

        function extractTags(content) {
            // Utiliza una expresi√≥n regular para encontrar todas las coincidencias de etiquetas
            const tagRegex = /#\w+/g;
            const tags = content.match(tagRegex) || [];
            return tags.map(tag => tag.substring(1)); // Elimina el hash del inicio de cada etiqueta
        }

        function closeModal() {
            // Obtiene el textarea del modal y el textarea original
            const modalContent = document.getElementById('generatedModelContent');
            const originalTextarea = document.getElementById('modalTitle').textareaElement;

            // Transfiere el contenido editado de vuelta al textarea original
            if (originalTextarea) {
                originalTextarea.value = modalContent.value;
            }

            // Cierra la modal
            document.getElementById('modalTitle').classList.remove('modal-open');
        }

        function updateTagsContainer(tagsContainer, tags) {
            // Limpia el contenedor de etiquetas actual
            tagsContainer.innerHTML = '';

            // A√±adir las nuevas etiquetas al contenedor
            tags.forEach(tag => {
                const tagSpan = document.createElement('span');
                // Asigna el valor de la etiqueta al atributo 'data-tag', asumiendo que 'tag' ya no tiene el '#'
                tagSpan.setAttribute('data-tag', tag);
                // Establece el texto visible del span como el valor de la etiqueta
                tagSpan.textContent = tag;
                tagsContainer.appendChild(tagSpan);

                // A√±adir un espacio despu√©s de cada etiqueta para separaci√≥n visual
                tagsContainer.appendChild(document.createTextNode(' '));
            });
        }

        function getSectionInfo(sectionTitle) {
            // Encuentra la entrada en metamodel que coincide con el t√≠tulo de la secci√≥n
            const metamodelEntry = metamodel.sections.find(entry => entry.name === sectionTitle);
            const infoUrl = metamodelEntry ? metamodelEntry.info : 'https://default.url';
            return infoUrl;
        }

        function getSectionExample(sectionTitle) {
            // Encuentra la entrada en metamodel que coincide con el t√≠tulo de la secci√≥n
            const metamodelEntry = metamodel.sections.find(entry => entry.name === sectionTitle);
            const infoUrl = metamodelEntry ? metamodelEntry.example : 'No example found';
            return infoUrl;
        }

        function openModalWithSectionName(sectionName) {
            // Encuentra el elemento que contiene el t√≠tulo en la ventana modal
            const modalTitleContent = document.getElementById('modalTitleContent');
            // Actualiza el contenido de este elemento con el nombre de la secci√≥n recibido
            modalTitleContent.textContent = sectionName;

            // Llama a generateModel para obtener el contenido actual del modelo
            const modelContent = generateModel();

            // Buscar en metamodel el campo example para la secci√≥n especificada
            const sectionExample = getSectionExample(sectionName);

            // Define el contenido deseado para el textarea usando plantillas literales
            const customContent = `As a business model design expert for startups, you specialize in refining business models through detailed, specific feedback and brainstorming tailored to each startup's unique aspects. Your role is to assist in drafting a document that accurately describes a business model, focusing on clear, structured, and relevant advice. Your approach involves:
            Listening closely to understand the specifics of the business.
            Providing concise, targeted guidance without unnecessary repetition or formalities.
            Offering step-by-step feedback to ensure the document effectively captures the business model.
            You focus on the client's needs and how to best articulate their business model.
            GOAL: Write a business model document describing the user's project business model. Here's some information about my Business:
                ${modelContent}
            MY QUESTION: Please suggest content for the "${sectionName}" section of the business model.
            WRITE your answer in PLASTILINN FORMAT, which consists of the text of the answer without any comments or similar, that closely adheres to the format and style of the plastilinn (taking the {block example} as a reference example of a properly formatted answer). In your responsse, each list component should begin with '#tag', followed by the name enclosed in double brackets '[[ ]]', and then a description on a new, indented line. This is an example of a answer:
            ---
            ${sectionExample}
            ---
            Copy answer in the text box below:
            ---
            \`\`\`
            ${sectionExample}
            \`\`\`
            ---
            - You can copy/paste this answer to a document, write 'copy' to have the answer in a text box or write ‚¨áÔ∏è 'download' to save this answer to your computer"
            `;

            // Encuentra el textarea dentro del modal y actualiza su contenido
            const generatedModelContent = document.getElementById('generatedModelContent');
            generatedModelContent.value = customContent;

            // Abre la ventana modal a√±adiendo la clase 'modal-open'
            document.getElementById('modalTitle').classList.add('modal-open');
        }

        function closeModal() {
            document.getElementById('modalTitle').classList.remove('modal-open'); // Cierra el modal
        }

        document.addEventListener('input', function (e) {
            if (e.target.classList.contains('md-line-content')) {
                const updatedContent = e.target.value;
                const id = parseInt(e.target.getAttribute('data-id'), 10); // Aseg√∫rate de que este atributo est√© correctamente asignado

                // Encuentra el objeto en `model` con el ID correspondiente y actualiza su `content`
                const index = model.findIndex(obj => obj.id === id);
                if (index !== -1) {
                    model[index].content = updatedContent; // Esta l√≠nea deber√≠a disparar el proxy si model es un proxy
                    console.log(`Contenido actualizado para ID ${id}: `, updatedContent);
                }
            }
        });

        // Esta funci√≥n extrae etiquetas del contenido y elimina el s√≠mbolo '#'
        function extractTagsFromContent(content) {
            // Ajuste de la expresi√≥n regular para incluir caracteres especiales como * y %
            const tagRegex = /#\w+/g;
            const tags = content.match(tagRegex) || [];
            return tags.map(tag => tag.substring(1)); // Elimina el '#' del inicio de cada etiqueta
        }

        document.addEventListener('DOMContentLoaded', function () {
            downloadJSON();
            setupMarkdownFileInput();
            setupDownloadButton();

            document.querySelectorAll('.md-line-content').forEach(textarea => {
                console.log('Textarea encontrado:', textarea); // Confirma que los textareas est√°n siendo seleccionados.

                textarea.addEventListener('focus', function () {
                    console.log('Focused'); // Confirma que el evento focus se dispara.
                    this.style.height = "400px"; // Ajusta la altura a 400px al enfocar.
                });

                textarea.addEventListener('blur', function () {
                    console.log('Blurred'); // Confirma que el evento blur se dispara.
                    this.style.height = "2em"; // Vuelve a la altura m√≠nima al perder el foco.
                });
            });
        });

        function copyToClipboard() {
            // Obt√©n el elemento textarea
            const textarea = document.getElementById('generatedModelContent');
            // Selecciona el contenido del textarea
            textarea.select();
            textarea.setSelectionRange(0, 99999); // Para dispositivos m√≥viles

            // Copia el texto seleccionado al portapapeles
            document.execCommand('copy');

            // Opcional: mostrar una notificaci√≥n o mensaje al usuario indicando que el texto ha sido copiado
        }

    </script>

    <div id="modalTitle" class="modal" tabindex="-1">
        <div class="modal-box">
            <h3 class="font-bold text-lg" id="modalTitleContent">T√≠tulo del Modelo</h3>
            <textarea id="generatedModelContent" class="textarea textarea-bordered w-full mt-4"
                placeholder="Aqu√≠ aparecer√° el contenido del modelo generado..."></textarea>
            <div class="modal-action">
                <button class="btn" onclick="copyToClipboard()">Copy content suggestion prompt</button>
            </div>
            <p class="py-4">Paste in <a href="https://chat.openai.com/" target="_blank">ChatGPT</a> or <a
                    href="https://gemini.google.com/app" target="_blank">Gemini Pro</a></p>
            <div class="modal-action">
                <a href="#" class="btn" onclick="closeModal()">close</a>
            </div>
        </div>
    </div>
</body>
</html>