<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web App con Pestañas</title>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <!-- Bootstrap Icons para usar iconos si es necesario -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
  </head>
<body class="container py-5">
    <h2 class="mb-4">Model Information</h2>

    <!-- Pestañas actualizadas para Bootstrap 5 -->
    <ul class="nav nav-tabs" id="myTab" role="tablist">
      <li class="nav-item" role="presentation">
          <button class="nav-link active" id="model-tab" data-bs-toggle="tab" data-bs-target="#model" type="button" role="tab" aria-controls="model" aria-selected="true">Model</button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="metaModel-tab" data-bs-toggle="tab" data-bs-target="#metaModel" type="button" role="tab" aria-controls="metaModel" aria-selected="true">Metamodel</button>
    </li>
    <li class="nav-item" role="presentation">
      <button class="nav-link" id="memory-tab" data-bs-toggle="tab" data-bs-target="#memory" type="button" role="tab" aria-controls="memory" aria-selected="false">Memory</button>
  </li>
    </ul>

  <!-- Contenido de las pestañas para Bootstrap 5 -->
  <div class="tab-content" id="myTabContent">
      <div class="tab-pane fade" id="model" role="tabpanel" aria-labelledby="model-tab">
          <input type="file" id="markdownFileInput" accept=".md">
          <!-- Botón de Descarga -->
          <button id="downloadBtn" class="btn btn-primary">Download</button>
          <div class="mb-3">
            <label for="tagsFilter" class="form-label">Filter by tags:</label>
            <select class="form-select" id="tagsFilter" multiple>
                <!-- Las opciones se llenarán dinámicamente con JavaScript -->
            </select>
          </div>
          <div id="markdownContent"></div>
      </div>
      <div class="tab-pane fade show active" id="metaModel" role="tabpanel" aria-labelledby="metaModel-tab">
        <div id="sections"></div>
      </div>

      <div class="tab-pane fade" id="memory" role="tabpanel" aria-labelledby="memory-tab">
        <div id="markdown-lines"></div>
        -------------------------------------
        <div id="sectionsTableContainer"></div>
      </div>
  </div>

  <!-- Bootstrap Bundle con Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Marked.js para procesar Markdown -->
  <script src="https://cdn.jsdelivr.net/npm/marked@12.0.0/lib/marked.umd.min.js"></script>

<!-- script metamodel -->
    <script>
function createSectionsTable(sections) {
    const table = document.createElement('table');
    table.className = 'table';

    // Crear cabecera de la tabla
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');

    // Suponiendo que todos los objetos tienen las mismas claves, usar el primer objeto para determinarlas
    if (sections.length > 0) {
        Object.keys(sections[0]).forEach(key => {
            const headerCell = document.createElement('th');
            headerCell.textContent = key; // Usar cada clave como nombre de columna
            headerRow.appendChild(headerCell);
        });
    }

    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Crear cuerpo de la tabla
    const tbody = document.createElement('tbody');

    sections.forEach(section => {
        const row = document.createElement('tr');
        Object.values(section).forEach(value => {
            const cell = document.createElement('td');
            cell.textContent = value; // Usar cada valor como contenido de la celda
            row.appendChild(cell);
        });
        tbody.appendChild(row);
    });

    table.appendChild(tbody);

    // Agregar la tabla al contenedor
    const container = document.getElementById('sectionsTableContainer');
    container.innerHTML = ''; // Limpiar contenido previo
    container.appendChild(table);
}


        document.addEventListener('DOMContentLoaded', () => {
          fetch('https://xbokmd.github.io/plastilinn/metamodel.json')
          .then(response => response.json())
          .then(data => {
              // Suponiendo que 'sections' es una clave en tu JSON
              createSectionsTable(data.sections);
              writeToDiv(data.sections); // Añade esta línea para escribir en el div
          })
          .catch(error => console.error('Error loading the JSON:', error));
      });

        function writeToDiv(sections) {
          const sectionsDiv = document.getElementById('sections');
          sectionsDiv.innerHTML = ''; // Limpiar contenido previo

          // Crear y añadir cada nombre de sección como un párrafo (o cualquier otro elemento) al div
          sections.forEach(section => {
              const paragraph = document.createElement('p');
              paragraph.textContent = section.name; // Asume que cada sección tiene un atributo 'name'
              sectionsDiv.appendChild(paragraph);
          });
}
    </script>

<!-- script model 2-->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const markdownInput = document.getElementById('markdownFileInput');
    const markdownLinesDiv = document.getElementById('markdown-lines');
    let sections = []; // Este array debe contener los nombres de las secciones

    // Carga los nombres de las secciones desde el JSON
    fetch('https://xbokmd.github.io/plastilinn/metamodel.json')
    .then(response => response.json())
    .then(data => {
        // Asume que data.sections contiene tus secciones y que cada sección tiene un atributo 'name'
        sections = data.sections.map(section => section.name);
        // Ahora sections contiene los nombres de todas tus secciones
    })
    .catch(error => console.error('Error al cargar los nombres de las secciones:', error));

    markdownInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (!file) {
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            const lines = content.split(/\r?\n/);
            markdownLinesDiv.innerHTML = ''; 

            markdownLinesDiv.style.display = 'grid';
            markdownLinesDiv.style.gridTemplateColumns = '1fr 1fr';
            markdownLinesDiv.style.gap = '10px';

            lines.forEach((line, index) => {
                const result = processModelTitle(line, index); // Añade el índice como argumento

                const titleDiv = document.createElement('div');
                titleDiv.innerHTML = `Title: ${result.title}, Section: ${result.isSection}`;

                const lineTextarea = document.createElement('textarea');
                lineTextarea.value = line;
                lineTextarea.style.width = '100%';
                lineTextarea.oninput = function() {
                    // Actualiza dinámicamente al editar
                    const update = processModelTitle(this.value, index);
                    titleDiv.innerHTML = `Title: ${update.title}, Section: ${update.isSection}`;
                };

                markdownLinesDiv.appendChild(titleDiv);
                markdownLinesDiv.appendChild(lineTextarea);

                if (result.modalId && result.sectionData) {
                    // Crear y añadir el modal correspondiente
                    const modal = createModal(result.modalId, result.sectionData);
                    document.body.appendChild(modal); // Añade el modal al body
                }
            });
        };
        reader.readAsText(file);
    });

    function processModelTitle(line, index) {
        let title = line.replace(/^[\s-]*/, '')
                        .replace(/#\S+/g, '')
                        .replace(/#+/g, '')
                        .replace(/\[\[/g, '')
                        .replace(/\]\]/g, '')
                        .trim();
        let matchingSection = sections.find(section => section === title);
        let isSection = matchingSection ? "Yes" : "No";
        let modalId = `sectionModal-${index}`;

        if (isSection === "Yes") {
            // Encuentra los datos de la sección
            let sectionData = sections.find(section => section === title);
            return { title, isSection: `<a href="#" data-bs-toggle="modal" data-bs-target="#${modalId}">Section</a>`, modalId, sectionData: matchingSection };
        } else {
            return { title, isSection, modalId: null, sectionData: null };
        }
    }

    function createModal(modalId, sectionData) {
        const modalDiv = document.createElement('div');
        modalDiv.id = modalId;
        modalDiv.className = 'modal fade';
        modalDiv.setAttribute('tabindex', '-1');
        modalDiv.setAttribute('role', 'dialog');
        modalDiv.innerHTML = `
            <div class="modal-dialog" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">${sectionData}</h5>
                        <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <!-- Aquí puedes agregar más detalles de sectionData -->
                        <p>${sectionData}</p>
                    </div>
                </div>
            </div>
        `;
        return modalDiv;
    }
});

  </script>
  

<!-- script model -->
<script>
  document.addEventListener('DOMContentLoaded', function() {
      const markdownInput = document.getElementById('markdownFileInput');
      const markdownContent = document.getElementById('markdownContent');
      const tagsFilter = document.getElementById('tagsFilter');
      let allTags = new Set(); // Almacena todas las etiquetas únicas
  
      markdownInput.addEventListener('change', function(event) {
          const file = event.target.files[0];
          if (!file) {
              return;
          }
  
          const reader = new FileReader();
          reader.onload = function(e) {
              const content = e.target.result;
              const lines = content.split(/\r?\n/); // Divide el contenido en líneas
              allTags.clear(); // Limpia el conjunto de etiquetas para la nueva selección de archivo
              markdownContent.innerHTML = ''; // Limpia el contenido anterior
  
              lines.forEach((line, index) => {
                  const container = document.createElement('div');
                  container.className = 'line-container';
  
                  const tagsContainer = document.createElement('div');
                  tagsContainer.className = 'tags-container';
  
                  const textarea = document.createElement('textarea');
                  textarea.value = line;
                  textarea.dataset.lineNumber = index;
                  textarea.oninput = function() {
                      adjustTextareaHeight(this);
                      updateTagsList(this, tagsContainer);
                  };
  
                  container.appendChild(tagsContainer);
                  container.appendChild(textarea);
                  markdownContent.appendChild(container);
  
                  adjustTextareaHeight(textarea);
                  updateTagsList(textarea, tagsContainer); // Actualiza los tags inicialmente
  
                  // Procesa etiquetas para el dropdown, removiendo el '#' y evitando duplicados
                  const tags = line.match(/(?<=\s)#([^\s#]+)/g) || [];
                  tags.forEach(tag => {
                      allTags.add(tag.substring(1)); // Añade solo el texto de la etiqueta, sin el '#'
                  });
              });
  
              updateTagsDropdown(Array.from(allTags)); // Actualiza el dropdown después de procesar todas las líneas
          };
          reader.readAsText(file);
      });
  
      function adjustTextareaHeight(textarea) {
          textarea.style.height = 'auto'; // Resetea la altura para obtener el scrollHeight correcto
          const maxHeight = 400; // Máximo de altura en píxeles
          textarea.style.height = `${Math.min(textarea.scrollHeight, maxHeight)}px`; // Ajusta altura
      }
  
      function updateTagsList(textarea, tagsContainer) {
    // Procesamiento del contenido del textarea
    let content = textarea.value;
    // Eliminar espacios en blanco y guiones previos al primer carácter o número
    content = content.replace(/^[\s-]*/, '');

    // Limpieza de tagsContainer antes de agregar contenido procesado o tags
    tagsContainer.innerHTML = ''; 

    // Crear y agregar el contenido procesado al tagsContainer
    const processedContentDisplay = document.createElement('div');
    processedContentDisplay.className = 'processed-content';
    processedContentDisplay.textContent = content; // Asigna el contenido procesado
    tagsContainer.appendChild(processedContentDisplay);

    // Proceso existente para manejar las etiquetas (si es necesario)
    const tags = content.match(/(?<=\s)#([^\s#]+)/g) || [];
    tags.forEach(tag => {
        const tagElement = document.createElement('span');
        const tagClass = tag.substring(1); // Obtiene el texto de la etiqueta sin el '#'
        tagElement.classList.add(tagClass);
        tagElement.textContent = tagClass; // Asigna el texto de la etiqueta
        tagsContainer.appendChild(tagElement); // Agrega la etiqueta al tagsContainer
    });
}


        document.getElementById('downloadBtn').addEventListener('click', downloadModel);

        function downloadModel() {
            const textareas = document.querySelectorAll('textarea');
            let fileContent = '';
            textareas.forEach(textarea => {
                fileContent += textarea.value + '\n'; // Añade un salto de línea después de cada área de texto
            });

            const fileName = `Business model ${formatDate(new Date())}.md`;
            downloadFile(fileName, fileContent);
        }

        function formatDate(date) {
            const year = date.getFullYear();
            const month = (`0${date.getMonth() + 1}`).slice(-2);
            const day = (`0${date.getDate()}`).slice(-2);
            const hours = (`0${date.getHours()}`).slice(-2);
            const minutes = (`0${date.getMinutes()}`).slice(-2);
            const seconds = (`0${date.getSeconds()}`).slice(-2);
            return `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
        }

        function downloadFile(fileName, content) {
            const element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
            element.setAttribute('download', fileName);

            element.style.display = 'none';
            document.body.appendChild(element);

            element.click();

            document.body.removeChild(element);
        }
  
      function updateTagsDropdown(tags) {
          tagsFilter.innerHTML = ''; // Limpia opciones existentes
          tags.forEach(tag => {
              const option = document.createElement('option');
              option.value = tag;
              option.textContent = tag; // Ya no incluye el símbolo '#'
              tagsFilter.appendChild(option); // Añade la opción al selector
          });
      }
  
      // Función para filtrar líneas por etiquetas seleccionadas
      tagsFilter.addEventListener('change', filterLinesBySelectedTags);
  
      function filterLinesBySelectedTags() {
          const selectedTags = Array.from(tagsFilter.selectedOptions).map(option => option.value);
          document.querySelectorAll('.line-container').forEach(line => {
              const lineTags = Array.from(line.querySelectorAll('.tags-container span')).map(span => span.textContent);
              line.style.display = selectedTags.every(tag => lineTags.includes(tag)) ? '' : 'none';
          });
      }
  });
  </script>
  

  <script>
    let allTags = new Set(); // Almacena todas las etiquetas únicas
    
    // Evento que se dispara cuando se selecciona un archivo
    markdownInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (!file) {
            return;
        }
    
        const reader = new FileReader();
// Este fragmento es parte del evento 'change' del input de archivos Markdown
reader.onload = function(e) {
    const content = e.target.result;
    const lines = content.split(/\r?\n/); // Divide el contenido en líneas
    allTags.clear(); // Limpia el conjunto de etiquetas para la nueva selección de archivo

    lines.forEach((line, index) => {
        // Cambia la expresión regular para capturar sin incluir '#'
        const tags = line.match(/(?<=\s)#([^\s#]+)/g) || []; // Busca etiquetas en la línea actual
        tags.forEach(tag => {
            // Añade solo el texto de la etiqueta, sin el '#', al conjunto de todas las etiquetas
            allTags.add(tag.substring(1)); // Elimina el símbolo '#' antes de añadir
        });
    });

    // Luego de procesar todas las líneas, actualiza el selector de etiquetas
    // Asegúrate de que esta llamada se ajuste para trabajar con las etiquetas modificadas
    updateTagsDropdown(Array.from(allTags));
};



function updateTagsDropdown(tags) {
    const tagsFilter = document.getElementById('tagsFilter');
    tagsFilter.innerHTML = ''; // Limpia opciones existentes
    tags.forEach(tag => {
        const option = document.createElement('option');
        option.value = tag;
        option.textContent = tag; // Ya no incluye el símbolo '#', ajustado previamente
        tagsFilter.appendChild(option); // Añade la opción al selector
    });
}
    tagsFilter.addEventListener('change', function() {
        filterLinesBySelectedTags();
    });
    
    function filterLinesBySelectedTags() {
        const selectedTags = Array.from(document.getElementById('tagsFilter').selectedOptions).map(option => option.value);
        const lines = document.querySelectorAll('.line-container');
        
        lines.forEach(line => {
            const lineTags = Array.from(line.querySelectorAll('.tags-container span')).map(span => span.textContent);
            const isLineVisible = selectedTags.every(selectedTag => lineTags.includes(selectedTag));
            line.style.display = isLineVisible ? '' : 'none';
        });
    }
    </script>
    </body>
    </html>