<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plastilinn</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
    <script src="https://cdn.botpress.cloud/webchat/v1/inject.js"></script>
    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap" rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        .bp-widget-side {
            width: 100% !important;
            height: 100vh !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            border: none !important;
            border-radius: 0 !important;
            overflow: hidden !important;
        }

        .filter-switch label {
            cursor: pointer;
        }

        .filter-switch-item input:checked+label {
            color: white;
            background-color: blue;
            font-weight: 400;
        }

        .filter-switch-item input:not(:checked)+label {
            --bg-opacity: 0;
            box-shadow: none;
        }

        #content ul {
            list-style-type: circle;
            margin-right: 2rem;
        }

        #content li {
            line-height: 1.4rem;
        }
    </style>
</head>

<body>
    <div id="vue-app">
        <div class="min-h-screen h-screen flex flex-col">
            <!-- HEADER -->
            <header class="border-b border-gray-200">
                <div id="top-container" class="bg-gray-200 w-full fixed">
                    <div id="navbar" class="navbar bg-base-100 shadow-2xl">
                        <div class="navbar-start">
                            <div class="p-5">
                                <!-- Logo como imagen -->
                                <img src="assets/logo.png" alt="Logo de mi empresa" class="h-8">
                                <!-- Logo como texto o SVG, aqu칤 un ejemplo con texto -->
                            </div>
                            <a class="btn btn-ghost text-xl">Plastilinn</a><kbd class="kbd kbd-xs">V0.2.0</kbd>
                        </div>
                        <div class="navbar-center">
                            <div class="flex-1 text-center bg-gray-200 rounded-lg p-2 m-2">
                                <p v-if="modelName">{{ modelName }}</p>
                            </div>
                        </div>
                        <div class="navbar-end">
                            <div class="join">
                                <button id="downloadBtn" @click="downloadMarkdown" class="btn join-item btn-primary">
                                    <span class="material-symbols-outlined" translate="no">
                                        download_for_offline
                                    </span>
                                    Download
                                </button>
                                <button id="exportBtn" @click="downloadHTML" class="btn join-item btn-primary">
                                    <span class="material-symbols-outlined" translate="no">
                                        download_for_offline
                                    </span>
                                    Export
                                </button>
                                <button @click="toggleAutoDownload"
                                    :class="{'bg-green-500': autoDownloadEnabled, 'bg-gray-500': !autoDownloadEnabled}"
                                    class="btn join-item btn-primary">
                                    <span class="material-symbols-outlined" translate="no">
                                        toggle_on
                                    </span>
                                    Auto Download {{ autoDownloadEnabled ? 'ON' : 'OFF' }}
                                </button>
                            </div>
                        </div>
                    </div>

                </div>
            </header>
            <!-- MAIN CONTAINER -->
            <div class="flex-1 flex flex-row overflow-y-hidden">
                <!-- SIDEBAR -->
                <nav class="order-first w-1/4 overflow-y-auto custom-scrollbar" style="min-width: 440px">
                    <div class="flex flex-row flex-wrap p-2 
                    gap-2 bg-white sticky z-10 top-0">
                        <div class="flex flex-row justify-between gap-2">
                            <button @click="changeSidebar('home')"
                                class="collapse-filter-button btn btn-primary btn-sm">
                                <span class="material-symbols-outlined" translate="no">
                                    link
                                </span>Home</button>
                            <button @click="changeSidebar('guides')"
                                class="collapse-filter-button btn btn-primary btn-sm">
                                <span class="material-symbols-outlined" translate="no">
                                    fact_check
                                </span>Guides</button>
                            <button @click="changeSidebar('index')"
                                class="collapse-filter-button btn btn-primary btn-sm">
                                <span class="material-symbols-outlined" translate="no">
                                    list_alt
                                </span>Index</button>
                            <button @click="changeSidebar('filter')"
                                class="collapse-filter-button btn btn-primary btn-sm">
                                <span class="material-symbols-outlined" translate="no">
                                    filter_alt
                                </span>Filter</button>
                        </div>
                    </div>
                    <!-- Secciones con visibilidad condicional -->
                    <div class="p-2">
                        <div
                            v-bind:class="{ block: currentSidebarSection === 'home', hidden: currentSidebarSection !== 'home' }">
                            <div id="sidebar-home">
                                <div>
                                    <p>Plastilinn allows you to create a business model and evolve it to make it better
                                        and
                                        better. </p>
                                    <div>
                                        <h5>Guides</h5>
                                        <p>Includes help guides that will make it easier for you to create your business
                                            model, offering you step by step all the information you need and precise
                                            instructions.</p>
                                        <h5>Index</h5>
                                        <p>Allows you to quickly navigate to the section of your plastilin doc that you
                                            want
                                            to consult.</p>
                                        <h5>Filter</h5>
                                        <p>Allows you to carry out smart queries by filtering the content of your
                                            plastilin
                                            doc.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div v-if="currentSidebarSection === 'guides'">
                            <!-- Select que se muestra u oculta seg칰n showSelect -->
                            <select @change="loadGuideMarkdownContent($event.target.value)" id="guide-select"
                                class="w-full bg-white border border-gray-300 text-gray-700 py-2 px-4 rounded-lg shadow-sm focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-200 transition duration-150 ease-in-out">
                                <option value="">Select a guide</option>
                                <option
                                    value="https://xbokmd.github.io/plastilinn/docs/guides/plastilinn_cheatsheet.md">
                                    Plastilinn cheatsheet
                                </option>
                                <option value="https://xbokmd.github.io/plastilinn/docs/guides/quick_start.md">Quick
                                    start
                                </option>
                                <option value="https://xbokmd.github.io/plastilinn/docs/guides/using_plastilinn.md">
                                    Using
                                    plastilinn
                                </option>
                                <option value="https://xbokmd.github.io/plastilinn/docs/guides/IA.md">IA
                                </option>
                                <option value="https://xbokmd.github.io/plastilinn/docs/guides/idea_definition.md">Idea
                                    definition
                                </option>
                                <option
                                    value="https://xbokmd.github.io/plastilinn/docs/guides/business_model_canvas.md">
                                    Business
                                    Model Canvas
                                </option>
                                <option value="https://xbokmd.github.io/plastilinn/docs/guides/lean_canvas.md">Lean
                                    Canvas
                                </option>
                                <option
                                    value="https://xbokmd.github.io/plastilinn/docs/guides/business_model_canvas.md">
                                    Business Model Canvas
                                </option>
                                <option
                                    value="https://xbokmd.github.io/plastilinn/docs/guides/value_proposition_canvas.md">
                                    Value
                                    Proposition Canvas
                                </option>
                                <option value="https://xbokmd.github.io/plastilinn/docs/guides/empathy_map.md">Empathy
                                    map
                                </option>
                            </select>
                            <!-- Div que muestra el contenido del Markdown seleccionado -->
                            <div v-if="markdownGuideContent">
                                <div v-html="markdownGuideContent"></div>
                            </div>

                            <button
                                @click="setArtifactBusinessModelCanvas('partners', 'activities', 'valuePropositions', 'relationships', 'profile', 'resources', 'channels', 'costLines', 'revenueLines'); isArtifactModalOpen = true"
                                class="btn btn-primary mt-4">Business
                                Model Canvas</button>
                        </div>
                        <div
                            v-bind:class="{ block: currentSidebarSection === 'index', hidden: currentSidebarSection !== 'index' }">
                            <div class="index">
                                <ul class="menu p-4 w-80 bg-base-100">
                                    <li v-for="block in model.filter(b => b.type === 'section')" :key="block.id"
                                        :class="`pl-${block.depthLevel * 4} p-0`">
                                        <a class="link link-primary" :href="'#' + block.title">{{ block.title }}</a>
                                    </li>
                                </ul>
                            </div>
                        </div>
                        <div
                            v-bind:class="{ block: currentSidebarSection === 'filter', hidden: currentSidebarSection !== 'filter' }">
                            <div class=" flex justify-between bg-white" v-if="filterVisible">
                                <div class="flex flex-col gap-4">
                                    <div class="flex flex-col w-full">
                                        <div class="flex flex-col w-full p-4 bg-white rounded-lg shadow-sm">
                                            <!-- B칰squeda -->

                                            <div
                                                class="flex flex-col mb-4 p-2 bg-gray-200 rounded-lg shadowflex flex-col mb-4 p-2 bg-gray-200 rounded-lg shadow">
                                                <h5 class="card-title">Search and replace</h5>
                                                <div class="flex items-center mb-4 p-2 bg-gray-50 rounded-lg shadow">
                                                    <span class="material-symbols-outlined" translate="no">
                                                        search
                                                    </span>
                                                    <input v-model="searchQuery" id="seach-query" type="text"
                                                        placeholder="Search..." class="input ml-2 bg-gray-50 w-full">
                                                </div>
                                                <div class="flex items-center mb-4 p-2 bg-gray-50 rounded-lg shadow">
                                                    <span class="material-symbols-outlined" translate="no">
                                                        find_replace
                                                    </span>
                                                    <input v-model="replaceText" id="replace-text" type="text"
                                                        placeholder="Replace with..."
                                                        class="input ml-2 bg-gray-50 w-full">
                                                </div>
                                                <button @click="replaceMatches" class="btn">Replace</button>
                                            </div>

                                            <!-- Filtro de etiquetas -->
                                            <div class="flex flex-col mt-4">
                                                <div class="flex flex-col mb-4 p-2 bg-gray-200 rounded-lg shadow">
                                                    <!-- Encabezado con Filter y Reset en la misma l칤nea -->
                                                    <div class="flex justify-between items-center mb-2">
                                                        <span class="text-lg font-semibold">Filtered tags and
                                                            markers</span>
                                                        <button @click="resetSelectedTagsAndMarkers"
                                                            class="btn btn-ghost">
                                                            <span class="material-symbols-outlined"
                                                                translate="no">restart_alt</span>
                                                            Reset
                                                        </button>
                                                    </div>
                                                    <!-- Contenedor para las etiquetas, ahora debajo del encabezado -->
                                                    <div id="show-selected"
                                                        class="flex flex-wrap p-2 gap-2 rounded bg-red-300">
                                                        <div class="flex flex-wrap gap-2">
                                                            <span v-for="tag in selectedTags" :key="tag"
                                                                class="flex items-center justify-center h-8 px-2 text-sm"
                                                                :data-tag="tag">{{ tag }}</span>
                                                            <span v-for="marker in selectedMarkers" :key="marker"
                                                                class="flex items-center justify-center h-8 px-2 text-sm"
                                                                :data-marker="marker">{{ marker }}</span>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="tag-group mb-4 px-2 py-3 bg-gray-200 rounded-md shadow-lg">
                                                    <div class="tag-name text-center font-semibold text-blue-600 mb-2">
                                                        Tags
                                                    </div>
                                                    <ul class="flex justify-center items-center flex-wrap gap-2">
                                                        <li v-for="tag in tags" :key="`tag-${tag}`"
                                                            class="filter-switch-item">
                                                            <input class="checkbox checkbox-primary sr-only"
                                                                :id="`tag-${tag}`" :value="tag" type="checkbox"
                                                                @change="toggleTagSelection(`${tag}`)">
                                                            <label :for="`tag-${tag}`"
                                                                class="cursor-pointer inline-block text-sm text-gray-600 hover:text-gray-800 bg-white rounded shadow p-1">
                                                                <span :data-tag="tag">{{ tag }}</span>
                                                            </label>
                                                        </li>
                                                    </ul>
                                                </div>
                                            </div>
                                            <div v-for="(values, markerName) in prepareMarkers()" :key="markerName"
                                                class="marker-group mb-4 px-2 py-3 bg-gray-200 rounded-md shadow-lg">
                                                <div class="marker-name text-center font-semibold text-blue-600 mb-2">{{
                                                    markerName }}</div>
                                                <ul class="flex justify-center items-center flex-wrap gap-2">
                                                    <li v-for="value in values" :key="`marker-${markerName}-${value}`"
                                                        class="filter-switch-item">
                                                        <input class="checkbox checkbox-primary sr-only"
                                                            :id="`marker-${markerName}-${value}`"
                                                            :value="`${markerName}:${value}`" type="checkbox"
                                                            @change="toggleMarkerSelection(`${value}`)">
                                                        <label :for="`marker-${markerName}-${value}`"
                                                            class="cursor-pointer inline-block text-sm text-gray-600 hover:text-gray-800 bg-white rounded shadow p-1">{{
                                                            value }}</label>
                                                    </li>
                                                </ul>
                                            </div>
                                        </div>
                                        <div class="">
                                            <!-- Botones para aplicar filtros directamente -->
                                            <div class="rounded-lg shadow-md overflow-hidden border border-red-500 m-2">
                                                <button @click="setFilterTags(['!!!!!', '!!!!'])"
                                                    class="bg-red-500 text-white px-4 py-2 hover:bg-red-600 focus:ring-red-500 focus:ring-opacity-50 w-full">
                                                    High priority
                                                </button>
                                                <div class="flex items-center bg-gray-100 px-4 py-2">
                                                    <p>
                                                        <span data-marker="!!!!!">!!!!!</span> <kbd
                                                            class="kbd kbd-xs">#!!!!!</kbd> or
                                                        <span data-marker="!!!!">!!!!</span> <kbd
                                                            class="kbd kbd-xs">#!!!!</kbd>
                                                    </p>
                                                </div>
                                            </div>
                                            <div class="rounded-lg shadow-md overflow-hidden border border-red-500 m-2">
                                                <button @click="setFilterTags(['*****', '?????'])"
                                                    class="bg-red-500 text-white px-4 py-2 hover:bg-red-600 focus:ring-red-500 focus:ring-opacity-50 w-full">
                                                    High importance or uncertainty
                                                </button>
                                                <div class="flex items-center bg-gray-100 px-4 py-2">
                                                    <p>
                                                        <span data-marker="*****">*****</span> <kbd
                                                            class="kbd kbd-xs">#*****</kbd> or
                                                        <span data-marker="?????">?????</span> <kbd
                                                            class="kbd kbd-xs">#?????</kbd>
                                                    </p>
                                                </div>
                                            </div>

                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </nav>
                <!-- CONTENT -->
                <main class="flex-auto border-l border-r border-gray-200 overflow-y-auto"
                    style="scroll-behavior: smooth;">
                    <div class="leading-10">
                        <div id="content" class="bg-gray-200 p-1 rounded">
                            <div class="plastilinn-hero hero pt-12" v-if="!modelMarkdownLoaded">
                                <div class="hero-content text-center">
                                    <div class="">
                                        <div class="m-auto p-12">
                                            <div class="flex flex-col md:flex-row">
                                                <div class="flex flex-col justify-center">

                                                </div>
                                            </div>
                                        </div>
                                        <div
                                            class="md:text-5xl text-2xl uppercase font-black bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-500">
                                            Shape your business with AI
                                        </div>
                                        <div class="text-xl m-4">Design, analyze and validate your business model.
                                        </div>
                                        <div class="collapse bg-base-200 mb-2">
                                            <input type="checkbox" />
                                            <div class="collapse-title text-xl font-medium">
                                                Change language / Cambiar idioma
                                            </div>
                                            <div class="collapse-content">
                                                <img src="assets/changing_language.gif" />

                                            </div>
                                        </div>
                                        <div class="card bg-base-100 shadow-xl">
                                            <div class="card-body flex justify-center items-center">
                                                <h2>I'm already using plastilinn</h2>
                                                Load or drag and drop your plastilinn doc
                                                <input type="file" @change="loadAndParseModelFile" accept=".md"
                                                    class="file-input file-input-bordered file-input-primary w-full max-w-xs m-4">
                                            </div>
                                        </div>
                                        <div class="card bg-base-100 shadow-xl mt-4">
                                            <div class="card-body">
                                                <h2>I'm new to Plastilinn</h2>
                                                <div class="card-actions">
                                                    <button
                                                        @click="activateGuidesAndLoadGuide('https://xbokmd.github.io/plastilinn/docs/guides/existing_business.md')">
                                                        I have a business running and I want to improve it</button>
                                                </div>
                                                <div class="card-actions">
                                                    <button
                                                        @click="activateGuidesAndLoadGuide('https://xbokmd.github.io/plastilinn/docs/guides/new_business.md')">
                                                        I am creating a new business from scratch</button>
                                                </div>
                                                <div class="card-actions">
                                                    <button
                                                        @click="activateGuidesAndLoadGuide('https://xbokmd.github.io/plastilinn/docs/guides/learn.md')">
                                                        I want to learn how to create a business</button>
                                                </div>
                                                <div class="card-actions">
                                                    <button
                                                        @click="activateGuidesAndLoadGuide('https://xbokmd.github.io/plastilinn/docs/guides/quick_start.md')">
                                                        I want to try plastilinn</button>
                                                </div>
                                            </div>

                                        </div>


                                    </div>
                                </div>
                            </div>
                            <div class="modelContainer m-2 p-0">
                                <div class="flex flex-row w-full">
                                    <div class="md-block-wrapper w-full">
                                        <div v-for="block in searchFilteredBlocks" :key="block.id" :id="block.title"
                                            class="md-block flex">
                                            <div
                                                class="md-block-container-middle md-block-content shadow-xl hover:shadow-2xl transition-shadow custom-flex-2 w-1/2">
                                                <div v-html="block.contentParsed"></div>
                                            </div>
                                            <div
                                                class="md-block-container-right metadata-container text-gray-500 w-full rounded-md text-sm text-center">
                                                <div
                                                    class="flex flex-col items-start justify-start w-full bg-gray-200 rounded-md text-sm text-gray-500">
                                                    <div class="xbok-block-tags flex items-center">
                                                        <button @click="openBlockEditModal(block)"
                                                            class="btn btn-primary btn-outline bg-base-200 p-2 rounded opacity-100 hover:opacity-100 focus:opacity-100">
                                                            游닇
                                                        </button>
                                                        <div :id="block.metamodel.name"
                                                            class="block-metamodel section inline-flex"
                                                            v-if="block.metamodel">
                                                            <button @click="openInfoModal(block.metamodel.name)"
                                                                class="btn btn-primary btn-outline bg-base-200 p-2 rounded opacity-100 hover:opacity-100 focus:opacity-100">
                                                                游
                                                            </button>
                                                        </div>
                                                        <div class="md-block-container-right markers-container"
                                                            v-html="block.markersParsed">
                                                        </div>
                                                        <div class="md-block-container-right metadata-container"
                                                            v-html="block.tagsParsed">
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div id="content" class="mt-48 ml-2 mr-2">
                                <div class="flex flex-row w-full">
                                    <div class="md-block-wrapper w-full">
                                        <div v-for="block in filteredBlocks" :key="block.id" :id="block.title"
                                            class="md-block flex">
                                            <!-- Renderizar los bloques -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
            <!-- FOOTER -->
            <!-- <footer class="border-t border-gray-200 p-2">Footer</footer> -->
        </div>
        <!-- MODAL WINDOWS -->
        <div id="artifact-modal" v-if="isArtifactModalOpen"
            style="position: fixed; top: 5%; left: 5%; width: 90%; height: 90%; z-index: 100; background-color: white; overflow: auto; padding: 20px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);">
            <!-- Usa v-html para insertar el contenido de artifactModalContent como HTML -->
            <button @click="isArtifactModalOpen = false" class="btn">Cerrar</button>
            <div v-html="artifactModalContent"></div>
            <div id="business-model-canvas" class="bg-gray-100 -black h-screen p-5">
                <div class="row-span-2 grid h-3/5 grid-cols-5 bg-white  shadow-lg">
                    <div class="row-span-2 border pl-2">
                        <h3>Key Partners</h2>
                    </div>
                    <div class="row-span-1 border pl-2">
                        <h3>Key activities</h3>
                        <div v-html="buildTagsQueryList(['work'])"></div>
                    </div>
                    <div class="row-span-2 border pl-2">
                        <h3>Value propositions</h3>
                        <div v-html="buildTagsQueryList(['value'])"></div>
                    </div>
                    <div class="border pl-2">
                        <h3>Customer relationships</h3>
                        <div v-html="buildTagsQueryList(['relation'])"></div>
                    </div>
                    <div class="row-span-2 border pl-2>">
                        <h3>Customer segments</h3>
                        <div v-html="buildTagsQueryList(['profile'])"></div>
                    </div>
                    <div class="border pl-2">
                        <h3>Key resources</h3>
                        <div v-html="buildTagsQueryList(['resource'])"></div>
                    </div>
                    <div class="border pl-2">
                        <h3>Channels</h3>
                        <div v-html="buildTagsQueryList(['channel'])"></div>
                    </div>
                </div>
                <div class="grid h-52 grid-cols-2 bg-white shadow-lg">
                    <div class="border pl-2">
                        <h3>Cost lines</h3>
                        <div v-html="buildTagsQueryList(['cost'])"></div>
                    </div>
                    <div class="border pl-2">
                        <h3>Revenue lines</h3>
                        <div v-html="buildTagsQueryList(['revenue'])"></div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Modal para editar el contenido del bloque seleccionada -->
        <div v-if="isBlockEditModalOpen"
            class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full items-center z-50">
            <div class="modal-background absolute inset-0 bg-black opacity-50"></div>
            <div class="relative top-10 mx-auto p-1 border w-4/5 h-4/5 shadow-lg rounded-md bg-white flex flex-col justify-center items-center"
                style="z-index: 100;">
                <!-- Contenedor para marcadores -->
                <div class="markers flex flex-col items-start justify-start">
                </div>
                <div class="flex">
                    <div class="mt-3 text-center">
                        <div class="mt-2">
                            <div id="editor-container"></div>
                        </div>
                        <button class="btn m-2 btn-primary" @click="sendMessageToBot()">
                            <span class="material-symbols-outlined" translate="no">
                                robot_2
                            </span>
                            AI suggest content
                        </button>
                        <button class="btn m-2 btn-primary" @click="showGeneratedContent()">
                            <span class="material-symbols-outlined" translate="no">
                                robot_2
                            </span>
                            AI suggest content 2
                        </button>
                        <button class="btn m-2 btn-primary" @click="">
                            <span class="material-symbols-outlined" translate="no">
                                style
                            </span>
                            Tags
                        </button>
                        <button class="btn m-2 btn-primary" @click="saveChanges">
                            <span class="material-symbols-outlined" translate="no">
                                save
                            </span>
                            Save changes
                        </button>
                        <button class="btn m-2 btn-primary" @click="closeModal">
                            <span class="material-symbols-outlined" translate="no">
                                cancel
                            </span>
                            Close window
                        </button>
                    </div>

                    <!-- Agrega los nuevos botones aqu칤 -->
                    <div v-if="generatedContent">
                        <textarea v-model="generatedContent" class="w-full h-32 mt-4 p-2 border"></textarea>
                        <button class="btn m-2 btn-primary" @click="copyToClipboard()">
                            <span class="material-symbols-outlined" translate="no">
                                content_copy
                            </span>
                            Copy Content
                        </button>
                        <button class="btn m-2 btn-primary" @click="openNewWindowWithPrompt()">
                            <span class="material-symbols-outlined" translate="no">
                                open_in_new
                            </span>
                            Open in New Window
                        </button>
                    </div>

                </div>
            </div>
        </div>
    </div>
    <script>
        Vue.createApp({
            data() {
                return {

                    // APP STATE
                    currentSidebarSection: 'home',
                    isSidebarVisible: true, // Controla la visibilidad de la sidebar
                    isIndexOpen: true,
                    isInfoModalOpen: false,
                    autoDownloadEnabled: true,
                    newMarkdownContent: '',
                    showGuidesSelect: false, // Controla la visibilidad del select
                    markdownGuideContent: '', // Almacena el contenido del Markdown cargado
                    isArtifactModalOpen: false,
                    artifactModalContent: '', // Almacenar치 el contenido HTML generado
                    generatedContent: '',
                    // METAMODEL
                    metamodel: [],
                    // Definir un array con los s칤mbolos que usan los markers
                    markerSymbols: ['>', '*', '?', '!', '춰', '=', '+', '-'],
                    // MODEL
                    model: [], // Se utilizar치 para almacenar el modelo de datos creado a partir del Markdown
                    modelName: '',
                    modelMarkdown: '', // Campo para almacenar el contenido Markdown concatenado
                    modelMarkdownLoaded: false, // Variable para controlar si el markdown ha sido cargado y analizado
                    modelTagsArray: new Set(),
                    depthCounters: [0, 0, 0, 0, 0, 0],
                    // MODEL BLOCKS
                    lastId: 0, // Inicializa un contador para los IDs
                    isBlockEditModalOpen: false,
                    selectedBlockContent: '',
                    selectedBlockIndex: null,
                    selectedBlockId: null,
                    tags: [],
                    // BLOCK INFO MODAL
                    selectedInfoBlock: null, // Para almacenar la informaci칩n del bloque seleccionado
                    selectedBlockInfoURL: null,
                    // FILTERS
                    selectedTags: [], // Almacena las etiquetas seleccionadas
                    selectedBlockTitles: [], // Arreglo para almacenar los titles seleccionados
                    selectedMarkers: [],
                    // combinedFilters: [],
                    filterVisible: true,
                    // SEARCH
                    searchQuery: '',
                    searchText: '',
                    replaceText: '',
                };
            },
            computed: {

                parsedModel() {
                    return this.model.map((block) => ({ ...block, contentParsed: marked.parse(block.content) }));
                },

                filteredBlocks() {
                    try {
                        let blocksWithParents = [];
                        let allLocators = new Set();

                        this.model.forEach(block => {
                            const tagMatch = this.selectedTags.length === 0 || this.selectedTags.some(tag => block.tags.includes(tag));
                            const markerMatch = this.selectedMarkers.length === 0 || this.selectedMarkers.some(marker => {
                                return block.markers && block.markers.some(bMarker => bMarker === marker || bMarker.includes(marker));
                            });

                            if (tagMatch && markerMatch) {
                                blocksWithParents.push(block);
                                allLocators.add(block.locator);

                                let parentLocator = block.locator.split('.').slice(0, -1).join('.');
                                while (parentLocator) {
                                    if (!allLocators.has(parentLocator)) {
                                        const parentBlock = this.model.find(b => b.locator === parentLocator);
                                        if (parentBlock) {
                                            blocksWithParents.unshift(parentBlock);
                                            allLocators.add(parentLocator);
                                        }
                                    }
                                    parentLocator = parentLocator.split('.').slice(0, -1).join('.');
                                }
                            }
                        });

                        // Ordena y resalta como antes
                        blocksWithParents.sort((a, b) => a.locator.localeCompare(b.locator));
                        blocksWithParents.sort((a, b) => a.uid - b.uid);

                        const highlightedBlocks = blocksWithParents.map(block => {
                            const clonedBlock = { ...block };
                            if (this.selectedTags.length > 0) {
                                clonedBlock.contentParsed = this.highlightText(clonedBlock.contentParsed, this.selectedTags);
                            }
                            return clonedBlock;
                        });
                        this.highlightFilteredBlocks();
                        return highlightedBlocks;
                    } catch (error) {
                        console.error('Error al filtrar bloques:', error);
                    }
                },

                combinedFilters() {
                    return [...this.selectedBrands, ...this.selectedTags];
                },

                searchFilteredBlocks() {
                    if (!this.searchQuery) {
                        return this.filteredBlocks;
                    }

                    let filteredBlocks = this.filteredBlocks.filter(block =>
                        block.contentParsed.toLowerCase().includes(this.searchQuery.toLowerCase())
                    );

                    const allLocators = new Set(filteredBlocks.map(block => block.locator));
                    let blocksToAdd = []; // Guardaremos aqu칤 los bloques padres para luego insertarlos

                    filteredBlocks.forEach(block => {
                        const parentLocators = this.findParentLocators(block.locator);
                        parentLocators.forEach(parentLocator => {
                            if (!allLocators.has(parentLocator)) {
                                const parentBlock = this.model.find(b => b.locator === parentLocator);
                                if (parentBlock) {
                                    blocksToAdd.push(parentBlock);
                                    allLocators.add(parentLocator);
                                }
                            }
                        });
                    });

                    // Insertar cada bloque padre en la posici칩n correcta
                    blocksToAdd.forEach(parentBlock => {
                        const childIndex = filteredBlocks.findIndex(block =>
                            block.locator.startsWith(parentBlock.locator + '.')
                        );
                        if (childIndex !== -1) {
                            // Si encontramos un hijo, insertamos el padre justo antes
                            filteredBlocks.splice(childIndex, 0, parentBlock);
                        } else {
                            // Si no encontramos un hijo (debido a filtros), agregamos el padre al final
                            filteredBlocks.push(parentBlock);
                        }
                    });

                    // Finalmente, aplicar el resaltado
                    return filteredBlocks.map(block => {
                        const highlightedContent = this.highlightText(block.contentParsed, this.searchQuery);
                        return { ...block, contentParsed: highlightedContent };
                    });
                },

                orderedBlocks() {
                    return this.model.sort((a, b) => a.uid - b.uid);
                }

            },
            methods: {

                changeSidebar(section) {
                    this.currentSidebarSection = section;
                    // Si la secci칩n no es 'filter', resetea el input de b칰squeda y los tags de filtro
                    if (section !== 'filter') {
                        this.searchQuery = ''; // Resetea el input de b칰squeda
                        this.selectedTags = []; // Resetea los tags de filtro seleccionados
                    }
                },

                // METAMODEL

                processMetamodel() {
                    axios.get('https://xbokmd.github.io/plastilinn/metamodel.json')
                        .then((response) => {
                            if (response.data && response.data.classes && response.data.sections) {
                                this.metamodel = response.data;
                            } else {
                                console.error('Metamodel received does not have the expected structure');
                            }
                        })
                        .catch((error) => console.error('Error loading metamodel:', error));
                },

                // MODEL LOADING

                loadAndParseModelFile(event) {
                    const file = event.target.files[0];
                    if (!file) {
                        return;
                    }
                    const modelName = this.getModelNameFromFileName(file.name);
                    this.modelName = modelName; // Actualiza modelName con el resultado de la funci칩n
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        this.parseModelMarkdown(content);
                    };
                    reader.readAsText(file);
                    this.updateModelMarkdown();
                    this.modelMarkdownLoaded = true;
                },

                getModelNameFromFileName(fileName) {
                    let name = fileName.replace(/\.md$/, ''); // Elimina la extensi칩n ".md"
                    name = name.replace(/ - saved.*$/, ''); // Elimina " - saved" y todo lo que sigue
                    return name;
                },

                parseModelMarkdown(content) {
                    const model = this.splitModelMarkdownIntoBlocks(content);
                    this.model = model.map((blockContent) => this.processBlock(blockContent));
                    this.assignUids();
                    // this.highlightTitlesInContent();
                    this.updateTagsArray();
                },

                splitModelMarkdownIntoBlocks(content) {
                    let currentBlock = [];
                    const lines = content.split(/\r?\n/);

                    lines.forEach((line) => {
                        if (/^\s*([-*\d.]*)*\s*#/.test(line)) {
                            if (currentBlock.length > 0) {
                                this.model.push(currentBlock.join('\n'));
                                currentBlock = [];
                            }
                        }
                        currentBlock.push(line);
                    });
                    if (currentBlock.length > 0) {
                        this.model.push(currentBlock.join('\n'));
                    }
                    return this.model;
                },

                // BLOCK PROCESSING

                updateModelBlockContent(blockId, newContent) {
                    const blockIndex = this.model.findIndex(block => block.id === blockId);
                    if (blockIndex !== -1) {
                        // Actualiza el contenido
                        const block = this.model[blockIndex];
                        // Asegura que newContent sea una cadena antes de asignarla.
                        // Si newContent no es una cadena, podr칤as convertirla a cadena o manejar el error como prefieras.
                        if (typeof newContent !== 'string') {
                            console.error('newContent esperaba una cadena, recibido:', typeof newContent, newContent);
                            // Por ejemplo, si newContent deber칤a ser siempre una cadena, podr칤as convertirla forzosamente a cadena
                            // o asignar una cadena vac칤a o alg칰n valor por defecto seg칰n sea apropiado para tu aplicaci칩n.
                            newContent = String(newContent); // Convierte forzosamente a cadena (podr칤a resultar en 'undefined' o 'null' como cadena)
                            // O manejar el caso de manera diferente seg칰n sea necesario.
                        }

                        block.content = newContent;

                        // Llama a los m칠todos para recalcular los campos dependientes
                        this.updateDependentModelBlockFields(blockIndex);
                    }
                },

                updateDependentModelBlockFields(blockIndex) {
                    const block = this.model[blockIndex];
                    // Conversi칩n forzada a cadena si es necesario.
                    let contentAsString = String(block.content)
                    const mdToHTML = this.parseToHTML(block.content);
                    block.contentParsed = marked.parse(mdToHTML);
                    //block.contentParsed = marked.parse(mdToHTML);
                    const firstLine = block.content.split('\n')[0];
                    block.type = this.determineBlockType(firstLine);
                    block.depthLevel = this.determineDepthLevel(firstLine);
                    block.title = this.extractBlockTitle(block.content); // Ajustado para usar el m칠todo recalculado
                    block.instanceClass = this.determineInstanceClass(block.content, block.type);
                    const tagResults = this.processTags(block.content);
                    block.tags = tagResults.tags;
                    block.tagsParsed = tagResults.tagsParsed;
                    block.markers = tagResults.markers;
                    block.markersParsed = tagResults.markersParsed;
                    block.instanceValue = this.setInstanceValue(block.title);
                    block.metamodelID = this.generateMetamodelID(block.title, block.instanceClass);
                    block.metamodel = this.importMetamodelData(block.metamodelID);
                    // Llama al nuevo m칠todo para calcular el locator
                    block.locator = this.calculateLocator(block.depthLevel);
                    // Aqu칤 puedes agregar m치s campos para recalcular si es necesario
                },

                processBlock(blockContent, blockId = null) {
                    let block;
                    let isNewBlock = false;

                    if (blockId == null) {
                        // Creaci칩n de un nuevo bloque
                        this.lastId += 1;
                        block = { id: this.lastId, content: blockContent };
                        this.model.push(block);
                        isNewBlock = true;
                    } else {
                        // Actualizaci칩n de un bloque existente
                        const blockIndex = this.model.findIndex(block => block.id === blockId);
                        if (blockIndex === -1) {
                            console.error("Block not found");
                            return;
                        }
                        block = this.model[blockIndex];
                        block.content = blockContent;
                    }

                    if (!isNewBlock || block.content) {
                        const blockIndex = this.model.findIndex(b => b.id === block.id);
                        this.updateDependentModelBlockFields(blockIndex);
                    }

                    // Siempre devuelve el bloque para operaciones de creaci칩n. Para actualizaciones,
                    // el bloque ya est치 actualizado en el modelo.
                    return block;
                },

                determineBlockType(firstLine) {
                    if (/^\s*(-\s+)?#(\s|#)/.test(firstLine)) {
                        return 'section';
                    }
                    return 'item';
                },

                determineDepthLevel(firstLine) {
                    // Esta expresi칩n regular busca signos '#' al inicio de la l칤nea seguidos directamente
                    // por otro '#' o un espacio, indicando un encabezado de Markdown.
                    const match = firstLine.match(/^\s*(#+)(?=\s|#)/);
                    if (match) {
                        return match[1].length; // La longitud de la coincidencia es el nivel de profundidad.
                    }
                    // Si no es un encabezado de Markdown, retorna 0 o un valor por defecto.
                    return 0;
                },

                calculateLocator(depthLevel) {
                    if (depthLevel === 0) {
                        // Encuentra el 칰ltimo locator con un depthLevel > 0 y tr치talo como base para este.
                        const lastNonZeroDepthLocator = this.findLastNonZeroDepthLocator();
                        return `${lastNonZeroDepthLocator}.1`; // Asume que quieres a침adirlo como un subnivel del 칰ltimo encabezado.
                    } else if (depthLevel >= 1 && depthLevel <= 6) {
                        this.depthCounters[depthLevel - 1] += 1;

                        for (let i = depthLevel; i < 6; i++) {
                            this.depthCounters[i] = 0;
                        }

                        return this.depthCounters.slice(0, depthLevel).join('.');
                    } else {
                        console.error(`Depth level out of range: ${depthLevel}`);
                        return '';
                    }
                },

                findLastNonZeroDepthLocator() {
                    // Busca hacia atr치s desde el final del array model hasta encontrar un bloque con depthLevel > 0.
                    for (let i = this.model.length - 1; i >= 0; i--) {
                        if (this.model[i].depthLevel > 0) {
                            return this.model[i].locator; // Aseg칰rate de que este bloque ya tiene un locator calculado.
                        }
                    }
                    return '0'; // Devuelve un valor por defecto si no encuentras ninguno.
                },

                determineInstanceClass(blockContent, type) {
                    if (type === 'section') {
                        const match = blockContent.match(/^\s*#+\s*(#[^\s]+)/);
                        if (match && match[1] && !/^#+$/.test(match[1])) {
                            return match[1].substring(1);
                        }
                    }
                    return null;
                },

                processTags(blockContent) {
                    const markerSymbols = this.markerSymbols;
                    // Inicializando un nuevo array para los marcadores ajustados
                    const adjustedMarkers = [];

                    // Capturando marcadores: cadenas que comienzan con # seguido por uno de los s칤mbolos especiales de marcadores
                    const markers = [...blockContent.matchAll(/(?:^|\s)#([>!*?+^-][^\s]*)/g)].map(match => {
                        const markerWithoutPrefix = match[1];
                        adjustedMarkers.push(markerWithoutPrefix); // Agrega el marcador ajustado sin el prefijo
                        return markerWithoutPrefix; // Devuelve el marcador sin el prefijo para el mapeo
                    });

                    const markersParsed = adjustedMarkers.map(marker => this.parseMarker(marker)).join(' ');

                    // Expresi칩n regular ajustada para capturar etiquetas
                    const tagsRegex = /(?:^|\s)(#[^\s#][^\s]*)/g;
                    const tags = [];
                    let match;
                    while ((match = tagsRegex.exec(blockContent)) !== null) {
                        // Evita bucles infinitos con coincidencias de ancho cero
                        if (match.index === tagsRegex.lastIndex) {
                            tagsRegex.lastIndex++;
                        }

                        // Excluye marcadores del array de etiquetas
                        if (!markerSymbols.some(symbol => match[1].startsWith(`#${symbol}`))) {
                            tags.push(match[1].substring(1)); // Elimina el # principal por consistencia con tu l칩gica original
                        }
                    }
                    const tagsParsed = tags.map(tag => this.parseTag(tag)).join(' ');

                    // Nota: Este c칩digo asume que todos los marcadores vienen con un prefijo y los ajusta en consecuencia.
                    // Si algunos marcadores pueden venir sin prefijo, deber치s ajustar esta l칩gica.
                    return { markers: adjustedMarkers, markersParsed, tags, tagsParsed };
                },

                parseMarker(marker) {
                    // Aseg칰rate de que esta funci칩n maneje correctamente el marcador ya sin prefijo
                    return `<span data-marker="${marker}">#${marker}</span>`;
                },

                parseTag(tag) {
                    return `<span data-tag="${tag}">#${tag}</span>`;
                },

                extractBlockTitle(blockContent) {
                    const firstLine = blockContent.split(/\r?\n/)[0]; // Obtiene la primera l칤nea

                    // Extrae el encabezado Markdown y la primera etiqueta (si existe) que est칠 directamente despu칠s del encabezado
                    const matches = firstLine.match(/^(#+\s*)(#[^\s]+)?\s*(.*)/);
                    if (matches) {
                        const markdownHeader = matches[1]; // Encabezado Markdown (p.ej., '###')
                        const directTag = matches[2] ? `${matches[2]} ` : ''; // La etiqueta directa despu칠s del encabezado, si existe
                        const restOfTheTitle = matches[3]; // El resto del t칤tulo despu칠s del encabezado y la etiqueta directa

                        // Combina la etiqueta directa (si existe) y el resto del t칤tulo, eliminando otras etiquetas
                        let title = (directTag + restOfTheTitle).replace(/#[^\s]+/g, '').trim();

                        // Elimina cualquier n칰mero de '#' que puedan existir al principio del valor de la variable title y est칠n seguidos de un espacio
                        title = title.replace(/^#+\s*/, '');

                        // /// console.log('Returning title with matches:', title); // Traza antes del return
                        return title;
                    }

                    // En caso de que no haya coincidencia, retorna la l칤nea completa, pero tambi칠n limpiamos posibles '#' al inicio aqu칤.
                    // Se asegura que se aplique la eliminaci칩n de '#' seguidos de un espacio para todos los casos.
                    const finalTitle = firstLine.replace(/^#+\s*/, '').trim();
                    /// console.log('Returning title without matches:', finalTitle); // Traza antes del return
                    return finalTitle;
                    // Asegurarse de devolver una cadena vac칤a si el t칤tulo no se encuentra
                    return title || '';
                },

                setInstanceValue(title) {
                    /// console.log("游 ~ setInstanceValue ~ title:", title)
                    // Verifica si title es una cadena
                    if (typeof title !== "string") {
                        /// console.log("title debe ser una cadena.setInstanceValue ~ title:", title);
                        return ""; // Retorna una cadena vac칤a o maneja el caso como prefieras
                    }

                    // Initial assignment based on title starting with a hashtag
                    if (/^#\w+/.test(title)) {
                        this.instanceValue = title;
                    }

                    // Extract component after the initial tag and dash, refining instanceValue
                    const titleParts = title.match(/^#\w+\s+(.*?)\s*(-|$)/);
                    /// console.log("游 ~ setInstanceValue ~ titleParts:", titleParts)
                    if (titleParts && titleParts[1]) {
                        this.instanceValue = titleParts[1].replace(/#\w+/g, '').trim();
                    } else if (title.includes('-')) {
                        this.instanceValue = title.split('-')[0].trim();
                    } else {
                        this.instanceValue = title.trim();
                    }
                    /// console.log("游 ~ setInstanceValue ~ this.instanceValue:", this.instanceValue)
                    return this.instanceValue;
                },

                generateMetamodelID(title, instanceClass) {
                    // Si instanceClass est치 vac칤o o es null, retorna directamente el title
                    if (!instanceClass) {
                        return title;
                    }

                    // Si instanceClass no est치 vac칤o y el t칤tulo no contiene un gui칩n con un espacio a cada lado
                    if (instanceClass && !title.includes(" - ")) {
                        return `${instanceClass} Name`;
                    }

                    // Si instanceClass no est치 vac칤o y el t칤tulo contiene un gui칩n con un espacio a cada lado
                    if (instanceClass && title.includes(" - ")) {
                        // Extrae el texto a la derecha del gui칩n, incluyendo el gui칩n y los espacios
                        const titleAfterDash = title.substring(title.indexOf(" - ") + 3);
                        // Construye metamodelID usando instanceClass y el texto a la derecha del gui칩n, reemplazando el inicio del t칤tulo por "Name"
                        return `${instanceClass} Name - ${titleAfterDash}`;
                    }

                    // En cualquier otro caso (por precauci칩n), retorna el t칤tulo
                    return title;
                },

                importMetamodelData(metamodelID) {
                    /// console.log("游 ~ importMetamodelData ~ metamodelID:", metamodelID)
                    // Encuentra la secci칩n que coincide con el metamodelID proporcionado.
                    const section = this.metamodel.sections.find((section) => section.name === metamodelID);

                    if (section) {
                        /// console.log("游 ~ importMetamodelData ~ section:", section)
                        return section;
                    }
                    /// console.log('No se encontr칩 ninguna secci칩n que coincida con el metamodelID:', metamodelID);
                    return null;
                },

                parseToHTML(content) {
                    if (typeof content !== 'string') {
                        console.error('Expected content to be a string, but got:', typeof content, content);
                        return ''; // Retorna una cadena vac칤a o maneja el error como prefieras
                    }

                    // Define un array con los s칤mbolos que usan los markers
                    const markerSymbols = this.markerSymbols;

                    // Procesa etiquetas y marcadores primero
                    let processedTagsContent = content.replace(/(^|\s)(#[^\s#]+)/g, (match, p1, p2) => {
                        if (markerSymbols.some(symbol => p2[1] === symbol)) {
                            // Si es un marcador
                            return `${p1}${this.parseMarker(p2.slice(1))}`;
                        } else {
                            // Si es una etiqueta
                            return `${p1}${this.parseTag(p2.slice(1))}`;
                        }
                    });
                    return processedTagsContent;
                },

                openInfoModal(block) {
                    /// console.log("游 ~ openInfoModal ~ block:", block)
                    this.selectedInfoBlock = block;
                    this.selectedBlockId = block.id; // Aseg칰rate de tener selectedBlockId definido en tu data()
                    this.selectedBlockInfoURL = `https://xbokmd.github.io/plastilinn/raw.html#/docs/xBoK/sections/${block.replace(/ /g, '_')}`;
                    // Busca el 칤ndice de la l칤nea bas치ndose en el ID 칰nico
                    this.selectedBlockIndex = this.model.findIndex((item) => item.id === block.id);
                    this.isInfoModalOpen = true;
                    this.$nextTick(() => {
                        // Aseg칰rate de que el contenedor del editor est칠 disponible en el DOM
                        this.selectedBlockInfoURL;
                    });

                    // Definir dimensiones y posici칩n de la ventana
                    const ancho = 900; // Ancho de la ventana
                    const alto = 600; // Alto de la ventana
                    // Calcular posici칩n central
                    const y = window.top.outerHeight / 2 + window.top.screenY - (alto / 2);
                    const x = window.top.outerWidth / 2 + window.top.screenX - (ancho / 2);

                    // Abrir nueva ventana
                    // eslint-disable-next-line max-len
                    window.open(this.selectedBlockInfoURL, 'Modal', `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, copyhistory=no, width=${ancho}, height=${alto}, top=${y}, left=${x}`);
                },

                findParentLocators(locator) {
                    const parts = locator.split('.');
                    const parents = [];

                    for (let i = 1; i < parts.length; i++) {
                        parents.push(parts.slice(0, i).join('.'));
                    }

                    return parents;
                },

                // EDIT BLOCK

                initEditor() {
                    if (this.editor) {
                        this.editor.destroy(); // Destruye la instancia anterior del editor
                    }
                    this.editor = new toastui.Editor({
                        el: document.querySelector('#editor-container'),
                        initialEditType: 'markdown',
                        previewStyle: 'tab',
                        height: '340px',
                        width: '500px',
                        hideModeSwitch: true,
                        initialValue: this.selectedBlockContent, // Asume que `editingContent` es tu contenido actual que quieres editar
                    });
                },

                openBlockEditModal(block) {
                    this.updateModelMarkdown();
                    this.selectedBlockId = block.id; // Aseg칰rate de tener selectedBlockId definido en tu data()
                    this.selectedBlockContent = block.content;
                    this.selectedBlockIndex = this.model.findIndex((item) => item.id === block.id);
                    this.isBlockEditModalOpen = true;
                    this.$nextTick(() => {
                        // Aseg칰rate de que el contenedor del editor est칠 disponible en el DOM
                        this.initEditor();
                    });
                },

                generateSuggestionPrompt() {
                    let suggestionPrompt = '';
                    this.updateModelMarkdown();
                    const block = this.model.find((b) => b.id === this.selectedBlockId);
                    const title = block ? block.title : 'Title not found';
                    const metamodelID = block ? block.metamodelID : 'metamodelID not found';
                    const { modelMarkdown } = this;
                    const blockExample = block ? block.metamodel.example : 'Example not found';
                    suggestionPrompt = `As a business model design expert for startups, you specialize in refining business models through detailed, specific feedback and brainstorming tailored to each startup's unique aspects. Your role is to assist in drafting a document that accurately describes a business model, focusing on clear, structured, and relevant advice. Your approach involves:\n\n
                    Listening closely to understand the specifics of the business.\n
                    Providing concise, targeted guidance without unnecessary repetition or formalities.\n
                    Offering step-by-step feedback to ensure the document effectively captures the business model.\n
                    You focus on the client's needs and how to best articulate their business model.\n
                    GOAL: Help the user write the "${metamodelID}" section of a document that describes his project business model. Here's some information about my Business:\n\n`
                        + `--- business model start ---\n\n`
                        + `${modelMarkdown}\n\n`
                        + `--- business model end ---\n\n
                    QUESTION: Please suggest content for the "${metamodelID}" (${title}) section of the business model.
                    WRITE your answer in PLASTILINN FORMAT, which consists of the text of the answer without any comments or similar, that closely adheres to the format and style of the plastilinn (taking the {block example} as a reference example of a properly formatted answer). In your response, each list component should begin with '#tag', followed by the name, and then a description on a new line. This is an example of an answer for the company Space X, an aerospace manufacturer and space transportation company:\n\n`
                        + `--- example-answer start ---\n\n`
                        + `${blockExample}\n\n`
                        + `--- example-answer end ---\n\n`
                        + `You can copy/paste this answer to your plastilinn doc`;
                    return suggestionPrompt;
                },

                showGeneratedContent() {
                    this.generatedContent = this.generateSuggestionPrompt();
                },

                copyToClipboard() {
                    const textarea = document.createElement('textarea');
                    textarea.value = this.generatedContent;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    alert('Content copied to clipboard');
                },

                openNewWindowWithPrompt() {
                    const url = "https://chatgpt.com/g/g-CqzH3wBOC-plastilinn-business-advisor";
                    const ancho = 800;
                    const alto = 600;
                    const y = window.top.outerHeight / 2 + window.top.screenY - (alto / 2);
                    const x = window.top.outerWidth / 2 + window.top.screenX - (ancho / 2);
                    window.open(url, '_blank', `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, width=${ancho}, height=${alto}, top=${y}, left=${x}`);
                },

                sendMessageToBot() {
                    const suggestionPrompt = this.generateSuggestionPrompt();
                    // El webchat est치 listo. Aqu칤 puedes enviar mensajes o realizar acciones.
                    //window.botpressWebChat.mergeConfig({className: 'plastilinnChatBot', showCloseButton: true });
                    //window.botpressWebChat.sendEvent({type: 'createConversation' });
                    window.botpressWebChat.sendPayload({
                        type: 'text',
                        text: suggestionPrompt
                    });
                    window.botpressWebChat.sendEvent({ type: 'show' });
                },

                receiveBotAnswer() {
                    window.botpressWebChat.onEvent(
                        (event) => {
                            if (event.type === 'MESSAGE.RECEIVED') {
                                console.log('A new message was received!')
                            }
                        },
                        ['MESSAGE.RECEIVED']
                    )

                },

                generateSuggestionPromptORIG() {
                    let suggestionPrompt = '';
                    this.updateModelMarkdown();
                    const block = this.model.find((b) => b.id === this.selectedBlockId);
                    const title = block ? block.title : 'Title not found';
                    const metamodelID = block ? block.metamodelID : 'metamodelID not found';
                    const { modelMarkdown } = this;
                    const blockExample = block ? block.metamodel.example : 'Example not found';
                    suggestionPrompt = `As a business model design expert for startups, you specialize in refining business models through detailed, specific feedback and brainstorming tailored to each startup's unique aspects. Your role is to assist in drafting a document that accurately describes a business model, focusing on clear, structured, and relevant advice. Your approach involves:\n\n
                                Listening closely to understand the specifics of the business.\n
                                Providing concise, targeted guidance without unnecessary repetition or formalities.\n
                                Offering step-by-step feedback to ensure the document effectively captures the business model.\n
                                You focus on the client's needs and how to best articulate their business model.\n
                                GOAL: Help the user write the "${metamodelID}" section of a document that describes his project business model. Here's some information about my Business:\n\n`
                        + `--- business model start ---\n\n`
                        + `${modelMarkdown}\n\n`
                        + `--- business model end ---\n\n`
                        + `QUESTION: Please suggest content for the "${metamodelID}" (${title}) section of the business model.\n\n`
                        + `WRITE your answer in PLASTILINN FORMAT, which consists of the text of the answer without any comments or similar, that closely adheres to the format and style of the plastilinn (taking the {block example} as a reference example of a properly formatted answer). In your response, each list component should begin with '#tag', followed by the name, and then a description on a new line. This is an example of an answer for the company Space X, an aerospace manufacturer and space transportation company:\n\n`
                        + `--- example-answer start ---\n\n`
                        + `${blockExample}\n\n`
                        + `--- example-answer end ---\n\n`
                        + `You can copy/paste this answer to your plastilinn doc`;
                    return suggestionPrompt;
                },

                sendMessageToBotORIG() {
                    const suggestionPromptData = this.generateSuggestionPromptData(); // Asume que esta funci칩n ahora genera los datos necesarios, no el texto completo.
                    window.botpressWebChat.mergeConfig({ className: 'plastilinnChatBot', showCloseButton: true });
                    window.botpressWebChat.sendEvent({ type: 'show' });
                    window.botpressWebChat.sendEvent({
                        type: 'custom',
                        payload: {
                            type: 'suggestionPromptData',
                            data: suggestionPromptData, // Env칤a los datos necesarios como parte del payload.
                        },
                    });
                },

                saveChanges() {
                    const editedContent = this.editor.getMarkdown();
                    const oldTitle = this.extractBlockTitle(this.selectedBlockContent); // Utiliza tu m칠todo existente para extraer el t칤tulo
                    const newTitle = this.extractBlockTitle(editedContent); // Suponiendo que tengas una funci칩n similar para el contenido editado

                    if (oldTitle !== newTitle) {
                        alert("You have changed the title of a block. If you have references to this title in the document, " +
                            "you might want to use the search and replace feature within the sidebar filter. " +
                            `Search "${oldTitle}" and replace it with "${newTitle}"`);
                    }

                    if (this.selectedBlockIndex !== null) {
                        // Encuentra el ID del bloque seleccionado para poder pasarlo al m칠todo de actualizaci칩n.
                        const blockId = this.model[this.selectedBlockIndex].id;

                        // Actualiza el bloque utilizando el m칠todo de actualizaci칩n que maneja la l칩gica de recalculo.
                        this.updateModelBlockContent(blockId, editedContent);

                        // Nota: No necesitas procesar tags, title, etc., aqu칤, ya que eso se manejar치 en el m칠todo de rec치lculo.
                    }
                    this.updateModelMarkdown();
                    const markdownContent = this.modelMarkdown; // Obtiene el valor actual de modelMarkdown
                    this.newMarkdownContent = markdownContent; // Almacena el contenido en el estado
                    this.processNewContent();
                    this.closeModal();

                    // Despu칠s de guardar, verifica si autoDownload est치 habilitado
                    if (this.autoDownloadEnabled) {
                        this.downloadMarkdown(); // Asume que este es tu m칠todo de descarga existente
                    }
                    // this.highlightTitlesInContent();
                },

                closeModal() {
                    this.isBlockEditModalOpen = false;
                },

                // NAVIGATION

                highlightOnLoad() {
                    this.$nextTick(() => {
                        if (window.location.hash) {
                            const hash = decodeURIComponent(window.location.hash.substring(1)); // Decodifica el hash.
                            this.highlightBlock(hash);
                        }
                    });
                },

                highlightBlock(id) {
                    const element = document.getElementById(id);
                    if (element) {
                        element.classList.add('highlight');
                        setTimeout(() => element.classList.remove('highlight'), 5000);
                    }
                },

                highlightFilteredBlocks() {
                    this.$nextTick(() => {
                        // Asumiendo que tienes un array 'filteredBlocks' que contiene los bloques filtrados
                        this.filteredBlocks.forEach(block => {
                            const element = document.getElementById(block.title); // Asumiendo que el 'id' del elemento HTML corresponde al 'title' del bloque
                            if (element) {
                                element.classList.add('highlight');
                                setTimeout(() => element.classList.remove('highlight'), 5000);
                            }
                        });
                    });
                },

                // MODEL PROCESSING

                assignUids() {
                    let uid = 1; // Inicia el contador de UID en 1 o cualquier otro valor inicial que prefieras.
                    this.model.forEach((block) => {
                        block.uid = uid++; // Asigna el UID y luego incrementa el contador.
                    });
                    /// console.log('UIDs assigned to model blocks:', this.model);
                },

                resetDepthCounters() {
                    this.depthCounters = [0, 0, 0, 0, 0, 0];
                },

                updateModelMarkdown() {
                    // Inicializa una variable para almacenar el contenido concatenado
                    let concatenatedContent = '';

                    // Recorre cada elemento del array model y concatena su contenido con saltos de l칤nea
                    this.model.forEach((item) => {
                        concatenatedContent += `${item.content}\n`;
                    });

                    // Guarda el contenido generado en el campo modelMarkdown del objeto model
                    this.modelMarkdown = concatenatedContent;
                    //this.parseModelMarkdown(concatenatedContent);
                    this.updateTagsArray();
                },

                updateTagsArray() {
                    // Cargar la lista de bloques
                    this.model.forEach((block) => block.tags.forEach((tag) => this.modelTagsArray.add(tag)));
                    // Convertir modelTagsArray a un array, ordenarlo alfab칠ticamente y luego asignar a this.tags
                    this.tags = Array.from(this.modelTagsArray).sort((a, b) => a.localeCompare(b));
                    // Inicializar el filtrado (si necesario)
                    //this.filterBlocks([]);
                },

                // FILTERS AND SEARCH

                setFilterTags(tags) {
                    // Establece las etiquetas seleccionadas directamente
                    this.selectedTags = tags;
                },

                filteredBlocksByTags(tags) {
                    return this.model.filter((block) => block.tags.some((tag) => tags.includes(tag)));
                },

                resetSelectedTagsAndMarkers() {
                    this.selectedTags = [];
                    this.selectedMarkers = [];
                },

                buildTagsQueryList(tags) {
                    // Filtra los bloques que contienen todas las etiquetas especificadas
                    const filteredBlocks = this.model.filter((block) => tags.every((tag) => block.tags.includes(tag)));
                    // Construye una lista de HTML con los titles de los bloques filtrados
                    let htmlList = '<ul>';
                    filteredBlocks.forEach((block) => {
                        htmlList += `<li>${block.title}</li>`;
                    });
                    htmlList += '</ul>';

                    // Devuelve la lista HTML
                    return htmlList;
                },

                toggleTagSelection(tag) {
                    console.log("游 ~ toggleTagSelection ~ tag:", tag)
                    const index = this.selectedTags.indexOf(tag);
                    if (index > -1) {
                        this.selectedTags.splice(index, 1); // Si la etiqueta ya est치 seleccionada, qu칤tala
                    } else {
                        this.selectedTags.push(tag); // Si no, a침치dela
                    }
                },

                toggleMarkerSelection(marker) {
                    // Asume que los marcadores ya se gestionan con su propio sistema de prefijos o identificaci칩n
                    const index = this.selectedMarkers.indexOf(marker);
                    if (index > -1) {
                        this.selectedMarkers.splice(index, 1); // Si el marcador ya est치 seleccionado, qu칤talo
                    } else {
                        this.selectedMarkers.push(marker); // Si no, a침치delo
                    }
                },

                highlightText(text, terms) {
                    if (!terms.length) return text; // Si no hay t칠rminos, devuelve el texto tal cual

                    // Asegura que terms sea un array. Si no lo es, convi칠rtelo.
                    if (!Array.isArray(terms)) {
                        terms = [terms];
                    }

                    // Preparar una expresi칩n regular que identifique si estamos dentro de una etiqueta HTML
                    const htmlTagRegex = /<\/?[^>]+>/gi;

                    // Esta funci칩n de reemplazo verifica si el t칠rmino est치 dentro de una etiqueta HTML
                    function replacementFunction(match, offset, fullText) {
                        // Encuentra todos los tags en el texto
                        let tagMatch;
                        let isInTag = false;
                        while ((tagMatch = htmlTagRegex.exec(fullText)) !== null) {
                            const tagStart = tagMatch.index;
                            const tagEnd = tagMatch.index + tagMatch[0].length;
                            if (offset >= tagStart && offset < tagEnd) {
                                // Si el match est치 dentro de un tag, marcamos isInTag como verdadero y rompemos el ciclo
                                isInTag = true;
                                break;
                            }
                        }

                        // Si el match est치 dentro de un tag, lo devuelve sin modificarlo
                        if (isInTag) {
                            return match;
                        } else {
                            // Si no est치 dentro de un tag, aplica el resaltado
                            return `<span class="highlight-text">${match}</span>`;
                        }
                    }

                    // Resalta cada t칠rmino
                    terms.forEach(term => {
                        const regex = new RegExp(term, 'gi');
                        text = text.replace(regex, replacementFunction);
                    });

                    return text;
                },

                escapeRegExp(string) {
                    return string.replace(/[.*+?^${ }()|[\]\\]/g, '\\$&'); // Escapa caracteres especiales para regex
                },

                replaceMatches() {
                    if (!this.searchQuery || !this.replaceText) {
                        alert("Por favor, completa ambos campos de b칰squeda y reemplazo.");
                        return;
                    }

                    // Utiliza el m칠todo escapeRegExp correctamente llamado con 'this.'
                    const regex = new RegExp(this.escapeRegExp(this.searchQuery), 'gi');

                    this.model.forEach((block) => {
                        if (regex.test(block.content)) {
                            // Reemplaza todas las coincidencias en el contenido del bloque
                            const updatedContent = block.content.replace(regex, this.replaceText);

                            // Llama a updateModelBlockContent para cada bloque afectado
                            // Esto asegurar치 que todos los campos dependientes se actualicen adecuadamente
                            this.updateModelBlockContent(block.id, updatedContent);
                        }
                    });

                    // Limpia los campos de b칰squeda y reemplazo despu칠s del proceso
                    this.searchQuery = '';
                    this.replaceText = '';

                    // Opcionalmente, puedes llamar a otros m칠todos si es necesario actualizar la UI o el estado global
                },

                prepareMarkers() {
                    const markers = {};
                    if (this.metamodel.markers && Array.isArray(this.metamodel.markers)) {
                        this.metamodel.markers.forEach((marker) => {
                            // Aseg칰rate de que marker.name existe y es una cadena v치lida
                            if (marker.name && typeof marker.name === 'string') {
                                if (!markers[marker.name]) {
                                    markers[marker.name] = new Set(); // Usa un Set para evitar valores duplicados
                                }
                                // Verifica si marker.values es una cadena y convi칠rtela en un arreglo si es necesario
                                const values = typeof marker.values === 'string' ? marker.values.split(',') : marker.values;
                                // Aseg칰rate de que values sea un arreglo antes de intentar iterar sobre 칠l
                                if (Array.isArray(values)) {
                                    values.forEach(value => markers[marker.name].add(value.trim())); // Usa trim para eliminar espacios en blanco al inicio y al final
                                } else {
                                    // Si marker.values no es un arreglo ni una cadena, muestra una advertencia
                                    console.warn(`Expected marker.values to be an array or a string, got:`, typeof marker.values, marker.values);
                                }
                            }
                        });
                    }

                    // Convierte los sets a arrays y elimina espacios en blanco de los valores
                    for (const markerName in markers) {
                        markers[markerName] = Array.from(markers[markerName]);
                    }
                    return markers;
                },

                toggleMarkerSelection(markerValue) {
                    const index = this.selectedMarkers.indexOf(markerValue);
                    if (index > -1) {
                        // El marcador ya est치 seleccionado, quitarlo del array
                        this.selectedMarkers.splice(index, 1);
                    } else {
                        // El marcador no est치 seleccionado, a침adirlo al array
                        this.selectedMarkers.push(markerValue);
                    }

                    // Opcional: Puedes llamar aqu칤 al m칠todo que actualiza el filtro de bloques si deseas que los bloques se actualicen inmediatamente despu칠s de cambiar la selecci칩n.
                    // this.updateBlocksFilter();
                },

                updateFilter(selectedMarker) {
                    // Aqu칤 puedes implementar la l칩gica para filtrar los bloques bas치ndose en el marcador seleccionado.
                    // Por ejemplo, podr칤as ajustar la propiedad 'filteredBlocks' para que solo incluya bloques que coincidan con el marcador seleccionado.
                    this.filteredBlocks = this.model.filter(block => {
                        // Suponiendo que 'block.markers' es un array de marcadores asociados con el bloque
                        return block.markers.includes(selectedMarker);
                    });
                },

                // FORMATING

                // ARTIFACTS

                // M칠todo para cambiar a la secci칩n "Guides" y cargar una gu칤a espec칤fica por URL
                activateGuidesAndLoadGuide(url) {
                    // Cambia la secci칩n activa del sidebar a "Guides"
                    this.changeSidebar('guides');

                    // Espera un momento para asegurar que la interfaz se haya actualizado
                    this.$nextTick(() => {
                        // Carga la gu칤a especificada por la URL
                        this.loadGuideMarkdownContent(url);
                    });
                },

                async loadGuideMarkdownContent(url) {
                    if (url) {
                        try {
                            const response = await fetch(url);
                            const markdown = await response.text();
                            // Aqu칤 convertir칤as el Markdown a HTML
                            // Puedes usar la librer칤a marked.js como antes mencion칠
                            this.markdownGuideContent = marked.parse(markdown);
                        } catch (error) {
                            /// console.log("游 ~ loadGuideMarkdownContent ~ error:", error)
                            this.markdownContent = '';
                        }
                    } else {
                        this.markdownGuideContent = '';
                    }
                },

                setArtifactBusinessModelCanvas() {
                    this.isArtifactModalOpen = true;
                },

                // DOWNLOAD AND EXPORT

                downloadMarkdown() {
                    // Asume que modelMarkdown y modelName ya est치n actualizados
                    this.updateModelMarkdown();
                    const markdownContent = this.modelMarkdown; // Obtiene el valor actual de modelMarkdown
                    this.newMarkdownContent = markdownContent; // Almacena el contenido en el estado
                    const { modelName } = this; // Obtiene el nombre actual del modelo
                    const timestamp = new Date().toISOString().replace(/[:-]|\.\d{3}/g, ''); // Genera un timestamp en el formato deseado
                    const fileName = `${modelName} - saved ${timestamp}.md`; // Construye el nombre del archivo

                    // Crea un Blob con el contenido Markdown
                    const blob = new Blob([markdownContent], { type: 'text/markdown' });

                    // Crea un enlace para descargar el archivo
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName;

                    // Simula un clic en el enlace para iniciar la descarga y luego limpia
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },

                processLoadedMarkdown() {
                    if (!this.newMarkdownContent) {
                        console.error("No hay contenido de Markdown para cargar.");
                        return;
                    }

                    // Simula la carga y el procesamiento del contenido Markdown
                    this.parseModelMarkdown(this.newMarkdownContent);
                },

                processNewContent() {
                    // Resetear model a un array vac칤o
                    this.model = [];
                    this.resetDepthCounters();
                    const content = this.newMarkdownContent;
                    // Aqu칤 debes invocar la l칩gica que normalmente usas para procesar el contenido Markdown cargado.
                    // Por ejemplo, si tienes un m칠todo que parsea el Markdown a bloques del modelo, 칰salo aqu칤.
                    this.parseModelMarkdown(content);
                },

                downloadHTML() {
                    // Convierte el Markdown a HTML
                    this.updateModelMarkdown();
                    // eslint-disable-next-line no-undef
                    const htmlContent = marked.parse(this.modelMarkdown);
                    const { modelName } = this; // Obtiene el nombre actual del modelo
                    const timestamp = new Date().toISOString().replace(/[:-]|\.\d{3}/g, ''); // Genera un timestamp en el formato deseado
                    const fileName = `${modelName} - saved ${timestamp}.html`; // Construye el nombre del archivo

                    // Opcional: Si quieres incluir un estilo b치sico en tu HTML exportado, puedes agregarlo aqu칤
                    const htmlWithStyle = `
                                <!DOCTYPE html>
                                <html lang="en">
                                    <head>
                                        <meta charset="UTF-8">
                                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                                                <title>Plastilinn</title>
                                                <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
                                                    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
                                                    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
                                                    </head>
                                                    <body>
                                                        ${htmlContent}
                                                    </body>
                                                    `;

                    // Crea un Blob con el contenido HTML
                    const blob = new Blob([htmlWithStyle], { type: 'text/html' });

                    // Crea un enlace para descargar el archivo
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName; // Puedes personalizar el nombre del archivo

                    // Simula un clic en el enlace para iniciar la descarga y luego limpia
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },

                toggleAutoDownload() {
                    this.autoDownloadEnabled = !this.autoDownloadEnabled;
                },

            },
            mounted() {
                this.processMetamodel(); // Otras inicializaciones pueden ir aqu칤
                this.highlightOnLoad(); // Resalta el elemento si la p치gina se carg칩 con un hash.
                window.addEventListener('hashchange', this.highlightOnLoad);
                if (window.botpressWebChat && typeof window.botpressWebChat.onEvent === 'function') {
                    window.botpressWebChat.onEvent((event) => {
                        if (event.type === 'message' && event.message_type === 'text') {
                            alert(`Respuesta del bot: ${event.text}`);
                        }
                    });
                } else {
                    console.warn('Botpress Web Chat is not loaded.');
                }
                // Configura marked.js para este componente
                marked.setOptions({
                    gfm: true, // Habilita GitHub Flavored Markdown (GFM)
                    breaks: true, // Convierte los saltos de l칤nea simples en <br>
                });
            },
        })
            .mount('#vue-app');
    </script>

    <script>
        window.botpressWebChat.init({
            "composerPlaceholder": "Chat with Plastilinn bot V0.2.0",
            "botConversationDescription": "",
            "botId": "52bd5724-db50-4bd1-8348-092faf88e2a1",
            "hostUrl": "https://cdn.botpress.cloud/webchat/v1",
            "messagingUrl": "https://messaging.botpress.cloud",
            "clientId": "52bd5724-db50-4bd1-8348-092faf88e2a1",
            "webhookId": "d4940c60-2b73-425d-bb52-67d64810a71b",
            "lazySocket": true,
            "themeName": "prism",
            "botName": "Plastilinn bot V0.2.0",
            "frontendVersion": "v1",
            "useSessionStorage": true,
            "showBotInfoPage": true,
            "enableConversationDeletion": true,
            "showPoweredBy": true,
            "theme": "prism",
            "themeColor": "#2563eb",
            "avatarUrl": "",
            "hideWidget": true,
            "useSessionStorage": true,
            "containerWidth": "520",
            "layoutWidth": "520",
        });
    </script>
</body>

</html>