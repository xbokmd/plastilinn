<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web App</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <style>
.hidden {
    display: none;
}

#markdownContainer {
        padding-top: 100px; /* Ajusta este valor según la altura de tus elementos fijos */
    }
    </style>

</head>

<body class="bg-gray-100">
    <div id="top-container">
        <div class="navbar bg-base-100">
            <div class="flex-1">
                <a class="btn btn-ghost text-xl">Plastilinn</a>
            </div>
            <div class="flex-none">
                <ul class="menu menu-horizontal px-1">
                    <li><a>App</a></li>
                    <li><a>Docs</a></li>
                    <li><a>About</a></li>
                </ul>
            </div>
        </div>
        <div id="document-controls" class="container mx-auto mt-8">
            <div class="flex justify-between items-center mb-6">
                <div class="flex items-center space-x-3">
                    <input type="file" id="markdownFileInput" accept=".md"
                        class="file-input file-input-bordered file-input-primary w-full max-w-xs">
                </div>
                <div class="flex space-x-3">
                    <select class="select select-bordered w-full max-w-xs" id="tagsFilter">
                    </select>
                    <button id="downloadBtn"
                        class="btn btn-primary bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md transition">Download</button>
                </div>
            </div>
        </div>
    </div>
    </div>
    <div id="markdownContainer" class="mt-16">
        <div class="hero min-h-screen bg-base-200">
            <div class="hero-content text-center">
                <div class="max-w-md">
                    <h1 class="text-5xl font-bold">Your business plan powered by Artificial Intelligence</h1>
                    <p class="py-6">Plastilinn offers guidance on completing your business model, including aspects
                        such
                        as market analysis, marketing strategies, financial planning, organizational structure,
                        understanding market trends, analyzing customer demographics, and evaluating competitor
                        behavior. It can help you make informed choices by evaluating different strategic options,
                        and
                        provides continuous support and instant feedback, crucial for iterative business development
                        and
                        improvement.</p>
                    <ul class="steps">
                        <li class="step step-primary">Design your Business Model</li>
                        <li class="step">Analyze your Business Model</li>
                        <li class="step">Validate your Business Model</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
        let metamodel = [];
        let model = []; // También aseguramos que `model` esté definido globalmente
        let uniqueId = 0; // Al inicio de tu script o fuera de cualquier función para que sea global
        document.addEventListener('DOMContentLoaded', function () {
            let metamodel = [];

            function downloadJSON() {
                axios.get('https://xbokmd.github.io/plastilinn/metamodel.json')
                    .then(function (response) {
                        metamodel = response.data;
                        console.log(metamodel); // Opcional: Mostrar los datos en la consola

                        // Crear un elemento para mostrar los datos del array "metamodel"
                        const container = document.createElement('div');
                        container.id = 'metamodelContainer';
                        container.className = 'mt-4 p-4 bg-gray-200'; // Añade estilos según necesites

                        // Convertir el array "metamodel" a una cadena JSON para mostrarlo
                        const content = document.createTextNode(JSON.stringify(metamodel, null, 2));
                        container.appendChild(content);

                        // Añadir el contenedor al final del cuerpo del documento
                        document.body.appendChild(container);
                    })
                    .catch(function (error) {
                        console.log(error); // Manejar el error
                    });
            }

            downloadJSON();
        });

        document.addEventListener('DOMContentLoaded', function () {

            const markdownFileInput = document.getElementById('markdownFileInput');
            const markdownContainer = document.getElementById('markdownContainer');

            markdownFileInput.addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    const content = e.target.result;
                    const lines = content.split(/\r?\n/);
                    model = _.map(lines, (line, index) => {
                        // Extracción de etiquetas
                        const rawTags = line.match(/#[^\s#]+/g) || [];
                        const tags = rawTags.map(tag => {
                            const tagName = tag.substring(1); // Simplemente elimina el símbolo '#' al principio
                            return { raw: tag, className: tagName };
                        });

                        // Intentar identificar y procesar títulos con nueva especificación
                        let title = undefined;
                        // La expresión regular ahora permite espacios/guiones al inicio y busca de 2 a 10 hashes
                        const headingMatch = line.match(/^\s*-*\s*#{2,10}\s*(.*)/);
                        if (headingMatch && headingMatch[1]) {
                            // Limpiar el título: elimina hashes y espacios iniciales, mantiene texto después de los hashes
                            title = headingMatch[1].trim();
                            // Eliminar etiquetas del título si es necesario
                            title = title.replace(/#[^\s#]+/g, '').trim();
                            title = title.replace(/\[\[|\]\]/g, '');
                        }

                        return {
                            id: uniqueId++, // Incrementa el ID único para cada objeto del modelo
                            content: line,
                            tags: tags,
                            index: index,
                            title: title // Agregado condicionalmente, undefined si no es un título
                        };
                    });

                    updateTagsFilter();
                    renderModel(); // Asegúrate de ajustar esta función para manejar "title"
                };
                reader.readAsText(file);
            });

            function renderModel(linesToRender = model) {
                console.log("Líneas a renderizar:", linesToRender); // Esto debería mostrarte las líneas que se van a renderizar
                const markdownContainer = document.getElementById('markdownContainer');
                markdownContainer.innerHTML = ''; // Limpiar el contenedor
                const mainContainer = document.createElement('div');
                mainContainer.className = 'flex flex-col';

                _.forEach(model, (lineData) => {

                    const rowWrapperDiv = document.createElement('div');
                    rowWrapperDiv.classList.add('md-line-wrapper');

                    const lineContainer = document.createElement('div');
                    lineContainer.className = 'flex flex-row md-line';

                    // Comprobar si el título de la línea coincide con algún nombre en metamodel
                    const matchingMeta = metamodel.find(meta => meta.name === lineData.title);

                    // Columna para el título
                    const processedContentElement = document.createElement('div');
                    processedContentElement.className = 'text-center bg-gray-50 rounded p-2 custom-flex-1';
                    processedContentElement.textContent = lineData.title ? lineData.title : '';
                    lineContainer.appendChild(processedContentElement);

                    // Mostrar el título de la línea si existe, de lo contrario dejar en blanco
                    processedContentElement.textContent = lineData.title ? lineData.title : '';
                    lineContainer.appendChild(processedContentElement);

                    // Contenedor para el contenido original (editable)
                    const contentContainer = document.createElement('div');
                    contentContainer.className = 'text-center bg-gray-50 rounded p-2 custom-flex-2';
                    const contentElement = document.createElement('div');
                    contentElement.className = 'md-line-content text-left bg-white shadow-md p-4 md:col-span-3';
                    contentElement.setAttribute('contenteditable', 'true');
                    contentElement.setAttribute('data-id', lineData.id); // Asignar el ID único aquí
                    contentElement.textContent = lineData.content;
                    contentContainer.appendChild(contentElement);

                    contentElement.addEventListener('input', function () {
                        // Captura las etiquetas directamente del contenido, incluyendo el símbolo '#'
                        const newTags = this.textContent.match(/#[^\s#]+/g) || [];
                        // No necesitas limpiar los caracteres especiales para data-tag
                        // Simplemente elimina el símbolo '#' al principio para el valor del data-tag
                        const cleanedTags = newTags.map(tag => tag.substring(1)); // Mantén los caracteres especiales

                        // Limpiar el contenedor de etiquetas actual antes de añadir las nuevas
                        tagsElement.innerHTML = '';

                        // Generar y añadir los nuevos elementos de etiquetas con data-tag
                        cleanedTags.forEach(tag => {
                            const tagSpan = document.createElement('span');
                            tagSpan.setAttribute('data-tag', tag); // Asigna el valor de la etiqueta al atributo 'data-tag'
                            tagSpan.textContent = tag; // Establece el texto visible del span como el valor de la etiqueta, sin '#'
                            tagsElement.appendChild(tagSpan);
                            tagsElement.appendChild(document.createTextNode(' ')); // Espacio entre etiquetas
                        });
                        updateTagsFilter();
                    });

                    contentElement.textContent = lineData.content;
                    contentContainer.appendChild(contentElement);

                    // Columna para las etiquetas
                    const tagsElement = document.createElement('div');
                    tagsElement.className = 'tags-container ext-gray-500 text-sm text-center bg-gray-50 rounded p-2 custom-flex-3';
                    lineData.tags.forEach(tag => {
                        const tagSpan = document.createElement('span');
                        // Limpiar el texto de la etiqueta para usarlo como nombre de clase
                        // Eliminamos el símbolo '#' y caracteres especiales, reemplazando con guiones si es necesario
                        tagSpan.setAttribute('data-tag', tag.className); // Almacena el valor de la etiqueta
                        tagSpan.textContent = tag.className; // Establece el texto visible del span
                        tagsElement.appendChild(tagSpan);
                        tagsElement.appendChild(document.createTextNode(' ')); // Espacio entre etiquetas
                    });

                    // Añadir el contenedor de contenido editable en el medio
                    lineContainer.insertBefore(contentContainer, null); // Asegúrate de que esto esté correctamente insertado

                    lineContainer.appendChild(tagsElement);

                    // Añadir el contenedor de la línea al contenedor principal
                    mainContainer.appendChild(lineContainer);

                    // Asegurarse de envolver correctamente el lineContainer con rowWrapperDiv
                    rowWrapperDiv.appendChild(lineContainer); // Envolver lineContainer dentro de rowWrapperDiv

                    // Añadir el contenedor de la línea (ahora correctamente envuelto) al contenedor principal
                    mainContainer.appendChild(rowWrapperDiv);
                });

                // Añadir el contenedor principal al contenedor de Markdown
                markdownContainer.appendChild(mainContainer);
            }

            function setupEditableContent(contentElement) {
                const editIndicator = document.createElement('span');
                editIndicator.className = 'text-gray-400 text-xl cursor-pointer absolute right-0 mr-4 opacity-0';
                editIndicator.textContent = '✏️';
                contentElement.parentNode.appendChild(editIndicator);

                contentElement.addEventListener('focus', function () {
                    this.classList.add('border', 'border-blue-500', 'rounded', 'p-1');
                });
                contentElement.addEventListener('blur', function () {
                    this.classList.remove('border', 'border-blue-500', 'rounded', 'p-1');
                });
                contentElement.addEventListener('mouseenter', function () {
                    editIndicator.style.opacity = '1';
                });
                contentElement.addEventListener('mouseleave', function () {
                    editIndicator.style.opacity = '0';
                });
            }
            document.getElementById('tagsFilter').addEventListener('change', filterLinesBySelectedTags);

            function filterLinesBySelectedTags() {
    const selectedTag = document.getElementById('tagsFilter').value;
    console.log("Etiqueta seleccionada:", selectedTag);

    // Obtener todos los elementos que representan las líneas de contenido
    const wrappers = document.querySelectorAll('.md-line-wrapper');

    wrappers.forEach(wrapper => {
        // Busca dentro del wrapper si existe alguna etiqueta que coincida con la seleccionada
        const tags = wrapper.querySelectorAll('.tags-container span');
        let tagFound = false; // Indicador si se encuentra la etiqueta dentro del wrapper

        tags.forEach(tag => {
            if (tag.textContent === selectedTag) {
                tagFound = true;
            }
        });

        // Si se encuentra la etiqueta o si no se ha seleccionado ninguna (valor ''), muestra el wrapper
        if (tagFound || selectedTag === '') {
            wrapper.classList.remove('hidden');
        } else {
            // En caso contrario, oculta el wrapper
            wrapper.classList.add('hidden');
        }
    });
}


            document.addEventListener('DOMContentLoaded', function () {

                document.getElementById('tagsFilter').addEventListener('change', filterLinesBySelectedTags);
            });
        });

        document.addEventListener('DOMContentLoaded', function () {

            document.getElementById('downloadBtn').addEventListener('click', downloadModel);

            function downloadModel() {
                let fileContent = model.map(obj => obj.content).join('\n'); // Concatena el contenido con saltos de línea

                const fileName = `Business model ${formatDate(new Date())}.md`; // Usa la función formatDate para crear un nombre de archivo único
                downloadFile(fileName, fileContent); // Llama a la función downloadFile con el nombre del archivo y el contenido a descargar
            }


            function formatDate(date) {
                const year = date.getFullYear();
                const month = (`0${date.getMonth() + 1}`).slice(-2);
                const day = (`0${date.getDate()}`).slice(-2);
                const hours = (`0${date.getHours()}`).slice(-2);
                const minutes = (`0${date.getMinutes()}`).slice(-2);
                const seconds = (`0${date.getSeconds()}`).slice(-2);
                return `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
            }

            function downloadFile(fileName, content) {
                const element = document.createElement('a');
                element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
                element.setAttribute('download', fileName);

                element.style.display = 'none';
                document.body.appendChild(element);

                element.click();

                document.body.removeChild(element);
            }
        });

        document.addEventListener('input', function (e) {
            if (e.target.getAttribute('contenteditable') === "true") {
                const id = parseInt(e.target.getAttribute('data-id'), 10); // Obtiene el ID como número
                const editedContent = e.target.textContent;

                // Busca y actualiza el objeto correspondiente en `model`
                const lineObj = model.find(obj => obj.id === id);
                if (lineObj) {
                    lineObj.content = editedContent;
                }
            }
        });

        function updateTagsFilter() {
            // Obtener todas las etiquetas únicas de `model`
            const allTags = new Set(); // Usamos un Set para evitar etiquetas duplicadas
            model.forEach(item => {
                item.tags.forEach(tag => {
                    allTags.add(tag.className); // Suponiendo que `className` contiene el nombre de la etiqueta sin '#'
                });
            });

            // Convertir el Set a Array y ordenarlo alfabéticamente
            const sortedTags = Array.from(allTags).sort();

            // Obtener el elemento del selector
            const tagsFilter = document.getElementById('tagsFilter');
            // Limpiar opciones existentes
            tagsFilter.innerHTML = '';

            // Opción predeterminada
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select a tag...';
            tagsFilter.appendChild(defaultOption);

            // Crear una opción para cada etiqueta única
            sortedTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagsFilter.appendChild(option);
            });
        }

    </script>

</body>

</html>