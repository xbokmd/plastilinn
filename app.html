<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web App</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://unpkg.com/@heroicons/vue@1.0.4/dist/heroicons.js"></script>
    <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
    <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
    <style>
        .btn {
            padding: 0.2rem;
        }

        ion-icon {
            font-size: 1.2rem;
        }

        .highlight-text {
            background-color: blue;
            color: white;
            padding: 0 4px;
            border-radius: 3px;
        }
    </style>
</head>

<body>
    <div id="vue-app">
        <div class="min-h-screen h-screen flex flex-col">
            <header class="border-b border-gray-200">
                <div id="top-container" class="bg-gray-200 w-full fixed">
                    <div id="navbar" class="navbar bg-base-100 shadow-xl">
                        <div class="navbar-start">
                            <div class="p-5">
                                <!-- Logo como imagen -->
                                <img src="assets/logo.png" alt="Logo de mi empresa" class="h-8">
                                <!-- Logo como texto o SVG, aqu√≠ un ejemplo con texto -->
                            </div>
                            <a class="btn btn-ghost text-xl">Plastilinn</a>V0.1.0
                        </div>
                        <div class="navbar-center">
                            <div class="flex-1 text-center bg-gray-200 rounded-lg p-2 m-2">
                                <h4 v-if="modelName">{{ modelName }}</h4>
                            </div>
                        </div>
                        <div class="navbar-end">
                            <div class="join">
                                <button id="downloadBtn" @click="downloadMarkdown" class="btn join-item btn-primary">
                                    <ion-icon name="cloud-download-outline"></ion-icon>
                                    Download
                                </button>
                                <button id="exportBtn" @click="downloadHTML" class="btn join-item btn-primary">
                                    <ion-icon name="download-outline"></ion-icon>
                                    Export
                                </button>
                                <button @click="toggleAutoDownload"
                                    :class="{'bg-green-500': autoDownloadEnabled, 'bg-gray-500': !autoDownloadEnabled}"
                                    class="btn join-item btn-primary">
                                    <ion-icon name="toggle-outline"></ion-icon>
                                    Auto Download {{ autoDownloadEnabled ? 'ON' : 'OFF' }}
                                </button>
                                <button @click="handleRefresh" class="btn join-item btn-primary">
                                    <ion-icon name="refresh-circle-outline"></ion-icon>Refresh</button>
                            </div>
                        </div>
                    </div>

                </div>
            </header>

            <!-- main container -->

            <div class="flex-1 flex flex-row overflow-y-hidden">
                <nav class="order-first w-1/4 m-4 p-2 overflow-y-auto" style="min-width: 440px">
                    <div class="flex flex-row flex-wrap gap-2 bg-white sticky top-0">
                        <div class="flex flex-row justify-between mb-4 gap-2">
                            <button @click="changeSidebar('home')" class="collapse-filter-button btn btn-primary">
                                <ion-icon name="link-outline"></ion-icon>Home</button>
                            <button @click="changeSidebar('guides')" class="collapse-filter-button btn btn-primary">
                                <ion-icon name="document-text-outline"></ion-icon size="large">Guides</button>
                            <button @click="changeSidebar('index')" class="collapse-filter-button btn btn-primary">
                                <ion-icon name="albums-outline"></ion-icon>Index</button>
                            <button @click="changeSidebar('filter')" class="collapse-filter-button btn btn-primary">
                                <ion-icon name="filter-outline"></ion-icon></ion-icon size="large">Filter</button>
                        </div>
                    </div>

                    <!-- Secciones con visibilidad condicional -->
                    <div
                        v-bind:class="{ block: currentSidebarSection === 'home', hidden: currentSidebarSection !== 'home' }">
                        <div id="sidebar-home">
                            <div>
                                <p>Plastilinn allows you to create a business model and evolve it to make it better and
                                    better. </p>
                                <div>
                                    <h5>Guides</h5>
                                    <p>Includes help guides that will make it easier for you to create your business
                                        model, offering you step by step all the information you need and precise
                                        instructions.</p>
                                    <h5>Index</h5>
                                    <p>Allows you to quickly navigate to the section of your plastilin doc that you want
                                        to consult.</p>
                                    <h5>Filter</h5>
                                    <p>Allows you to carry out smart queries by filtering the content of your plastilin
                                        doc.</p>
                                </div>

                                <div tabindex="0" class="collapse bg-base-200">
                                    <div class="collapse-title text-xl font-medium">
                                        <span style="display: inline-block; vertical-align: middle;">
                                            <ion-icon name="information-circle-outline"></ion-icon size="large">
                                        </span>
                                        Help
                                    </div>
                                    <div class="collapse-content">
                                        <p>Click on the info icon <span
                                                style="display: inline-block; vertical-align: middle;">
                                                <ion-icon name="information-circle-outline"></ion-icon
                                                    size="large"></span> at the
                                            right of any section of your document</p>
                                        <p>Click here to access the <a
                                                href="https://xbokmd.github.io/plastilinn/index.html"
                                                target="_blank">plastilinn documentation page</a> (Work in Progress)</p>
                                    </div>
                                </div>
                                <div role="alert" class="alert mt-10">
                                    <ion-icon name="information-circle-outline"></ion-icon>
                                    <h3 class="font-bold">New to plastilin?</h3>
                                    <div class="text-xs">Simply click on the guides button in this sidebar and select
                                        the quickstart guide.</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div
                        v-bind:class="{ block: currentSidebarSection === 'guides', hidden: currentSidebarSection !== 'guides' }">
                        <!-- Select que se muestra u oculta seg√∫n showSelect -->
                        <select @change="loadGuideMarkdownContent($event.target.value)"
                            class="w-full bg-white border border-gray-300 text-gray-700 py-2 px-4 rounded-lg shadow-sm focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-200 transition duration-150 ease-in-out">
                            <option value="">Select a guide</option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/plastilinn_cheatsheet.md">
                                Plastilinn cheatsheet
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/quick_start.md">Quick start
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/using_plastilinn.md">Using
                                plastilinn
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/IA.md">IA
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/idea_definition.md">Idea
                                definition
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/business_model_canvas.md">Business
                                Model Canvas
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/lean_canvas.md">Lean Canvas
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/value_proposition_canvas.md">Value
                                Proposition Canvas
                            </option>
                            <option value="https://xbokmd.github.io/plastilinn/guides/empathy_map.md">Empathy map
                            </option>
                        </select>
                        <!-- Div que muestra el contenido del Markdown seleccionado -->
                        <div v-if="markdownGuideContent">
                            <div v-html="markdownGuideContent"></div>
                        </div>

                        <button
                            @click="setArtifactBusinessModelCanvas('partners', 'activities', 'valuePropositions', 'relationships', 'profile', 'resources', 'channels', 'costLines', 'revenueLines'); isArtifactModalOpen = true"
                            class="btn btn-primary">Business
                            Model Canvas</button>
                    </div>

                    <div
                        v-bind:class="{ block: currentSidebarSection === 'index', hidden: currentSidebarSection !== 'index' }">
                        <div class="index">
                            <ul class="menu p-4 w-80 bg-base-100">
                                <li v-for="block in model.filter(b => b.type === 'section')" :key="block.id"
                                    :class="`pl-${block.depthLevel * 4} p-0`">
                                    <a :href="'#' + block.title">{{ block.title }}</a>
                                </li>
                            </ul>
                        </div>
                    </div>

                    <div
                        v-bind:class="{ block: currentSidebarSection === 'filter', hidden: currentSidebarSection !== 'filter' }">
                        <div class=" flex justify-between bg-white" v-if="filterVisible">
                            <div class="flex flex-col gap-4">
                                <div class="flex flex-col w-full">
                                    <div class="flex flex-col w-full p-4 bg-white rounded-lg shadow-sm">
                                        <!-- B√∫squeda -->
                                        <div class="flex items-center mb-4 p-2 bg-gray-50 rounded-lg shadow">
                                            <ion-icon name="search-outline"></ion-icon>
                                            <input v-model="searchQuery" type="text" placeholder="Search..."
                                                class="input ml-2 bg-gray-50 w-full">
                                        </div>
                                        <!-- Bot√≥n para abrir el modal de b√∫squeda y reemplazo -->
                                        <button @click="showSearchReplaceModal = true" class="btn btn-primary">Abrir
                                            b√∫squeda y reemplazo</button>
                                        <!-- Filtro de etiquetas -->
                                        <div class="flex flex-col">
                                            <div class="flex items-center mb-4 p-2 bg-gray-50 rounded-lg shadow">
                                                <span>Filter tags</span>
                                                <div class="flex flex-wrap gap-2 mt-2">
                                                    <span v-for="tag in selectedTags" :key="tag"
                                                        class="flex items-center justify-center h-8 px-2 text-sm"
                                                        :data-tag="tag">{{ tag }}</span>
                                                </div>
                                                <button @click="resetSelectedTags" class="btn btn-ghost">
                                                    <ion-icon name="refresh-circle-outline"></ion-icon
                                                        size="large">Reset</button>
                                            </div>
                                            <select v-model="selectedTags"
                                                class="select select-bordered w-full p-2 bg-white rounded-lg shadow"
                                                multiple>
                                                <option v-for="tag in tags" :key="tag" :value="tag">{{ tag }}
                                                </option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="">
                                        <!-- Botones para aplicar filtros directamente -->
                                        <div class="rounded-lg shadow-md overflow-hidden border border-red-500 m-2">
                                            <button @click="setFilterTags(['!!!!!', '!!!!'])"
                                                class="bg-red-500 text-white px-4 py-2 hover:bg-red-600 focus:ring-red-500 focus:ring-opacity-50 w-full">
                                                High priority
                                            </button>
                                            <div class="flex items-center bg-gray-100 px-4 py-2">
                                                <p>
                                                    <span data-marker="!!!!!">!!!!!</span> <kbd
                                                        class="kbd kbd-xs">#!!!!!</kbd> or
                                                    <span data-marker="!!!!">!!!!</span> <kbd
                                                        class="kbd kbd-xs">#!!!!</kbd>
                                                </p>
                                            </div>
                                        </div>
                                        <div class="rounded-lg shadow-md overflow-hidden border border-red-500 m-2">
                                            <button @click="setFilterTags(['*****', '?????'])"
                                                class="bg-red-500 text-white px-4 py-2 hover:bg-red-600 focus:ring-red-500 focus:ring-opacity-50 w-full">
                                                High importance or uncertainty
                                            </button>
                                            <div class="flex items-center bg-gray-100 px-4 py-2">
                                                <p>
                                                    <span data-marker="*****">*****</span> <kbd
                                                        class="kbd kbd-xs">#*****</kbd> or
                                                    <span data-marker="?????">?????</span> <kbd
                                                        class="kbd kbd-xs">#?????</kbd>
                                                </p>
                                            </div>
                                        </div>

                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </nav>

                <main class="flex-auto border-l border-r border-gray-200 p-2 overflow-y-auto"
                    style="scroll-behavior: smooth;">
                    <div class="leading-10">
                        <div id="content" class="bg-gray-200 p-1 rounded">
                            <div class="plastilinn-hero hero pt-48" v-if="!modelMarkdownLoaded">
                                <div class="hero-content text-center">
                                    <div class="max-w-md">
                                        <div class="m-auto max-w-6xl p-12">
                                            <div class="flex flex-col md:flex-row">
                                                <div class="md:w-1/2 max-w-md flex flex-col justify-center">

                                                </div>
                                            </div>
                                        </div>
                                        <div
                                            class="md:text-5xl text-2xl uppercase font-black bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-500">
                                            Shape your business with AI
                                        </div>
                                        <div class="text-xl mt-4">Design, analyze and validate your business model.
                                        </div>
                                        <div role="alert" class="alert m-8">
                                            <ion-icon name="alert-circle-outline"></ion-icon>
                                            <span>Upload your plastilinn doc</span>
                                        </div>
                                        <input type="file" @change="loadAndParseModelFile" accept=".md"
                                            class="file-input file-input-bordered file-input-primary w-full max-w-xs m-4">
                                    </div>
                                </div>
                            </div>
                            <div class="modelContainer m-2 p-0">
                                <div class="flex flex-row w-full">
                                    <div class="md-block-wrapper w-full">
                                        <div v-for="block in searchFilteredBlocks" :key="block.id" :id="block.title"
                                            class="md-block flex">
                                            <div
                                                class="md-block-container-middle md-block-content shadow-xl hover:shadow-2xl transition-shadow p-2 ml-2 mr-2 custom-flex-2 w-1/2">
                                                <div v-html="block.contentParsed"></div>
                                            </div>
                                            <div
                                                class="md-block-container-right tags-container text-gray-500 w-full rounded-md text-sm text-center p-2 mt-1 mb-1 w-1/4">
                                                <div
                                                    class="flex flex-col items-start justify-start w-full bg-gray-200 rounded-md text-sm text-gray-500 p-2 mt-1 mb-1 w-1/4">
                                                    <div class="xbok-block-tags flex items-center">
                                                        <button @click="openBlockEditModal(block)"
                                                            class="btn btn-primary btn-outline text-white p-0 rounded opacity-80 hover:opacity-100 focus:opacity-100">
                                                            <ion-icon name="document-outline"></ion-icon size="large">
                                                        </button>
                                                        <div :id="block.metamodel.name"
                                                            class="block-metamodel section inline-flex"
                                                            v-if="block.metamodel">
                                                            <button @click="openInfoModal(block.metamodel.name)"
                                                                class="btn btn-primary btn-outline text-white p-0 rounded opacity-80 hover:opacity-100 focus:opacity-100">
                                                                <ion-icon name="information-circle-outline"></ion-icon>
                                                            </button>
                                                        </div>
                                                        <div class="md-block-container-right markers-container"
                                                            v-html="block.markersParsed">
                                                        </div>
                                                        <div class="md-block-container-right tags-container"
                                                            v-html="block.tagsParsed">
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div id="content" class="mt-48 ml-2 mr-2">
                                <div class="flex flex-row w-full">
                                    <div class="md-block-wrapper w-full">
                                        <div v-for="block in filteredBlocks" :key="block.id" :id="block.title"
                                            class="md-block flex">
                                            <!-- Renderizar los bloques -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </main>


            </div>
            <!-- end main container -->

            <footer class="border-t border-gray-200 p-2">Footer</footer>
        </div>

        <!-- MODAL WINDOWS -->

        <div id="artifact-modal" v-if="isArtifactModalOpen"
            style="position: fixed; top: 5%; left: 5%; width: 90%; height: 90%; z-index: 100; background-color: white; overflow: auto; padding: 20px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);">
            <!-- Usa v-html para insertar el contenido de artifactModalContent como HTML -->
            <button @click="isArtifactModalOpen = false" class="btn">Cerrar</button>
            <div v-html="artifactModalContent"></div>
            <div id="business-model-canvas" class="bg-gray-100 -black h-screen p-5">
                <div class="row-span-2 grid h-3/5 grid-cols-5 bg-white  shadow-lg">
                    <div class="row-span-2 border pl-2">
                        <h3>Key Partners</h2>
                    </div>
                    <div class="row-span-1 border pl-2">
                        <h3>Key activities</h3>
                        <div v-html="buildTagsQueryList(['work'])"></div>
                    </div>
                    <div class="row-span-2 border pl-2">
                        <h3>Value propositions</h3>
                        <div v-html="buildTagsQueryList(['value'])"></div>
                    </div>
                    <div class="border pl-2">
                        <h3>Customer relationships</h3>
                        <div v-html="buildTagsQueryList(['relation'])"></div>
                    </div>
                    <div class="row-span-2 border pl-2>">
                        <h3>Customer segments</h3>
                        <div v-html="buildTagsQueryList(['profile'])"></div>
                    </div>
                    <div class="border pl-2">
                        <h3>Key resources</h3>
                        <div v-html="buildTagsQueryList(['resource'])"></div>
                    </div>
                    <div class="border pl-2">
                        <h3>Channels</h3>
                        <div v-html="buildTagsQueryList(['channel'])"></div>
                    </div>
                </div>
                <div class="grid h-52 grid-cols-2 bg-white shadow-lg">
                    <div class="border pl-2">
                        <h3>Cost lines</h3>
                        <div v-html="buildTagsQueryList(['cost'])"></div>
                    </div>
                    <div class="border pl-2">
                        <h3>Revenue lines</h3>
                        <div v-html="buildTagsQueryList(['revenue'])"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal de b√∫squeda y reemplazo -->
        <div v-if="showSearchReplaceModal"
            class="fixed inset-0 bg-gray-600 bg-opacity-75 flex justify-center items-center">
            <div class="bg-white p-4 rounded-lg shadow-lg flex flex-col">
                <div class="mb-2">
                    <label for="searchText" class="block text-sm font-medium text-gray-700">Texto a buscar</label>
                    <input v-model="searchText" id="searchText" type="text"
                        class="mt-1 p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div class="mb-4">
                    <label for="replaceText" class="block text-sm font-medium text-gray-700">Texto de reemplazo</label>
                    <input v-model="replaceText" id="replaceText" type="text"
                        class="mt-1 p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div class="flex justify-end gap-2">
                    <button @click="showSearchReplaceModal = false" class="btn btn-secondary">Cancelar</button>
                    <button @click="performSearchReplace(searchText)" class="btn mb-2 btn-primary">Reemplazar</button>
                </div>
            </div>
        </div>

        <!-- Modal para editar el contenido del bloqur seleccionada -->
        <div v-if="isBlockEditModalOpen"
            class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full items-center z-50">
            <div class="modal-background absolute inset-0 bg-black opacity-50"></div>
            <div class="relative top-20 mx-auto p-5 border w-4/5 shadow-lg rounded-md bg-white flex flex-col justify-center items-center"
                style="z-index: 100;">
                <!-- Contenedor para marcadores -->
                <div class="markers flex flex-col items-start justify-start m-2">
                </div>
                <div class="flex">
                    <div class="mt-3 text-center">
                        <div class="mt-2">
                            <div id="editor-container"></div>
                        </div>
                        <button class="btn m-2 btn-primary" @click="">
                            <ion-icon name="pricetags-outline"></ion-icon>
                            Tags</button>
                        <button class="btn m-2 btn-primary" @click="sendMessageToBot()">
                            <ion-icon name="hardware-chip-outline"></ion-icon>
                            AI suggest content</button>
                        <button class="btn m-2 btn-primary" @click="saveChanges">
                            <ion-icon name="save-outline"></ion-icon>
                            Save changes</button>
                        <button class="btn m-2 btn-primary" @click="closeModal"><ion-icon size="large"
                                name="close-circle-outline"></ion-icon>
                            Close window</button>
                    </div>
                </div>
            </div>

        </div>
    </div>
    <script>
        Vue.createApp({
            data() {
                return {

                    // APP STATE
                    currentSidebarSection: 'home',
                    isSidebarVisible: true, // Controla la visibilidad de la sidebar
                    isIndexOpen: true,
                    isInfoModalOpen: false,
                    autoDownloadEnabled: true,
                    showGuidesSelect: false, // Controla la visibilidad del select
                    markdownGuideContent: '', // Almacena el contenido del Markdown cargado
                    showSearchReplaceModal: false,
                    isArtifactModalOpen: false,
                    artifactModalContent: '', // Almacenar√° el contenido HTML generado
                    // METAMODEL
                    metamodel: [],
                    // Definir un array con los s√≠mbolos que usan los markers
                    markerSymbols: ['>', '*', '?', '!', '¬°', '=', '+', '-'],
                    // MODEL
                    model: [], // Se utilizar√° para almacenar el modelo de datos creado a partir del Markdown
                    modelName: '',
                    modelMarkdown: '', // Campo para almacenar el contenido Markdown concatenado
                    modelMarkdownLoaded: false, // Variable para controlar si el markdown ha sido cargado y analizado
                    modelTagsArray: new Set(),
                    // MODEL BLOCKS
                    lastId: 0, // Inicializa un contador para los IDs
                    isBlockEditModalOpen: false,
                    selectedBlockContent: '',
                    selectedBlockIndex: null,
                    selectedBlockId: null,
                    tags: [],
                    // BLOCK INFO MODAL
                    selectedInfoBlock: null, // Para almacenar la informaci√≥n del bloque seleccionado
                    selectedBlockInfoURL: null,
                    // FILTERS
                    selectedTags: [], // Almacena las etiquetas seleccionadas
                    selectedBlockTitles: [], // Arreglo para almacenar los titles seleccionados
                    filterVisible: true,
                    // SEARCH
                    searchQuery: '',
                    searchText: '',
                    replaceText: '',
                };
            },
            computed: {

                modelBlocks() {
                    return this.model.map(block => ({
                        ...block,
                        title: this.extractTitle(block.content),
                        htmlContent: this.markdownToHtml(block.content)
                    }));
                },

                parsedModel() {
                    return this.model.map((block) => ({ ...block, contentParsed: marked.parse(block.content) }));
                },

                filteredBlocks() {
                    const blocksWithSections = [];
                    const addedSectionIds = new Set(); // Almacena los IDs de secciones ya a√±adidas
                    this.model.filter((block) => {
                        const tagMatch = this.selectedTags.length === 0 || this.selectedTags.some((tag) => block.tags.includes(tag));
                        const titleMatch = this.selectedBlockTitles.length === 0 || this.selectedBlockTitles.includes(block.title);
                        return tagMatch && titleMatch;
                    }).forEach((block) => {
                        if (block.type === 'item') {
                            const sectionUid = String(block.id).split('.')[0];
                            // Verificar si la secci√≥n ya fue a√±adida, si no, encontrar y a√±adir la secci√≥n
                            if (!addedSectionIds.has(sectionUid)) {
                                const sectionBlock = this.model.find((b) => String(b.id) === sectionUid && b.type === 'section');
                                if (sectionBlock && !blocksWithSections.includes(sectionBlock)) {
                                    blocksWithSections.push(sectionBlock);
                                    addedSectionIds.add(sectionUid);
                                }
                            }
                        }
                        // A√±adir el bloque si es un √≠tem o si es una secci√≥n que no ha sido a√±adida previamente
                        if (block.type === 'section' && !addedSectionIds.has(String(block.id))) {
                            addedSectionIds.add(String(block.id));
                            blocksWithSections.push(block);
                        } else if (block.type === 'item') {
                            blocksWithSections.push(block);
                        }
                    });
                    return blocksWithSections;
                },

                searchFilteredBlocks() {
                    if (!this.searchQuery) {
                        return this.filteredBlocks; // Retorna todos los bloques si no hay t√©rmino de b√∫squeda
                    }
                    // Filtra primero los bloques que contienen el t√©rmino de b√∫squeda en su contenido
                    const filteredBlocks = this.filteredBlocks.filter((block) => block.contentParsed.toLowerCase().includes(this.searchQuery.toLowerCase()));

                    // Luego aplica el resaltado a las coincidencias encontradas en esos bloques filtrados
                    return filteredBlocks.map((block) => {
                        const highlightedContent = this.highlightSearchText(block.contentParsed, this.searchQuery);
                        return { ...block, contentParsed: highlightedContent };
                    });
                },

                searchFilteredBlocksORIGINAL() {
                    if (!this.searchQuery) return this.filteredBlocks;
                    // Utiliza filteredBlocks para mantener los filtros anteriores
                    // Verifica si el contenido del bloque incluye el texto de b√∫squeda
                    // Asume que 'contentParsed' es el contenido que deseas buscar
                    return this.filteredBlocks.filter((block) => block.contentParsed.toLowerCase().includes(this.searchQuery.toLowerCase()));
                },
            },
            methods: {

                changeSidebar(section) {
                    this.currentSidebarSection = section;
                    console.log("üöÄ ~ changeSidebar ~ this.currentSidebarSection:", this.currentSidebarSection)
                    // Aqu√≠ puedes agregar cualquier otra l√≥gica que necesites ejecutar cuando cambies de secci√≥n
                },

                // METAMODEL

                processMetamodel() {
                    // eslint-disable-next-line no-undef
                    axios.get('https://xbokmd.github.io/plastilinn/metamodel.json')
                        .then((response) => {
                            if (response.data && response.data.classes && response.data.sections) {
                                this.metamodel = response.data;
                                console.log('Metamodel loaded:', this.metamodel);
                            } else {
                                console.error('Metamodel received does not have the expected structure');
                            }
                        })
                        .catch((error) => console.error('Error loading metamodel:', error));
                },

                // MODEL LOADING

                loadAndParseModelFile(event) {
                    const file = event.target.files[0];
                    if (!file) {
                        return;
                    }
                    const modelName = this.getModelNameFromFileName(file.name);
                    this.modelName = modelName; // Actualiza modelName con el resultado de la funci√≥n
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        this.parseModelMarkdown(content);
                    };
                    reader.readAsText(file);
                    this.modelMarkdownLoaded = true;
                },

                getModelNameFromFileName(fileName) {
                    let name = fileName.replace(/\.md$/, ''); // Elimina la extensi√≥n ".md"
                    name = name.replace(/ - saved.*$/, ''); // Elimina " - saved" y todo lo que sigue
                    return name;
                },

                parseModelMarkdown(content) {
                    const model = this.splitModelMarkdownIntoBlocks(content);
                    this.model = model.map((blockContent) => this.processBlock(blockContent));
                    this.updateModelMarkdown();
                    this.assignUids();
                    // this.setInstanceValue();
                },

                splitModelMarkdownIntoBlocks(content) {
                    let currentBlock = [];
                    const lines = content.split(/\r?\n/);

                    lines.forEach((line) => {
                        if (/^\s*([-*\d.]*)*\s*#/.test(line)) {
                            if (currentBlock.length > 0) {
                                this.model.push(currentBlock.join('\n'));
                                currentBlock = [];
                            }
                        }
                        currentBlock.push(line);
                    });
                    if (currentBlock.length > 0) {
                        this.model.push(currentBlock.join('\n'));
                    }
                    return this.model;
                },

                // BLOCK PROCESSING

                updateModelBlockContent(blockId, newContent) {
                    const blockIndex = this.model.findIndex(block => block.id === blockId);
                    if (blockIndex !== -1) {
                        // Actualiza el contenido
                        this.model[blockIndex].content = newContent;

                        // Llama a los m√©todos para recalcular los campos dependientes
                        this.updateDependentModelBlockFields(blockIndex);
                    }
                },

                updateDependentModelBlockFields(blockIndex) {
                    const block = this.model[blockIndex];
                    const mdToHTML = this.parseToHTML(block.content);
                    block.contentParsed = marked.parse(mdToHTML);
                    const firstLine = block.content.split('\n')[0];
                    block.type = this.determineBlockType(firstLine);
                    block.depthLevel = this.determineDepthLevel(firstLine);
                    block.title = this.extractBlockTitle(block.content); // Ajustado para usar el m√©todo recalculado
                    block.instanceClass = this.determineInstanceClass(block.content, block.type);
                    const tagResults = this.processTags(block.content);
                    block.tags = tagResults.tags;
                    block.tagsParsed = tagResults.tagsParsed;
                    block.markers = tagResults.markers;
                    block.markersParsed = tagResults.markersParsed;
                    block.instanceValue = this.setInstanceValue(block.title);
                    block.metamodelID = this.generateMetamodelID(block.title, block.instanceClass);
                    block.metamodel = this.importMetamodelData(block.metamodelID);
                    // Aqu√≠ puedes agregar m√°s campos para recalcular si es necesario
                },

                processBlock(blockContent, blockId = null) {
                    let block;
                    let isNewBlock = false;

                    if (blockId == null) {
                        // Creaci√≥n de un nuevo bloque
                        this.lastId += 1;
                        block = { id: this.lastId, content: blockContent };
                        this.model.push(block);
                        isNewBlock = true;
                    } else {
                        // Actualizaci√≥n de un bloque existente
                        const blockIndex = this.model.findIndex(block => block.id === blockId);
                        if (blockIndex === -1) {
                            console.error("Block not found");
                            return;
                        }
                        block = this.model[blockIndex];
                        block.content = blockContent;
                    }

                    // Recalcular campos que dependen del contenido actualizado.
                    // Para nuevos bloques, esto tambi√©n establecer√° contentParsed correctamente.
                    if (!isNewBlock || block.content) {
                        const blockIndex = this.model.findIndex(b => b.id === block.id);
                        this.updateDependentModelBlockFields(blockIndex);
                    }

                    // Siempre devuelve el bloque para operaciones de creaci√≥n. Para actualizaciones,
                    // el bloque ya est√° actualizado en el modelo.
                    return block;
                },

                determineBlockType(firstLine) {
                    if (/^\s*(-\s+)?#(\s|#)/.test(firstLine)) {
                        return 'section';
                    }
                    return 'item';
                },

                determineDepthLevel(firstLine) {
                    return firstLine.startsWith('#') ? firstLine.match(/^#+/)[0].length : 0;
                },

                determineInstanceClass(blockContent, type) {
                    if (type === 'section') {
                        const match = blockContent.match(/^\s*#+\s*(#[^\s]+)/);
                        if (match && match[1] && !/^#+$/.test(match[1])) {
                            return match[1].substring(1);
                        }
                    }
                    return null;
                },

                processTags(blockContent) {
                    const markerSymbols = this.markerSymbols;
                    // Capturing markers: strings starting with # followed by one of the special marker symbols
                    const markers = [...blockContent.matchAll(/(?:^|\s)#([>!*?+^-][^\s]*)/g)].map(match => match[1]);
                    const markersParsed = markers.map(marker => this.parseMarker(marker)).join(' ');

                    // Adjusted regular expression for capturing tags
                    const tagsRegex = /(?:^|\s)(#[^\s#][^\s]*)/g;
                    const tags = [];
                    let match;
                    while ((match = tagsRegex.exec(blockContent)) !== null) {
                        // Avoid infinite loops with zero-width matches
                        if (match.index === tagsRegex.lastIndex) {
                            tagsRegex.lastIndex++;
                        }

                        // Exclude markers from the tags array
                        if (!markerSymbols.some(symbol => match[1].startsWith(`#${symbol}`))) {
                            tags.push(match[1].substring(1)); // Remove leading # for consistency with your original logic
                        }
                    }
                    const tagsParsed = tags.map(tag => this.parseTag(tag)).join(' ');

                    return { markers, markersParsed, tags, tagsParsed };
                },

                parseMarker(marker) {
                    // Assumes implementation of converting marker to HTML span remains the same
                    return `<span class="marker">${marker}</span>`;
                },

                parseTag(tag) {
                    // Assumes implementation of converting tag to HTML span remains the same
                    return `<span class="tag">${tag}</span>`;
                }
                ,

                parseMarker(marker) {
                    return `<span data-marker="${marker}">#${marker}</span>`;
                },

                parseTag(tag) {
                    return `<span data-tag="${tag}">#${tag}</span>`;
                },

                extractBlockTitle(blockContent) {
                    const firstLine = blockContent.split(/\r?\n/)[0]; // Obtiene la primera l√≠nea

                    // Extrae el encabezado Markdown y la primera etiqueta (si existe) que est√© directamente despu√©s del encabezado
                    const matches = firstLine.match(/^(#+\s*)(#[^\s]+)?\s*(.*)/);
                    if (matches) {
                        const markdownHeader = matches[1]; // Encabezado Markdown (p.ej., '###')
                        const directTag = matches[2] ? `${matches[2]} ` : ''; // La etiqueta directa despu√©s del encabezado, si existe
                        const restOfTheTitle = matches[3]; // El resto del t√≠tulo despu√©s del encabezado y la etiqueta directa

                        // Combina la etiqueta directa (si existe) y el resto del t√≠tulo, eliminando otras etiquetas
                        let title = (directTag + restOfTheTitle).replace(/#[^\s]+/g, '').trim();

                        // Elimina cualquier n√∫mero de '#' que puedan existir al principio del valor de la variable title y est√©n seguidos de un espacio
                        title = title.replace(/^#+\s*/, '');

                        console.log('Returning title with matches:', title); // Traza antes del return
                        return title;
                    }

                    // En caso de que no haya coincidencia, retorna la l√≠nea completa, pero tambi√©n limpiamos posibles '#' al inicio aqu√≠.
                    // Se asegura que se aplique la eliminaci√≥n de '#' seguidos de un espacio para todos los casos.
                    const finalTitle = firstLine.replace(/^#+\s*/, '').trim();
                    console.log('Returning title without matches:', finalTitle); // Traza antes del return
                    return finalTitle;
                    // Asegurarse de devolver una cadena vac√≠a si el t√≠tulo no se encuentra
                    return title || '';
                },

                setInstanceValue(title) {
                    console.log("üöÄ ~ setInstanceValue ~ title:", title)
                    // Verifica si title es una cadena
                    if (typeof title !== "string") {
                        console.log("title debe ser una cadena.setInstanceValue ~ title:", title);
                        return ""; // Retorna una cadena vac√≠a o maneja el caso como prefieras
                    }

                    // Initial assignment based on title starting with a hashtag
                    if (/^#\w+/.test(title)) {
                        this.instanceValue = title;
                    }

                    // Extract component after the initial tag and dash, refining instanceValue
                    const titleParts = title.match(/^#\w+\s+(.*?)\s*(-|$)/);
                    console.log("üöÄ ~ setInstanceValue ~ titleParts:", titleParts)
                    if (titleParts && titleParts[1]) {
                        this.instanceValue = titleParts[1].replace(/#\w+/g, '').trim();
                    } else if (title.includes('-')) {
                        this.instanceValue = title.split('-')[0].trim();
                    } else {
                        this.instanceValue = title.trim();
                    }
                    console.log("üöÄ ~ setInstanceValue ~ this.instanceValue:", this.instanceValue)
                    return this.instanceValue;
                },

                generateMetamodelID(title, instanceClass) {
                    // Si instanceClass est√° vac√≠o o es null, retorna directamente el title
                    if (!instanceClass) {
                        return title;
                    }

                    // Si instanceClass no est√° vac√≠o y el t√≠tulo no contiene un gui√≥n con un espacio a cada lado
                    if (instanceClass && !title.includes(" - ")) {
                        return `${instanceClass} Name`;
                    }

                    // Si instanceClass no est√° vac√≠o y el t√≠tulo contiene un gui√≥n con un espacio a cada lado
                    if (instanceClass && title.includes(" - ")) {
                        // Extrae el texto a la derecha del gui√≥n, incluyendo el gui√≥n y los espacios
                        const titleAfterDash = title.substring(title.indexOf(" - ") + 3);
                        // Construye metamodelID usando instanceClass y el texto a la derecha del gui√≥n, reemplazando el inicio del t√≠tulo por "Name"
                        return `${instanceClass} Name - ${titleAfterDash}`;
                    }

                    // En cualquier otro caso (por precauci√≥n), retorna el t√≠tulo
                    return title;
                },

                importMetamodelData(metamodelID) {
                    console.log("üöÄ ~ importMetamodelData ~ metamodelID:", metamodelID)
                    // Encuentra la secci√≥n que coincide con el metamodelID proporcionado.
                    const section = this.metamodel.sections.find((section) => section.name === metamodelID);

                    if (section) {
                        console.log("üöÄ ~ importMetamodelData ~ section:", section)
                        return section;
                    }
                    console.log('No se encontr√≥ ninguna secci√≥n que coincida con el metamodelID:', metamodelID);
                    return null;
                },

                parseToHTML(content) {
                    // Define un array con los s√≠mbolos que usan los markers
                    const markerSymbols = this.markerSymbols;

                    // Procesa etiquetas y marcadores primero
                    let processedTagsContent = content.replace(/(^|\s)(#[^\s#]+)/g, (match, p1, p2) => {
                        if (markerSymbols.some(symbol => p2[1] === symbol)) {
                            // Si es un marcador
                            return `${p1}${this.parseMarker(p2.slice(1))}`;
                        } else {
                            // Si es una etiqueta
                            return `${p1}${this.parseTag(p2.slice(1))}`;
                        }
                    });

                    // Luego convierte los encabezados Markdown a HTML l√≠nea por l√≠nea
                    // Esto evita convertir todo el texto con marked.parse directamente, lo que podr√≠a alterar el procesamiento previo
                    processedTagsContent = processedTagsContent.split('\n').map((line) => {
                        // Verifica si la l√≠nea es un encabezado Markdown
                        if (/^#+\s/.test(line)) {
                            // Convierte solo el encabezado a HTML
                            return marked.parse(line).trim(); // Usa marked para convertir a HTML y elimina espacios extra al final
                        }
                        return line;
                    }).join('<br>'); // Mantiene los saltos de l√≠nea reemplaz√°ndolos con <br> despu√©s de procesar etiquetas/marcadores y encabezados

                    return processedTagsContent;
                },

                openInfoModal(block) {
                    console.log("üöÄ ~ openInfoModal ~ block:", block)
                    this.selectedInfoBlock = block;
                    this.selectedBlockId = block.id; // Aseg√∫rate de tener selectedBlockId definido en tu data()
                    this.selectedBlockInfoURL = `https://xbokmd.github.io/plastilinn/raw.html#/docs/xBoK/sections/${block.replace(/ /g, '_')}`;
                    // Busca el √≠ndice de la l√≠nea bas√°ndose en el ID √∫nico
                    this.selectedBlockIndex = this.model.findIndex((item) => item.id === block.id);
                    this.isInfoModalOpen = true;
                    this.$nextTick(() => {
                        // Aseg√∫rate de que el contenedor del editor est√© disponible en el DOM
                        this.selectedBlockInfoURL;
                    });

                    // Definir dimensiones y posici√≥n de la ventana
                    const ancho = 900; // Ancho de la ventana
                    const alto = 600; // Alto de la ventana
                    // Calcular posici√≥n central
                    const y = window.top.outerHeight / 2 + window.top.screenY - (alto / 2);
                    const x = window.top.outerWidth / 2 + window.top.screenX - (ancho / 2);

                    // Abrir nueva ventana
                    // eslint-disable-next-line max-len
                    window.open(this.selectedBlockInfoURL, 'Modal', `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, copyhistory=no, width=${ancho}, height=${alto}, top=${y}, left=${x}`);
                },

                // EDIT BLOCK

                initEditor() {
                    if (this.editor) {
                        this.editor.destroy(); // Destruye la instancia anterior del editor
                    }
                    // eslint-disable-next-line no-undef
                    this.editor = new toastui.Editor({
                        el: document.querySelector('#editor-container'),
                        initialEditType: 'markdown',
                        previewStyle: 'tab',
                        height: '340px',
                        width: '500px',
                        hideModeSwitch: true,
                        initialValue: this.selectedBlockContent, // Asume que `editingContent` es tu contenido actual que quieres editar
                    });
                },

                openBlockEditModal(block) {
                    console.log("üöÄ ~ openBlockEditModal ~ block:", block)
                    this.selectedBlockId = block.id; // Aseg√∫rate de tener selectedBlockId definido en tu data()
                    this.selectedBlockContent = block.content;
                    this.selectedBlockMarkers = block.markers; // Aseg√∫rate de que `block` tiene una propiedad `markers`
                    // Busca el √≠ndice de la l√≠nea bas√°ndose en el ID √∫nico
                    this.selectedBlockIndex = this.model.findIndex((item) => item.id === block.id);
                    this.isBlockEditModalOpen = true;
                    this.$nextTick(() => {
                        // Aseg√∫rate de que el contenedor del editor est√© disponible en el DOM
                        this.initEditor();
                    });
                },

                generateSuggestionPrompt() {
                    let suggestionPrompt = '';
                    const block = this.model.find((b) => b.id === this.selectedBlockId);
                    const title = block ? block.title : 'Title not found';
                    const metamodelID = block ? block.metamodelID : 'metamodelID not found';
                    const { modelMarkdown } = this;
                    const blockExample = block ? block.metamodel.example : 'Example not found';
                    suggestionPrompt = `As a business model design expert for startups, you specialize in refining business models through detailed, specific feedback and brainstorming tailored to each startup's unique aspects. Your role is to assist in drafting a document that accurately describes a business model, focusing on clear, structured, and relevant advice. Your approach involves:\n\n
                    Listening closely to understand the specifics of the business.\n
                    Providing concise, targeted guidance without unnecessary repetition or formalities.\n
                    Offering step-by-step feedback to ensure the document effectively captures the business model.\n
                    You focus on the client's needs and how to best articulate their business model.\n
                    GOAL: Help the user write the "${metamodelID}" section of a document that describes his project business model. Here's some information about my Business  (delimited with XML tags):\n\n
                    <business-model>`
                        + `${modelMarkdown}\n\n`
                        + `</business-model>
                    QUESTION: Please suggest content for the "${metamodelID}" (${title}) section of the business model.
                    WRITE your answer in PLASTILINN FORMAT, which consists of the text of the answer without any comments or similar, that closely adheres to the format and style of the plastilinn (taking the {block example} as a reference example of a properly formatted answer). In your response, each list component should begin with '#tag', followed by the name, and then a description on a new line. This is an example of an answer (delimited with XML tags) for the company Space X, an aerospace manufacturer and space transportation company:\n\n
                    <example-answer>`
                        + `${blockExample}\n\n`
                        + `</example-answer>\n\n
                    You can copy/paste this answer to your plastilinn doc`;
                    return suggestionPrompt;
                },

                sendMessageToBot() {
                    const suggestionPrompt = this.generateSuggestionPrompt();
                    window.botpressWebChat.mergeConfig({ className: 'plastilinnChatBot', showCloseButton: true });
                    window.botpressWebChat.sendEvent({ type: 'show' });
                    window.botpressWebChat.sendPayload({
                        type: 'text',
                        text: suggestionPrompt,
                    });
                },

                saveChanges() {
                    const editedContent = this.editor.getMarkdown();
                    if (this.selectedBlockIndex !== null) {
                        // Encuentra el ID del bloque seleccionado para poder pasarlo al m√©todo de actualizaci√≥n.
                        const blockId = this.model[this.selectedBlockIndex].id;

                        // Actualiza el bloque utilizando el m√©todo de actualizaci√≥n que maneja la l√≥gica de recalculo.
                        this.updateModelBlockContent(blockId, editedContent);

                        // Nota: No necesitas procesar tags, title, etc., aqu√≠, ya que eso se manejar√° en el m√©todo de rec√°lculo.
                    }
                    this.updateModelMarkdown();
                    this.closeModal();

                    // Despu√©s de guardar, verifica si autoDownload est√° habilitado
                    if (this.autoDownloadEnabled) {
                        this.downloadMarkdown(); // Asume que este es tu m√©todo de descarga existente
                    }
                },

                closeModal() {
                    this.isBlockEditModalOpen = false;
                },

                // NAVIGATION

                highlightOnLoad() {
                    this.$nextTick(() => {
                        if (window.location.hash) {
                            const hash = decodeURIComponent(window.location.hash.substring(1)); // Decodifica el hash.
                            this.highlightBlock(hash);
                        }
                    });
                },

                highlightBlock(id) {
                    const element = document.getElementById(id);
                    if (element) {
                        element.classList.add('highlight');
                        setTimeout(() => element.classList.remove('highlight'), 3000);
                    }
                },

                // MODEL PROCESSING

                assignUids() {
                    let uid = 1; // Inicia el contador de UID en 1 o cualquier otro valor inicial que prefieras.
                    this.model.forEach((block) => {
                        block.uid = uid++; // Asigna el UID y luego incrementa el contador.
                    });
                    console.log('UIDs assigned to model blocks:', this.model);
                },

                updateModelMarkdown() {
                    // Inicializa una variable para almacenar el contenido concatenado
                    let concatenatedContent = '';

                    // Recorre cada elemento del array model y concatena su contenido con saltos de l√≠nea
                    this.model.forEach((item) => {
                        concatenatedContent += `${item.content}\n`;
                    });

                    // Guarda el contenido generado en el campo modelMarkdown del objeto model
                    this.modelMarkdown = concatenatedContent;
                    this.updateTagsArray();
                },

                updateTagsArray() {
                    // Cargar la lista de bloques
                    this.model.forEach((block) => block.tags.forEach((tag) => this.modelTagsArray.add(tag)));
                    // Convertir modelTagsArray a un array, ordenarlo alfab√©ticamente y luego asignar a this.tags
                    this.tags = Array.from(this.modelTagsArray).sort((a, b) => a.localeCompare(b));
                    // Inicializar el filtrado (si necesario)
                    this.filterBlocks([]);
                },

                // FILTERS

                filterBlocks(tags) {
                    this.filteredBlocks = this.model.filter((block) => tags.some((tag) => block.tags.includes(tag)));
                },

                setFilterTags(tags) {
                    // Establece las etiquetas seleccionadas directamente
                    this.selectedTags = tags;
                },

                filteredBlocksByTags(tags) {
                    return this.model.filter((block) => block.tags.some((tag) => tags.includes(tag)));
                },

                resetSelectedTags() {
                    this.selectedTags = [];
                },

                buildTagsQueryList(tags) {
                    // Filtra los bloques que contienen todas las etiquetas especificadas
                    const filteredBlocks = this.model.filter((block) => tags.every((tag) => block.tags.includes(tag)));
                    // Construye una lista de HTML con los titles de los bloques filtrados
                    let htmlList = '<ul>';
                    filteredBlocks.forEach((block) => {
                        htmlList += `<li>${block.title}</li>`;
                    });
                    htmlList += '</ul>';

                    // Devuelve la lista HTML
                    return htmlList;
                },

                // SEARCH

                highlightSearchText(text, searchTerm) {
                    console.log("üöÄ ~ highlightSearchText ~ searchTerm:", searchTerm)
                    console.log("üöÄ ~ highlightSearchText ~ text:", text)
                    if (!searchTerm.trim()) return text; // Retorna el texto original si el t√©rmino de b√∫squeda est√° vac√≠o

                    // Escapa caracteres especiales en searchTerm para su uso en una expresi√≥n regular
                    const search = searchTerm.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    const pattern = new RegExp(`(${search})`, 'gi'); // 'gi' para b√∫squeda global e insensible a may√∫sculas

                    // Reemplaza las coincidencias con el t√©rmino de b√∫squeda envuelto en un span para el resaltado
                    return text.replace(pattern, '<span class="highlight-text">$1</span>');
                },

                performSearchReplace(originalText) {
                    // Aseg√∫rate de que searchText no est√© vac√≠o y que realmente quieras usar el argumento originalText
                    if (!originalText) return; // Sale si originalText est√° vac√≠o

                    this.model.forEach((block) => {
                        // Usa la variable originalText en lugar de searchText para el reemplazo
                        block.content = block.content.replaceAll(originalText, this.replaceText);
                        // Actualiza el contenido parseado despu√©s del reemplazo para reflejar los cambios
                        block.contentParsed = this.processBlock(block.content);
                    });

                    // Restablece searchText y replaceText a cadenas vac√≠as despu√©s del reemplazo
                    this.searchText = '';
                    this.replaceText = '';
                    this.showSearchReplaceModal = false; // Cierra el modal despu√©s de realizar el reemplazo
                },

                // ARTIFACTS

                setArtifactTestDELETEME(placeholder1, placeholder2) {
                    this.artifactModalContent = `
                        <div>
                            <h3>1</h3>
                            ${placeholder1}
                        </div>
                        <div>
                            <h3>2</h3>
                            ${placeholder2}https://eslint.org/docs/latest/rules/linebreak-style
                        </div>
                    `;
                    // eslint-disable-next-line linebreak-style
                    this.isArtifactModalOpen = true;
                    // eslint-disable-next-line linebreak-style
                },

                async loadGuideMarkdownContent(url) {
                    if (url) {
                        try {
                            const response = await fetch(url);
                            const markdown = await response.text();
                            // Aqu√≠ convertir√≠as el Markdown a HTML
                            // Puedes usar la librer√≠a marked.js como antes mencion√©
                            this.markdownGuideContent = marked.parse(markdown);
                        } catch (error) {
                            console.log("üöÄ ~ loadGuideMarkdownContent ~ error:", error)
                            this.markdownContent = '';
                        }
                    } else {
                        this.markdownGuideContent = '';
                    }
                },

                setArtifactBusinessModelCanvas() {
                    this.isArtifactModalOpen = true;
                },

                // DOWNLOAD AND EXPORT

                downloadMarkdown() {
                    // Asume que modelMarkdown y modelName ya est√°n actualizados
                    const markdownContent = this.modelMarkdown; // Obtiene el valor actual de modelMarkdown
                    const { modelName } = this; // Obtiene el nombre actual del modelo
                    const timestamp = new Date().toISOString().replace(/[:-]|\.\d{3}/g, ''); // Genera un timestamp en el formato deseado
                    const fileName = `${modelName} - saved ${timestamp}.md`; // Construye el nombre del archivo

                    // Crea un Blob con el contenido Markdown
                    const blob = new Blob([markdownContent], { type: 'text/markdown' });

                    // Crea un enlace para descargar el archivo
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName;

                    // Simula un clic en el enlace para iniciar la descarga y luego limpia
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },

                downloadHTML() {
                    // Convierte el Markdown a HTML
                    // eslint-disable-next-line no-undef
                    const htmlContent = marked.parse(this.modelMarkdown);
                    const { modelName } = this; // Obtiene el nombre actual del modelo
                    const timestamp = new Date().toISOString().replace(/[:-]|\.\d{3}/g, ''); // Genera un timestamp en el formato deseado
                    const fileName = `${modelName} - saved ${timestamp}.html`; // Construye el nombre del archivo

                    // Opcional: Si quieres incluir un estilo b√°sico en tu HTML exportado, puedes agregarlo aqu√≠
                    const htmlWithStyle = `
                        <!DOCTYPE html>
                        <html lang="en">
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <title>Plastilinn</title>
                            <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
                            <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
                            <link rel="stylesheet" href="https://xbokmd.github.io/plastilinn/css.css">
                        </head>
                        <body>
                        ${htmlContent}
                        </body>
                        `;

                    // Crea un Blob con el contenido HTML
                    const blob = new Blob([htmlWithStyle], { type: 'text/html' });

                    // Crea un enlace para descargar el archivo
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName; // Puedes personalizar el nombre del archivo

                    // Simula un clic en el enlace para iniciar la descarga y luego limpia
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                },

                toggleAutoDownload() {
                    this.autoDownloadEnabled = !this.autoDownloadEnabled;
                },

            },
            mounted() {
                this.processMetamodel(); // Otras inicializaciones pueden ir aqu√≠
                this.highlightOnLoad(); // Resalta el elemento si la p√°gina se carg√≥ con un hash.
                window.addEventListener('hashchange', this.highlightOnLoad);
                if (window.botpressWebChat && typeof window.botpressWebChat.onEvent === 'function') {
                    window.botpressWebChat.onEvent((event) => {
                        if (event.type === 'message' && event.message_type === 'text') {
                            alert(`Respuesta del bot: ${event.text}`);
                        }
                    });
                } else {
                    console.warn('Botpress Web Chat is not loaded.');
                }
                // Configura marked.js para este componente
                marked.setOptions({
                    gfm: true, // Habilita GitHub Flavored Markdown (GFM)
                    breaks: true, // Convierte los saltos de l√≠nea simples en <br>
                });
            },
        })
            .mount('#vue-app');
    </script>
    <script src="https://cdn.botpress.cloud/webchat/v1/inject.js"></script>
    <script src="https://mediafiles.botpress.cloud/2aa639ac-f805-454c-b5da-6fcc527f8d70/webchat/config.js"
        defer></script>
    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
</body>

</html>